from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.Object as __object__
import py4godot.classes.UndoRedo as __undoredo__


class MergeMode:
  MERGE_DISABLE:int = 0
  MERGE_ENDS:int = 1
  MERGE_ALL:int = 2


class UndoRedo(__object__.Object):
  """
		UndoRedo works by registering methods and property changes inside "actions". You can create an action, then provide ways to do and undo this action using function calls and property changes, then commit the action.
		When an action is committed, all of the `do_*` methods will run. If the `undo` method is used, the `undo_*` methods will run. If the `redo` method is used, once again, all of the `do_*` methods will run.
		Here's an example on how to add an action:
		
		```gdscript
		var undo_redo = UndoRedo.new()

		func do_something():
			pass # Put your code here.

		func undo_something():
			pass # Put here the code that reverts what's done by "do_something()".

		func _on_my_button_pressed():
			var node = get_node("MyNode2D")
			undo_redo.create_action("Move the node")
			undo_redo.add_do_method(do_something)
			undo_redo.add_undo_method(undo_something)
			undo_redo.add_do_property(node, "position", Vector2(100, 100))
			undo_redo.add_undo_property(node, "position", node.position)
			undo_redo.commit_action()
		```
		
		
		Before calling any of the `add_(un)do_*` methods, you need to first call `create_action`. Afterwards you need to call `commit_action`.
		If you don't need to register a method, you can leave `add_do_method` and `add_undo_method` out; the same goes for properties. You can also register more than one method/property.
		If you are making an `EditorPlugin` and want to integrate into the editor's undo history, use `EditorUndoRedoManager` instead.
		If you are registering multiple properties/method which depend on one another, be aware that by default undo operation are called in the same order they have been added. Therefore instead of grouping do operation with their undo operations it is better to group do on one side and undo on the other as shown below.
		
		```gdscript
		undo_redo.create_action("Add object")

		# DO
		undo_redo.add_do_method(_create_object)
		undo_redo.add_do_method(_add_object_to_singleton)

		# UNDO
		undo_redo.add_undo_method(_remove_object_from_singleton)
		undo_redo.add_undo_method(_destroy_that_object)

		undo_redo.commit_action()
		```
		
		
	"""
  version_changed: BuiltinSignal

  @staticmethod
  def constructor()->UndoRedo:pass



  @staticmethod
  def cast(other:__object__.Object)->UndoRedo:pass


  @property
  def max_steps(self)->int:
    """"""
    pass
  @max_steps.setter
  def max_steps(self,  value:int)->None:
    """"""
    pass
  def create_action(self, name:str, merge_mode:int =0, backward_undo_ops:bool=False)->None:
    """
				Create a new action. After this is called, do all your calls to `add_do_method`, `add_undo_method`, `add_do_property`, and `add_undo_property`, then commit the action with `commit_action`.
				The way actions are merged is dictated by `merge_mode`.
				The way undo operation are ordered in actions is dictated by `backward_undo_ops`. When `backward_undo_ops` is `false` undo option are ordered in the same order they were added. Which means the first operation to be added will be the first to be undone.
			"""
    pass

  def commit_action(self, execute:bool=True)->None:
    """
				Commit the action. If `execute` is `true` (which it is by default), all "do" methods/properties are called/set when this function is called.
			"""
    pass

  def is_committing_action(self)->bool:
    """
				Returns `true` if the `UndoRedo` is currently committing the action, i.e. running its "do" method or property change (see `commit_action`).
			"""
    pass

  def add_do_method(self, callable:__core__.Callable)->None:
    """
				Register a `Callable` that will be called when the action is committed.
			"""
    pass

  def add_undo_method(self, callable:__core__.Callable)->None:
    """
				Register a `Callable` that will be called when the action is undone.
			"""
    pass

  def add_do_property(self, object:__object__.Object, property:__core__.StringName|str, value:Any)->None:
    """
				Register a `property` that would change its value to `value` when the action is committed.
			"""
    pass

  def add_undo_property(self, object:__object__.Object, property:__core__.StringName|str, value:Any)->None:
    """
				Register a `property` that would change its value to `value` when the action is undone.
			"""
    pass

  def add_do_reference(self, object:__object__.Object)->None:
    """
				Register a reference to an object that will be erased if the "do" history is deleted. This is useful for objects added by the "do" action and removed by the "undo" action.
				When the "do" history is deleted, if the object is a `RefCounted`, it will be unreferenced. Otherwise, it will be freed. Do not use for resources.
				```gdscript
				var node = Node2D.new()
				undo_redo.create_action("Add node")
				undo_redo.add_do_method(add_child.bind(node))
				undo_redo.add_do_reference(node)
				undo_redo.add_undo_method(remove_child.bind(node))
				undo_redo.commit_action()
				```
			"""
    pass

  def add_undo_reference(self, object:__object__.Object)->None:
    """
				Register a reference to an object that will be erased if the "undo" history is deleted. This is useful for objects added by the "undo" action and removed by the "do" action.
				When the "undo" history is deleted, if the object is a `RefCounted`, it will be unreferenced. Otherwise, it will be freed. Do not use for resources.
				```gdscript
				var node = $Node2D
				undo_redo.create_action("Remove node")
				undo_redo.add_do_method(remove_child.bind(node))
				undo_redo.add_undo_method(add_child.bind(node))
				undo_redo.add_undo_reference(node)
				undo_redo.commit_action()
				```
			"""
    pass

  def start_force_keep_in_merge_ends(self)->None:
    """
				Marks the next "do" and "undo" operations to be processed even if the action gets merged with another in the `constant MERGE_ENDS` mode. Return to normal operation using `end_force_keep_in_merge_ends`.
			"""
    pass

  def end_force_keep_in_merge_ends(self)->None:
    """
				Stops marking operations as to be processed even if the action gets merged with another in the `constant MERGE_ENDS` mode. See `start_force_keep_in_merge_ends`.
			"""
    pass

  def get_history_count(self)->int:
    """
				Returns how many elements are in the history.
			"""
    pass

  def get_current_action(self)->int:
    """
				Gets the index of the current action.
			"""
    pass

  def get_action_name(self, id:int)->str:
    """
				Gets the action name from its index.
			"""
    pass

  def clear_history(self, increase_version:bool=True)->None:
    """
				Clear the undo/redo history and associated references.
				Passing `false` to `increase_version` will prevent the version number from increasing when the history is cleared.
			"""
    pass

  def get_current_action_name(self)->str:
    """
				Gets the name of the current action, equivalent to `get_action_name(get_current_action())`.
			"""
    pass

  def has_undo(self)->bool:
    """
				Returns `true` if an "undo" action is available.
			"""
    pass

  def has_redo(self)->bool:
    """
				Returns `true` if a "redo" action is available.
			"""
    pass

  def get_version(self)->int:
    """
				Gets the version. Every time a new action is committed, the `UndoRedo`'s version number is increased automatically.
				This is useful mostly to check if something changed from a saved version.
			"""
    pass

  def set_max_steps(self, max_steps:int)->None:
    """"""
    pass

  def get_max_steps(self)->int:
    """"""
    pass

  def redo(self)->bool:
    """
				Redo the last action.
			"""
    pass

  def undo(self)->bool:
    """
				Undo the last action.
			"""
    pass


