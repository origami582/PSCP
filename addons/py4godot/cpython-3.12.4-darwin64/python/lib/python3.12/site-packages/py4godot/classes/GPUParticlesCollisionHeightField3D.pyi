from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.GPUParticlesCollision3D as __gpuparticlescollision3d__
import py4godot.classes.GPUParticlesCollisionHeightField3D as __gpuparticlescollisionheightfield3d__


class Resolution:
  RESOLUTION_256:int = 0
  RESOLUTION_512:int = 1
  RESOLUTION_1024:int = 2
  RESOLUTION_2048:int = 3
  RESOLUTION_4096:int = 4
  RESOLUTION_8192:int = 5
  RESOLUTION_MAX:int = 6
class UpdateMode:
  UPDATE_MODE_WHEN_MOVED:int = 0
  UPDATE_MODE_ALWAYS:int = 1


class GPUParticlesCollisionHeightField3D(__gpuparticlescollision3d__.GPUParticlesCollision3D):
  """
		A real-time heightmap-shaped 3D particle collision shape affecting `GPUParticles3D` nodes.
		Heightmap shapes allow for efficiently representing collisions for convex and concave objects with a single "floor" (such as terrain). This is less flexible than `GPUParticlesCollisionSDF3D`, but it doesn't require a baking step.
		`GPUParticlesCollisionHeightField3D` can also be regenerated in real-time when it is moved, when the camera moves, or even continuously. This makes `GPUParticlesCollisionHeightField3D` a good choice for weather effects such as rain and snow and games with highly dynamic geometry. However, this class is limited since heightmaps cannot represent overhangs (e.g. indoors or caves).
		**Note:** `ParticleProcessMaterial.collision_mode` must be `true` on the `GPUParticles3D`'s process material for collision to work.
		**Note:** Particle collision only affects `GPUParticles3D`, not `CPUParticles3D`.
	"""

  @staticmethod
  def constructor()->GPUParticlesCollisionHeightField3D:pass



  @staticmethod
  def cast(other:__object__.Object)->GPUParticlesCollisionHeightField3D:pass


  @property
  def size(self)->__core__.Vector3:
    """"""
    pass
  @size.setter
  def size(self,  value:__core__.Vector3)->None:
    """"""
    pass
  @property
  def resolution(self)->int:
    """"""
    pass
  @resolution.setter
  def resolution(self,  value:int)->None:
    """"""
    pass
  @property
  def update_mode(self)->int:
    """"""
    pass
  @update_mode.setter
  def update_mode(self,  value:int)->None:
    """"""
    pass
  @property
  def follow_camera_enabled(self)->bool:
    """"""
    pass
  @follow_camera_enabled.setter
  def follow_camera_enabled(self,  value:bool)->None:
    """"""
    pass
  @property
  def heightfield_mask(self)->int:
    """"""
    pass
  @heightfield_mask.setter
  def heightfield_mask(self,  value:int)->None:
    """"""
    pass
  def set_size(self, size:__core__.Vector3)->None:
    """"""
    pass

  def get_size(self)->__core__.Vector3:
    """"""
    pass

  def set_resolution(self, resolution:int )->None:
    """"""
    pass

  def get_resolution(self)->int:
    """"""
    pass

  def set_update_mode(self, update_mode:int )->None:
    """"""
    pass

  def get_update_mode(self)->int:
    """"""
    pass

  def set_heightfield_mask(self, heightfield_mask:int)->None:
    """"""
    pass

  def get_heightfield_mask(self)->int:
    """"""
    pass

  def set_heightfield_mask_value(self, layer_number:int, value:bool)->None:
    """
				Based on `value`, enables or disables the specified layer in the `heightfield_mask`, given a `layer_number` between `1` and `20`, inclusive.
			"""
    pass

  def get_heightfield_mask_value(self, layer_number:int)->bool:
    """
				Returns `true` if the specified layer of the `heightfield_mask` is enabled, given a `layer_number` between `1` and `20`, inclusive.
			"""
    pass

  def set_follow_camera_enabled(self, enabled:bool)->None:
    """"""
    pass

  def is_follow_camera_enabled(self)->bool:
    """"""
    pass


