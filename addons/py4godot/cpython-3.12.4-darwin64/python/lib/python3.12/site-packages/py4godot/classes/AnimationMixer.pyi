from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.r as __r__
import py4godot.classes.g as __g__
import py4godot.classes.t as __t__
import py4godot.classes.a as __a__
import py4godot.classes.AnimationPlayer as __animationplayer__
import py4godot.classes.n as __n__
import py4godot.classes.S as __s__
import py4godot.classes.A as __a__
import py4godot.classes.d as __d__
import py4godot.classes.AnimationLibrary as __animationlibrary__
import py4godot.classes.Tween as __tween__
import py4godot.classes.m as __m__
import py4godot.classes.i as __i__
import py4godot.classes.Animation as __animation__
import py4godot.classes.Node as __node__
import py4godot.classes.N as __n__
import py4godot.classes.p as __p__
import py4godot.classes.y as __y__
import py4godot.classes.e as __e__
import py4godot.classes.AnimationTree as __animationtree__
import py4godot.classes.T as __t__
import py4godot.classes.AnimationMixer as __animationmixer__


class AnimationCallbackModeProcess:
  ANIMATION_CALLBACK_MODE_PROCESS_PHYSICS:int = 0
  ANIMATION_CALLBACK_MODE_PROCESS_IDLE:int = 1
  ANIMATION_CALLBACK_MODE_PROCESS_MANUAL:int = 2
class AnimationCallbackModeMethod:
  ANIMATION_CALLBACK_MODE_METHOD_DEFERRED:int = 0
  ANIMATION_CALLBACK_MODE_METHOD_IMMEDIATE:int = 1
class AnimationCallbackModeDiscrete:
  ANIMATION_CALLBACK_MODE_DISCRETE_DOMINANT:int = 0
  ANIMATION_CALLBACK_MODE_DISCRETE_RECESSIVE:int = 1
  ANIMATION_CALLBACK_MODE_DISCRETE_FORCE_CONTINUOUS:int = 2


class AnimationMixer(__node__.Node):
  """
		Base class for `AnimationPlayer` and `AnimationTree` to manage animation lists. It also has general properties and methods for playback and blending.
		After instantiating the playback information data within the extended class, the blending is processed by the `AnimationMixer`.
	"""
  animation_list_changed: BuiltinSignal
  animation_libraries_updated: BuiltinSignal
  animation_finished: BuiltinSignal
  animation_started: BuiltinSignal
  caches_cleared: BuiltinSignal
  mixer_applied: BuiltinSignal
  mixer_updated: BuiltinSignal

  @staticmethod
  def constructor()->AnimationMixer:pass



  @staticmethod
  def cast(other:__object__.Object)->AnimationMixer:pass


  @property
  def active(self)->bool:
    """"""
    pass
  @active.setter
  def active(self,  value:bool)->None:
    """"""
    pass
  @property
  def deterministic(self)->bool:
    """"""
    pass
  @deterministic.setter
  def deterministic(self,  value:bool)->None:
    """"""
    pass
  @property
  def reset_on_save(self)->bool:
    """"""
    pass
  @reset_on_save.setter
  def reset_on_save(self,  value:bool)->None:
    """"""
    pass
  @property
  def root_node(self)->__core__.NodePath:
    """"""
    pass
  @root_node.setter
  def root_node(self,  value:__core__.NodePath)->None:
    """"""
    pass
  @property
  def root_motion_track(self)->__core__.NodePath:
    """"""
    pass
  @root_motion_track.setter
  def root_motion_track(self,  value:__core__.NodePath)->None:
    """"""
    pass
  @property
  def root_motion_local(self)->bool:
    """"""
    pass
  @root_motion_local.setter
  def root_motion_local(self,  value:bool)->None:
    """"""
    pass
  @property
  def audio_max_polyphony(self)->int:
    """"""
    pass
  @audio_max_polyphony.setter
  def audio_max_polyphony(self,  value:int)->None:
    """"""
    pass
  @property
  def callback_mode_process(self)->int:
    """"""
    pass
  @callback_mode_process.setter
  def callback_mode_process(self,  value:int)->None:
    """"""
    pass
  @property
  def callback_mode_method(self)->int:
    """"""
    pass
  @callback_mode_method.setter
  def callback_mode_method(self,  value:int)->None:
    """"""
    pass
  @property
  def callback_mode_discrete(self)->int:
    """"""
    pass
  @callback_mode_discrete.setter
  def callback_mode_discrete(self,  value:int)->None:
    """"""
    pass
  def _post_process_key_value(self, animation:__animation__.Animation, track:int, value:Any, object_id:int, object_sub_idx:int)->Any:
    """
				A virtual function for processing after getting a key during playback.
			"""
    pass

  def add_animation_library(self, name:__core__.StringName|str, library:__animationlibrary__.AnimationLibrary)->int:
    """
				Adds `library` to the animation player, under the key `name`.
				AnimationMixer has a global library by default with an empty string as key. For adding an animation to the global library:
				
				```gdscript
				var global_library = mixer.get_animation_library("")
				global_library.add_animation("animation_name", animation_resource)
				```
				
			"""
    pass

  def remove_animation_library(self, name:__core__.StringName|str)->None:
    """
				Removes the `AnimationLibrary` associated with the key `name`.
			"""
    pass

  def rename_animation_library(self, name:__core__.StringName|str, newname:__core__.StringName|str)->None:
    """
				Moves the `AnimationLibrary` associated with the key `name` to the key `newname`.
			"""
    pass

  def has_animation_library(self, name:__core__.StringName|str)->bool:
    """
				Returns `true` if the `AnimationMixer` stores an `AnimationLibrary` with key `name`.
			"""
    pass

  def get_animation_library(self, name:__core__.StringName|str)->__animationlibrary__.AnimationLibrary:
    """
				Returns the first `AnimationLibrary` with key `name` or `null` if not found.
				To get the `AnimationMixer`'s global animation library, use `get_animation_library("")`.
			"""
    pass

  def get_animation_library_list(self)->typedarray::StringName:
    """
				Returns the list of stored library keys.
			"""
    pass

  def has_animation(self, name:__core__.StringName|str)->bool:
    """
				Returns `true` if the `AnimationMixer` stores an `Animation` with key `name`.
			"""
    pass

  def get_animation(self, name:__core__.StringName|str)->__animation__.Animation:
    """
				Returns the `Animation` with the key `name`. If the animation does not exist, `null` is returned and an error is logged.
			"""
    pass

  def get_animation_list(self)->__core__.PackedStringArray:
    """
				Returns the list of stored animation keys.
			"""
    pass

  def set_active(self, active:bool)->None:
    """"""
    pass

  def is_active(self)->bool:
    """"""
    pass

  def set_deterministic(self, deterministic:bool)->None:
    """"""
    pass

  def is_deterministic(self)->bool:
    """"""
    pass

  def set_root_node(self, path:__core__.NodePath|str)->None:
    """"""
    pass

  def get_root_node(self)->__core__.NodePath:
    """"""
    pass

  def set_callback_mode_process(self, mode:int )->None:
    """"""
    pass

  def get_callback_mode_process(self)->int:
    """"""
    pass

  def set_callback_mode_method(self, mode:int )->None:
    """"""
    pass

  def get_callback_mode_method(self)->int:
    """"""
    pass

  def set_callback_mode_discrete(self, mode:int )->None:
    """"""
    pass

  def get_callback_mode_discrete(self)->int:
    """"""
    pass

  def set_audio_max_polyphony(self, max_polyphony:int)->None:
    """"""
    pass

  def get_audio_max_polyphony(self)->int:
    """"""
    pass

  def set_root_motion_track(self, path:__core__.NodePath|str)->None:
    """"""
    pass

  def get_root_motion_track(self)->__core__.NodePath:
    """"""
    pass

  def set_root_motion_local(self, enabled:bool)->None:
    """"""
    pass

  def is_root_motion_local(self)->bool:
    """"""
    pass

  def get_root_motion_position(self)->__core__.Vector3:
    """
				Retrieve the motion delta of position with the `root_motion_track` as a `Vector3` that can be used elsewhere.
				If `root_motion_track` is not a path to a track of type `constant Animation.TYPE_POSITION_3D`, returns `Vector3(0, 0, 0)`.
				See also `root_motion_track` and `RootMotionView`.
				The most basic example is applying position to `CharacterBody3D`:
				
				```gdscript
				var current_rotation

				func _process(delta):
					if Input.is_action_just_pressed("animate"):
						current_rotation = get_quaternion()
						state_machine.travel("Animate")
					var velocity = current_rotation * animation_tree.get_root_motion_position() / delta
					set_velocity(velocity)
					move_and_slide()
				```
				
				By using this in combination with `get_root_motion_rotation_accumulator`, you can apply the root motion position more correctly to account for the rotation of the node.
				
				```gdscript
				func _process(delta):
					if Input.is_action_just_pressed("animate"):
						state_machine.travel("Animate")
					set_quaternion(get_quaternion() * animation_tree.get_root_motion_rotation())
					var velocity = (animation_tree.get_root_motion_rotation_accumulator().inverse() * get_quaternion()) * animation_tree.get_root_motion_position() / delta
					set_velocity(velocity)
					move_and_slide()
				```
				
				If `root_motion_local` is `true`, returns the pre-multiplied translation value with the inverted rotation.
				In this case, the code can be written as follows:
				
				```gdscript
				func _process(delta):
					if Input.is_action_just_pressed("animate"):
						state_machine.travel("Animate")
					set_quaternion(get_quaternion() * animation_tree.get_root_motion_rotation())
					var velocity = get_quaternion() * animation_tree.get_root_motion_position() / delta
					set_velocity(velocity)
					move_and_slide()
				```
				
			"""
    pass

  def get_root_motion_rotation(self)->__core__.Quaternion:
    """
				Retrieve the motion delta of rotation with the `root_motion_track` as a `Quaternion` that can be used elsewhere.
				If `root_motion_track` is not a path to a track of type `constant Animation.TYPE_ROTATION_3D`, returns `Quaternion(0, 0, 0, 1)`.
				See also `root_motion_track` and `RootMotionView`.
				The most basic example is applying rotation to `CharacterBody3D`:
				
				```gdscript
				func _process(delta):
					if Input.is_action_just_pressed("animate"):
						state_machine.travel("Animate")
					set_quaternion(get_quaternion() * animation_tree.get_root_motion_rotation())
				```
				
			"""
    pass

  def get_root_motion_scale(self)->__core__.Vector3:
    """
				Retrieve the motion delta of scale with the `root_motion_track` as a `Vector3` that can be used elsewhere.
				If `root_motion_track` is not a path to a track of type `constant Animation.TYPE_SCALE_3D`, returns `Vector3(0, 0, 0)`.
				See also `root_motion_track` and `RootMotionView`.
				The most basic example is applying scale to `CharacterBody3D`:
				
				```gdscript
				var current_scale = Vector3(1, 1, 1)
				var scale_accum = Vector3(1, 1, 1)

				func _process(delta):
					if Input.is_action_just_pressed("animate"):
						current_scale = get_scale()
						scale_accum = Vector3(1, 1, 1)
						state_machine.travel("Animate")
					scale_accum += animation_tree.get_root_motion_scale()
					set_scale(current_scale * scale_accum)
				```
				
			"""
    pass

  def get_root_motion_position_accumulator(self)->__core__.Vector3:
    """
				Retrieve the blended value of the position tracks with the `root_motion_track` as a `Vector3` that can be used elsewhere.
				This is useful in cases where you want to respect the initial key values of the animation.
				For example, if an animation with only one key `Vector3(0, 0, 0)` is played in the previous frame and then an animation with only one key `Vector3(1, 0, 1)` is played in the next frame, the difference can be calculated as follows:
				
				```gdscript
				var prev_root_motion_position_accumulator

				func _process(delta):
					if Input.is_action_just_pressed("animate"):
						state_machine.travel("Animate")
					var current_root_motion_position_accumulator = animation_tree.get_root_motion_position_accumulator()
					var difference = current_root_motion_position_accumulator - prev_root_motion_position_accumulator
					prev_root_motion_position_accumulator = current_root_motion_position_accumulator
					transform.origin += difference
				```
				
				However, if the animation loops, an unintended discrete change may occur, so this is only useful for some simple use cases.
			"""
    pass

  def get_root_motion_rotation_accumulator(self)->__core__.Quaternion:
    """
				Retrieve the blended value of the rotation tracks with the `root_motion_track` as a `Quaternion` that can be used elsewhere.
				This is necessary to apply the root motion position correctly, taking rotation into account. See also `get_root_motion_position`.
				Also, this is useful in cases where you want to respect the initial key values of the animation.
				For example, if an animation with only one key `Quaternion(0, 0, 0, 1)` is played in the previous frame and then an animation with only one key `Quaternion(0, 0.707, 0, 0.707)` is played in the next frame, the difference can be calculated as follows:
				
				```gdscript
				var prev_root_motion_rotation_accumulator

				func _process(delta):
					if Input.is_action_just_pressed("animate"):
						state_machine.travel("Animate")
					var current_root_motion_rotation_accumulator = animation_tree.get_root_motion_rotation_accumulator()
					var difference = prev_root_motion_rotation_accumulator.inverse() * current_root_motion_rotation_accumulator
					prev_root_motion_rotation_accumulator = current_root_motion_rotation_accumulator
					transform.basis *=  Basis(difference)
				```
				
				However, if the animation loops, an unintended discrete change may occur, so this is only useful for some simple use cases.
			"""
    pass

  def get_root_motion_scale_accumulator(self)->__core__.Vector3:
    """
				Retrieve the blended value of the scale tracks with the `root_motion_track` as a `Vector3` that can be used elsewhere.
				For example, if an animation with only one key `Vector3(1, 1, 1)` is played in the previous frame and then an animation with only one key `Vector3(2, 2, 2)` is played in the next frame, the difference can be calculated as follows:
				
				```gdscript
				var prev_root_motion_scale_accumulator

				func _process(delta):
					if Input.is_action_just_pressed("animate"):
						state_machine.travel("Animate")
					var current_root_motion_scale_accumulator = animation_tree.get_root_motion_scale_accumulator()
					var difference = current_root_motion_scale_accumulator - prev_root_motion_scale_accumulator
					prev_root_motion_scale_accumulator = current_root_motion_scale_accumulator
					transform.basis = transform.basis.scaled(difference)
				```
				
				However, if the animation loops, an unintended discrete change may occur, so this is only useful for some simple use cases.
			"""
    pass

  def clear_caches(self)->None:
    """
				`AnimationMixer` caches animated nodes. It may not notice if a node disappears; `clear_caches` forces it to update the cache again.
			"""
    pass

  def advance(self, delta:float)->None:
    """
				Manually advance the animations by the specified time (in seconds).
			"""
    pass

  def capture(self, name:__core__.StringName|str, duration:float, trans_type:int =0, ease_type:int =0)->None:
    """
				If the animation track specified by `name` has an option `constant Animation.UPDATE_CAPTURE`, stores current values of the objects indicated by the track path as a cache. If there is already a captured cache, the old cache is discarded.
				After this it will interpolate with current animation blending result during the playback process for the time specified by `duration`, working like a crossfade.
				You can specify `trans_type` as the curve for the interpolation. For better results, it may be appropriate to specify `constant Tween.TRANS_LINEAR` for cases where the first key of the track begins with a non-zero value or where the key value does not change, and `constant Tween.TRANS_QUAD` for cases where the key value changes linearly.
			"""
    pass

  def set_reset_on_save_enabled(self, enabled:bool)->None:
    """"""
    pass

  def is_reset_on_save_enabled(self)->bool:
    """"""
    pass

  def find_animation(self, animation:__animation__.Animation)->__core__.StringName:
    """
				Returns the key of `animation` or an empty `StringName` if not found.
			"""
    pass

  def find_animation_library(self, animation:__animation__.Animation)->__core__.StringName:
    """
				Returns the key for the `AnimationLibrary` that contains `animation` or an empty `StringName` if not found.
			"""
    pass


