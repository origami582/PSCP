from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.CryptoKey as __cryptokey__
import py4godot.classes.HashingContext as __hashingcontext__
import py4godot.classes.X509Certificate as __x509certificate__
import py4godot.classes.RefCounted as __refcounted__



class Crypto(__refcounted__.RefCounted):
  """
		The Crypto class provides access to advanced cryptographic functionalities.
		Currently, this includes asymmetric key encryption/decryption, signing/verification, and generating cryptographically secure random bytes, RSA keys, HMAC digests, and self-signed `X509Certificate`s.
		
		```gdscript
		var crypto = Crypto.new()

		# Generate new RSA key.
		var key = crypto.generate_rsa(4096)

		# Generate new self-signed certificate with the given key.
		var cert = crypto.generate_self_signed_certificate(key, "CN=mydomain.com,O=My Game Company,C=IT")

		# Save key and certificate in the user folder.
		key.save("user://generated.key")
		cert.save("user://generated.crt")

		# Encryption
		var data = "Some data"
		var encrypted = crypto.encrypt(key, data.to_utf8_buffer())

		# Decryption
		var decrypted = crypto.decrypt(key, encrypted)

		# Signing
		var signature = crypto.sign(HashingContext.HASH_SHA256, data.sha256_buffer(), key)

		# Verifying
		var verified = crypto.verify(HashingContext.HASH_SHA256, data.sha256_buffer(), signature, key)

		# Checks
		assert(verified)
		assert(data.to_utf8_buffer() == decrypted)
		```
		
		
	"""

  @staticmethod
  def constructor()->Crypto:pass



  @staticmethod
  def cast(other:__object__.Object)->Crypto:pass


  def generate_random_bytes(self, size:int)->__core__.PackedByteArray:
    """
				Generates a `PackedByteArray` of cryptographically secure random bytes with given `size`.
			"""
    pass

  def generate_rsa(self, size:int)->__cryptokey__.CryptoKey:
    """
				Generates an RSA `CryptoKey` that can be used for creating self-signed certificates and passed to `StreamPeerTLS.accept_stream`.
			"""
    pass

  def generate_self_signed_certificate(self, key:__cryptokey__.CryptoKey, issuer_name:str= __core__.String.new0(), not_before:str= __core__.String.new0(), not_after:str= __core__.String.new0())->__x509certificate__.X509Certificate:
    """
				Generates a self-signed `X509Certificate` from the given `CryptoKey` and `issuer_name`. The certificate validity will be defined by `not_before` and `not_after` (first valid date and last valid date). The `issuer_name` must contain at least "CN=" (common name, i.e. the domain name), "O=" (organization, i.e. your company name), "C=" (country, i.e. 2 lettered ISO-3166 code of the country the organization is based in).
				A small example to generate an RSA key and an X509 self-signed certificate.
				
				```gdscript
				var crypto = Crypto.new()
				# Generate 4096 bits RSA key.
				var key = crypto.generate_rsa(4096)
				# Generate self-signed certificate using the given key.
				var cert = crypto.generate_self_signed_certificate(key, "CN=example.com,O=A Game Company,C=IT")
				```
				
				
			"""
    pass

  def sign(self, hash_type:int , hash:__core__.PackedByteArray, key:__cryptokey__.CryptoKey)->__core__.PackedByteArray:
    """
				Sign a given `hash` of type `hash_type` with the provided private `key`.
			"""
    pass

  def verify(self, hash_type:int , hash:__core__.PackedByteArray, signature:__core__.PackedByteArray, key:__cryptokey__.CryptoKey)->bool:
    """
				Verify that a given `signature` for `hash` of type `hash_type` against the provided public `key`.
			"""
    pass

  def encrypt(self, key:__cryptokey__.CryptoKey, plaintext:__core__.PackedByteArray)->__core__.PackedByteArray:
    """
				Encrypt the given `plaintext` with the provided public `key`.
				**Note:** The maximum size of accepted plaintext is limited by the key size.
			"""
    pass

  def decrypt(self, key:__cryptokey__.CryptoKey, ciphertext:__core__.PackedByteArray)->__core__.PackedByteArray:
    """
				Decrypt the given `ciphertext` with the provided private `key`.
				**Note:** The maximum size of accepted ciphertext is limited by the key size.
			"""
    pass

  def hmac_digest(self, hash_type:int , key:__core__.PackedByteArray, msg:__core__.PackedByteArray)->__core__.PackedByteArray:
    """
				Generates an `url=https://en.wikipedia.org/wiki/HMAC`HMAC`/url` digest of `msg` using `key`. The `hash_type` parameter is the hashing algorithm that is used for the inner and outer hashes.
				Currently, only `constant HashingContext.HASH_SHA256` and `constant HashingContext.HASH_SHA1` are supported.
			"""
    pass

  def constant_time_compare(self, trusted:__core__.PackedByteArray, received:__core__.PackedByteArray)->bool:
    """
				Compares two `PackedByteArray`s for equality without leaking timing information in order to prevent timing attacks.
				See `url=https://paragonie.com/blog/2015/11/preventing-timing-attacks-on-string-comparison-with-double-hmac-strategy`this blog post`/url` for more information.
			"""
    pass


