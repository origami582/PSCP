from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.AESContext as __aescontext__
import py4godot.classes.RefCounted as __refcounted__


class Mode:
  MODE_ECB_ENCRYPT:int = 0
  MODE_ECB_DECRYPT:int = 1
  MODE_CBC_ENCRYPT:int = 2
  MODE_CBC_DECRYPT:int = 3
  MODE_MAX:int = 4


class AESContext(__refcounted__.RefCounted):
  """
		This class holds the context information required for encryption and decryption operations with AES (Advanced Encryption Standard). Both AES-ECB and AES-CBC modes are supported.
		
		```gdscript
		extends Node

		var aes = AESContext.new()

		func _ready():
			var key = "My secret key!!!" # Key must be either 16 or 32 bytes.
			var data = "My secret text!!" # Data size must be multiple of 16 bytes, apply padding if needed.
			# Encrypt ECB
			aes.start(AESContext.MODE_ECB_ENCRYPT, key.to_utf8_buffer())
			var encrypted = aes.update(data.to_utf8_buffer())
			aes.finish()
			# Decrypt ECB
			aes.start(AESContext.MODE_ECB_DECRYPT, key.to_utf8_buffer())
			var decrypted = aes.update(encrypted)
			aes.finish()
			# Check ECB
			assert(decrypted == data.to_utf8_buffer())

			var iv = "My secret iv!!!!" # IV must be of exactly 16 bytes.
			# Encrypt CBC
			aes.start(AESContext.MODE_CBC_ENCRYPT, key.to_utf8_buffer(), iv.to_utf8_buffer())
			encrypted = aes.update(data.to_utf8_buffer())
			aes.finish()
			# Decrypt CBC
			aes.start(AESContext.MODE_CBC_DECRYPT, key.to_utf8_buffer(), iv.to_utf8_buffer())
			decrypted = aes.update(encrypted)
			aes.finish()
			# Check CBC
			assert(decrypted == data.to_utf8_buffer())
		```
		
		
	"""

  @staticmethod
  def constructor()->AESContext:pass



  @staticmethod
  def cast(other:__object__.Object)->AESContext:pass


  def start(self, mode:int , key:__core__.PackedByteArray, iv:__core__.PackedByteArray= __core__.PackedByteArray.new0())->int:
    """
				Start the AES context in the given `mode`. A `key` of either 16 or 32 bytes must always be provided, while an `iv` (initialization vector) of exactly 16 bytes, is only needed when `mode` is either `constant MODE_CBC_ENCRYPT` or `constant MODE_CBC_DECRYPT`.
			"""
    pass

  def update(self, src:__core__.PackedByteArray)->__core__.PackedByteArray:
    """
				Run the desired operation for this AES context. Will return a `PackedByteArray` containing the result of encrypting (or decrypting) the given `src`. See `start` for mode of operation.
				**Note:** The size of `src` must be a multiple of 16. Apply some padding if needed.
			"""
    pass

  def get_iv_state(self)->__core__.PackedByteArray:
    """
				Get the current IV state for this context (IV gets updated when calling `update`). You normally don't need this function.
				**Note:** This function only makes sense when the context is started with `constant MODE_CBC_ENCRYPT` or `constant MODE_CBC_DECRYPT`.
			"""
    pass

  def finish(self)->None:
    """
				Close this AES context so it can be started again. See `start`.
			"""
    pass


