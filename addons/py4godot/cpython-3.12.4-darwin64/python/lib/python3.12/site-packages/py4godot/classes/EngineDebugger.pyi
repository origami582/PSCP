from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.Object as __object__
import py4godot.classes.ScriptLanguage as __scriptlanguage__
import py4godot.classes.EngineProfiler as __engineprofiler__



class EngineDebugger(__object__.Object):
  """
		`EngineDebugger` handles the communication between the editor and the running game. It is active in the running game. Messages can be sent/received through it. It also manages the profilers.
	"""



  @staticmethod
  def cast(other:__object__.Object)->EngineDebugger:pass

  @staticmethod
  def instance()->EngineDebugger:pass

  def is_active(self)->bool:
    """
				Returns `true` if the debugger is active otherwise `false`.
			"""
    pass

  def register_profiler(self, name:__core__.StringName|str, profiler:__engineprofiler__.EngineProfiler)->None:
    """
				Registers a profiler with the given `name`. See `EngineProfiler` for more information.
			"""
    pass

  def unregister_profiler(self, name:__core__.StringName|str)->None:
    """
				Unregisters a profiler with given `name`.
			"""
    pass

  def is_profiling(self, name:__core__.StringName|str)->bool:
    """
				Returns `true` if a profiler with the given name is present and active otherwise `false`.
			"""
    pass

  def has_profiler(self, name:__core__.StringName|str)->bool:
    """
				Returns `true` if a profiler with the given name is present otherwise `false`.
			"""
    pass

  def profiler_add_frame_data(self, name:__core__.StringName|str, data:__core__.Array)->None:
    """
				Calls the `add` callable of the profiler with given `name` and `data`.
			"""
    pass

  def profiler_enable(self, name:__core__.StringName|str, enable:bool, arguments:__core__.Array= __core__.Array.new0())->None:
    """
				Calls the `toggle` callable of the profiler with given `name` and `arguments`. Enables/Disables the same profiler depending on `enable` argument.
			"""
    pass

  def register_message_capture(self, name:__core__.StringName|str, callable:__core__.Callable)->None:
    """
				Registers a message capture with given `name`. If `name` is "my_message" then messages starting with "my_message:" will be called with the given callable.
				The callable must accept a message string and a data array as argument. The callable should return `true` if the message is recognized.
				**Note:** The callable will receive the message with the prefix stripped, unlike `EditorDebuggerPlugin._capture`. See the `EditorDebuggerPlugin` description for an example.
			"""
    pass

  def unregister_message_capture(self, name:__core__.StringName|str)->None:
    """
				Unregisters the message capture with given `name`.
			"""
    pass

  def has_capture(self, name:__core__.StringName|str)->bool:
    """
				Returns `true` if a capture with the given name is present otherwise `false`.
			"""
    pass

  def line_poll(self)->None:
    """
				Forces a processing loop of debugger events. The purpose of this method is just processing events every now and then when the script might get too busy, so that bugs like infinite loops can be caught.
			"""
    pass

  def send_message(self, message:str, data:__core__.Array)->None:
    """
				Sends a message with given `message` and `data` array.
			"""
    pass

  def debug(self, can_continue:bool=True, is_error_breakpoint:bool=False)->None:
    """
				Starts a debug break in script execution, optionally specifying whether the program can continue based on `can_continue` and whether the break was due to a breakpoint.
			"""
    pass

  def script_debug(self, language:__scriptlanguage__.ScriptLanguage, can_continue:bool=True, is_error_breakpoint:bool=False)->None:
    """
				Starts a debug break in script execution, optionally specifying whether the program can continue based on `can_continue` and whether the break was due to a breakpoint.
			"""
    pass

  def set_lines_left(self, lines:int)->None:
    """
				Sets the current debugging lines that remain.
			"""
    pass

  def get_lines_left(self)->int:
    """
				Returns the number of lines that remain.
			"""
    pass

  def set_depth(self, depth:int)->None:
    """
				Sets the current debugging depth.
			"""
    pass

  def get_depth(self)->int:
    """
				Returns the current debug depth.
			"""
    pass

  def is_breakpoint(self, line:int, source:__core__.StringName|str)->bool:
    """
				Returns `true` if the given `source` and `line` represent an existing breakpoint.
			"""
    pass

  def is_skipping_breakpoints(self)->bool:
    """
				Returns `true` if the debugger is skipping breakpoints otherwise `false`.
			"""
    pass

  def insert_breakpoint(self, line:int, source:__core__.StringName|str)->None:
    """
				Inserts a new breakpoint with the given `source` and `line`.
			"""
    pass

  def remove_breakpoint(self, line:int, source:__core__.StringName|str)->None:
    """
				Removes a breakpoint with the given `source` and `line`.
			"""
    pass

  def clear_breakpoints(self)->None:
    """
				Clears all breakpoints.
			"""
    pass


