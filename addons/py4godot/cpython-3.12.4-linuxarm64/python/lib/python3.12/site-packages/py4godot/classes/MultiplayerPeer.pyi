from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.PacketPeer as __packetpeer__
import py4godot.classes.MultiplayerPeer as __multiplayerpeer__
import py4godot.classes.OfflineMultiplayerPeer as __offlinemultiplayerpeer__
import py4godot.classes.MultiplayerPeerExtension as __multiplayerpeerextension__
import py4godot.classes.ENetMultiplayerPeer as __enetmultiplayerpeer__
import py4godot.classes.WebRTCMultiplayerPeer as __webrtcmultiplayerpeer__
import py4godot.classes.WebSocketMultiplayerPeer as __websocketmultiplayerpeer__


class ConnectionStatus:
  CONNECTION_DISCONNECTED:int = 0
  CONNECTION_CONNECTING:int = 1
  CONNECTION_CONNECTED:int = 2
class TransferMode:
  TRANSFER_MODE_UNRELIABLE:int = 0
  TRANSFER_MODE_UNRELIABLE_ORDERED:int = 1
  TRANSFER_MODE_RELIABLE:int = 2


class MultiplayerPeer(__packetpeer__.PacketPeer):
  """
		Manages the connection with one or more remote peers acting as server or client and assigning unique IDs to each of them. See also `MultiplayerAPI`.
		**Note:** The `MultiplayerAPI` protocol is an implementation detail and isn't meant to be used by non-Godot servers. It may change without notice.
		**Note:** When exporting to Android, make sure to enable the `INTERNET` permission in the Android export preset before exporting the project or using one-click deploy. Otherwise, network communication of any kind will be blocked by Android.
	"""
  peer_connected: BuiltinSignal
  peer_disconnected: BuiltinSignal

  @staticmethod
  def constructor()->MultiplayerPeer:pass



  @staticmethod
  def cast(other:__object__.Object)->MultiplayerPeer:pass


  @property
  def refuse_new_connections(self)->bool:
    """"""
    pass
  @refuse_new_connections.setter
  def refuse_new_connections(self,  value:bool)->None:
    """"""
    pass
  @property
  def transfer_mode(self)->int:
    """"""
    pass
  @transfer_mode.setter
  def transfer_mode(self,  value:int)->None:
    """"""
    pass
  @property
  def transfer_channel(self)->int:
    """"""
    pass
  @transfer_channel.setter
  def transfer_channel(self,  value:int)->None:
    """"""
    pass
  def set_transfer_channel(self, channel:int)->None:
    """"""
    pass

  def get_transfer_channel(self)->int:
    """"""
    pass

  def set_transfer_mode(self, mode:int )->None:
    """"""
    pass

  def get_transfer_mode(self)->int:
    """"""
    pass

  def set_target_peer(self, id:int)->None:
    """
				Sets the peer to which packets will be sent.
				The `id` can be one of: `constant TARGET_PEER_BROADCAST` to send to all connected peers, `constant TARGET_PEER_SERVER` to send to the peer acting as server, a valid peer ID to send to that specific peer, a negative peer ID to send to all peers except that one. By default, the target peer is `constant TARGET_PEER_BROADCAST`.
			"""
    pass

  def get_packet_peer(self)->int:
    """
				Returns the ID of the `MultiplayerPeer` who sent the next available packet. See `PacketPeer.get_available_packet_count`.
			"""
    pass

  def get_packet_channel(self)->int:
    """
				Returns the channel over which the next available packet was received. See `PacketPeer.get_available_packet_count`.
			"""
    pass

  def get_packet_mode(self)->int:
    """
				Returns the transfer mode the remote peer used to send the next available packet. See `PacketPeer.get_available_packet_count`.
			"""
    pass

  def poll(self)->None:
    """
				Waits up to 1 second to receive a new network event.
			"""
    pass

  def close(self)->None:
    """
				Immediately close the multiplayer peer returning to the state `constant CONNECTION_DISCONNECTED`. Connected peers will be dropped without emitting `signal peer_disconnected`.
			"""
    pass

  def disconnect_peer(self, peer:int, force:bool=False)->None:
    """
				Disconnects the given `peer` from this host. If `force` is `true` the `signal peer_disconnected` signal will not be emitted for this peer.
			"""
    pass

  def get_connection_status(self)->int:
    """
				Returns the current state of the connection.
			"""
    pass

  def get_unique_id(self)->int:
    """
				Returns the ID of this `MultiplayerPeer`.
			"""
    pass

  def generate_unique_id(self)->int:
    """
				Returns a randomly generated integer that can be used as a network unique ID.
			"""
    pass

  def set_refuse_new_connections(self, enable:bool)->None:
    """"""
    pass

  def is_refusing_new_connections(self)->bool:
    """"""
    pass

  def is_server_relay_supported(self)->bool:
    """
				Returns `true` if the server can act as a relay in the current configuration. That is, if the higher level `MultiplayerAPI` should notify connected clients of other peers, and implement a relay protocol to allow communication between them.
			"""
    pass


