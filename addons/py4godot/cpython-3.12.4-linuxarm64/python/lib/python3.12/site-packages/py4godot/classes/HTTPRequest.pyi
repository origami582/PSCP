from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.Node as __node__
import py4godot.classes.TLSOptions as __tlsoptions__
import py4godot.classes.HTTPClient as __httpclient__


class Result:
  RESULT_SUCCESS:int = 0
  RESULT_CHUNKED_BODY_SIZE_MISMATCH:int = 1
  RESULT_CANT_CONNECT:int = 2
  RESULT_CANT_RESOLVE:int = 3
  RESULT_CONNECTION_ERROR:int = 4
  RESULT_TLS_HANDSHAKE_ERROR:int = 5
  RESULT_NO_RESPONSE:int = 6
  RESULT_BODY_SIZE_LIMIT_EXCEEDED:int = 7
  RESULT_BODY_DECOMPRESS_FAILED:int = 8
  RESULT_REQUEST_FAILED:int = 9
  RESULT_DOWNLOAD_FILE_CANT_OPEN:int = 10
  RESULT_DOWNLOAD_FILE_WRITE_ERROR:int = 11
  RESULT_REDIRECT_LIMIT_REACHED:int = 12
  RESULT_TIMEOUT:int = 13


class HTTPRequest(__node__.Node):
  """
		A node with the ability to send HTTP requests. Uses `HTTPClient` internally.
		Can be used to make HTTP requests, i.e. download or upload files or web content via HTTP.
		**Warning:** See the notes and warnings on `HTTPClient` for limitations, especially regarding TLS security.
		**Note:** When exporting to Android, make sure to enable the `INTERNET` permission in the Android export preset before exporting the project or using one-click deploy. Otherwise, network communication of any kind will be blocked by Android.
		**Example:** Contact a REST API and print one of its returned fields:
		
		```gdscript
		func _ready():
			# Create an HTTP request node and connect its completion signal.
			var http_request = HTTPRequest.new()
			add_child(http_request)
			http_request.request_completed.connect(self._http_request_completed)

			# Perform a GET request. The URL below returns JSON as of writing.
			var error = http_request.request("https://httpbin.org/get")
			if error != OK:
				push_error("An error occurred in the HTTP request.")

			# Perform a POST request. The URL below returns JSON as of writing.
			# Note: Don't make simultaneous requests using a single HTTPRequest node.
			# The snippet below is provided for reference only.
			var body = JSON.new().stringify({"name": "Godette"})
			error = http_request.request("https://httpbin.org/post", ``, HTTPClient.METHOD_POST, body)
			if error != OK:
				push_error("An error occurred in the HTTP request.")

		# Called when the HTTP request is completed.
		func _http_request_completed(result, response_code, headers, body):
			var json = JSON.new()
			json.parse(body.get_string_from_utf8())
			var response = json.get_data()

			# Will print the user agent string used by the HTTPRequest node (as recognized by httpbin.org).
			print(response.headers`"User-Agent"`)
		```
		
		
		**Example:** Load an image using `HTTPRequest` and display it:
		
		```gdscript
		func _ready():
			# Create an HTTP request node and connect its completion signal.
			var http_request = HTTPRequest.new()
			add_child(http_request)
			http_request.request_completed.connect(self._http_request_completed)

			# Perform the HTTP request. The URL below returns a PNG image as of writing.
			var error = http_request.request("https://placehold.co/512")
			if error != OK:
				push_error("An error occurred in the HTTP request.")

		# Called when the HTTP request is completed.
		func _http_request_completed(result, response_code, headers, body):
			if result != HTTPRequest.RESULT_SUCCESS:
				push_error("Image couldn't be downloaded. Try a different image.")

			var image = Image.new()
			var error = image.load_png_from_buffer(body)
			if error != OK:
				push_error("Couldn't load the image.")

			var texture = ImageTexture.create_from_image(image)

			# Display the image in a TextureRect node.
			var texture_rect = TextureRect.new()
			add_child(texture_rect)
			texture_rect.texture = texture
		```
		
		
		**Note:** `HTTPRequest` nodes will automatically handle decompression of response bodies. An `Accept-Encoding` header will be automatically added to each of your requests, unless one is already specified. Any response with a `Content-Encoding: gzip` header will automatically be decompressed and delivered to you as uncompressed bytes.
	"""
  request_completed: BuiltinSignal

  @staticmethod
  def constructor()->HTTPRequest:pass



  @staticmethod
  def cast(other:__object__.Object)->HTTPRequest:pass


  @property
  def download_file(self)->str:
    """"""
    pass
  @download_file.setter
  def download_file(self,  value:str)->None:
    """"""
    pass
  @property
  def download_chunk_size(self)->int:
    """"""
    pass
  @download_chunk_size.setter
  def download_chunk_size(self,  value:int)->None:
    """"""
    pass
  @property
  def use_threads(self)->bool:
    """"""
    pass
  @use_threads.setter
  def use_threads(self,  value:bool)->None:
    """"""
    pass
  @property
  def accept_gzip(self)->bool:
    """"""
    pass
  @accept_gzip.setter
  def accept_gzip(self,  value:bool)->None:
    """"""
    pass
  @property
  def body_size_limit(self)->int:
    """"""
    pass
  @body_size_limit.setter
  def body_size_limit(self,  value:int)->None:
    """"""
    pass
  @property
  def max_redirects(self)->int:
    """"""
    pass
  @max_redirects.setter
  def max_redirects(self,  value:int)->None:
    """"""
    pass
  @property
  def timeout(self)->float:
    """"""
    pass
  @timeout.setter
  def timeout(self,  value:float)->None:
    """"""
    pass
  def request(self, url:str, custom_headers:__core__.PackedStringArray= __core__.PackedStringArray.new0(), method:int =0, request_data:str= __core__.String.new0())->int:
    """
				Creates request on the underlying `HTTPClient`. If there is no configuration errors, it tries to connect using `HTTPClient.connect_to_host` and passes parameters onto `HTTPClient.request`.
				Returns `constant OK` if request is successfully created. (Does not imply that the server has responded), `constant ERR_UNCONFIGURED` if not in the tree, `constant ERR_BUSY` if still processing previous request, `constant ERR_INVALID_PARAMETER` if given string is not a valid URL format, or `constant ERR_CANT_CONNECT` if not using thread and the `HTTPClient` cannot connect to host.
				**Note:** When `method` is `constant HTTPClient.METHOD_GET`, the payload sent via `request_data` might be ignored by the server or even cause the server to reject the request (check `url=https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.1`RFC 7231 section 4.3.1`/url` for more details). As a workaround, you can send data as a query string in the URL (see `String.uri_encode` for an example).
				**Note:** It's recommended to use transport encryption (TLS) and to avoid sending sensitive information (such as login credentials) in HTTP GET URL parameters. Consider using HTTP POST requests or HTTP headers for such information instead.
			"""
    pass

  def request_raw(self, url:str, custom_headers:__core__.PackedStringArray= __core__.PackedStringArray.new0(), method:int =0, request_data_raw:__core__.PackedByteArray= __core__.PackedByteArray.new0())->int:
    """
				Creates request on the underlying `HTTPClient` using a raw array of bytes for the request body. If there is no configuration errors, it tries to connect using `HTTPClient.connect_to_host` and passes parameters onto `HTTPClient.request`.
				Returns `constant OK` if request is successfully created. (Does not imply that the server has responded), `constant ERR_UNCONFIGURED` if not in the tree, `constant ERR_BUSY` if still processing previous request, `constant ERR_INVALID_PARAMETER` if given string is not a valid URL format, or `constant ERR_CANT_CONNECT` if not using thread and the `HTTPClient` cannot connect to host.
			"""
    pass

  def cancel_request(self)->None:
    """
				Cancels the current request.
			"""
    pass

  def set_tls_options(self, client_options:__tlsoptions__.TLSOptions)->None:
    """
				Sets the `TLSOptions` to be used when connecting to an HTTPS server. See `TLSOptions.client`.
			"""
    pass

  def get_http_client_status(self)->int:
    """
				Returns the current status of the underlying `HTTPClient`.
			"""
    pass

  def set_use_threads(self, enable:bool)->None:
    """"""
    pass

  def is_using_threads(self)->bool:
    """"""
    pass

  def set_accept_gzip(self, enable:bool)->None:
    """"""
    pass

  def is_accepting_gzip(self)->bool:
    """"""
    pass

  def set_body_size_limit(self, bytes:int)->None:
    """"""
    pass

  def get_body_size_limit(self)->int:
    """"""
    pass

  def set_max_redirects(self, amount:int)->None:
    """"""
    pass

  def get_max_redirects(self)->int:
    """"""
    pass

  def set_download_file(self, path:str)->None:
    """"""
    pass

  def get_download_file(self)->str:
    """"""
    pass

  def get_downloaded_bytes(self)->int:
    """
				Returns the number of bytes this HTTPRequest downloaded.
			"""
    pass

  def get_body_size(self)->int:
    """
				Returns the response body length.
				**Note:** Some Web servers may not send a body length. In this case, the value returned will be `-1`. If using chunked transfer encoding, the body length will also be `-1`.
			"""
    pass

  def set_timeout(self, timeout:float)->None:
    """"""
    pass

  def get_timeout(self)->float:
    """"""
    pass

  def set_download_chunk_size(self, chunk_size:int)->None:
    """"""
    pass

  def get_download_chunk_size(self)->int:
    """"""
    pass

  def set_http_proxy(self, host:str, port:int)->None:
    """
				Sets the proxy server for HTTP requests.
				The proxy server is unset if `host` is empty or `port` is -1.
			"""
    pass

  def set_https_proxy(self, host:str, port:int)->None:
    """
				Sets the proxy server for HTTPS requests.
				The proxy server is unset if `host` is empty or `port` is -1.
			"""
    pass


