# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.RDUniformTypedArray as py4godot_rduniformtypedarray 
  import py4godot.classes.RIDTypedArray as py4godot_ridtypedarray 
  import py4godot.classes.PackedByteArrayTypedArray as py4godot_packedbytearraytypedarray 
  import py4godot.classes.RDAttachmentFormatTypedArray as py4godot_rdattachmentformattypedarray 
  import py4godot.classes.RDSamplerState as py4godot_rdsamplerstate 
  import py4godot.classes.RDShaderSPIRV as py4godot_rdshaderspirv 
  import py4godot.classes.RDTextureFormat as py4godot_rdtextureformat 
  import py4godot.classes.RDPipelineMultisampleState as py4godot_rdpipelinemultisamplestate 
  import py4godot.classes.RDVertexAttributeTypedArray as py4godot_rdvertexattributetypedarray 
  import py4godot.classes.RDFramebufferPassTypedArray as py4godot_rdframebufferpasstypedarray 
  import py4godot.classes.RDShaderSource as py4godot_rdshadersource 
  import py4godot.classes.RDPipelineRasterizationState as py4godot_rdpipelinerasterizationstate 
  import py4godot.classes.RDPipelineDepthStencilState as py4godot_rdpipelinedepthstencilstate 
  import py4godot.classes.RDPipelineColorBlendState as py4godot_rdpipelinecolorblendstate 
  import py4godot.classes.RDTextureView as py4godot_rdtextureview 
  import py4godot.classes.RDPipelineSpecializationConstantTypedArray as py4godot_rdpipelinespecializationconstanttypedarray 
import py4godot.classes.RDUniformTypedArray as py4godot_rduniformtypedarray 
import py4godot.classes.RIDTypedArray as py4godot_ridtypedarray 
import py4godot.classes.PackedByteArrayTypedArray as py4godot_packedbytearraytypedarray 
import py4godot.classes.RDAttachmentFormatTypedArray as py4godot_rdattachmentformattypedarray 
import py4godot.classes.RDVertexAttributeTypedArray as py4godot_rdvertexattributetypedarray 
import py4godot.classes.RDFramebufferPassTypedArray as py4godot_rdframebufferpasstypedarray 
import py4godot.classes.Object as py4godot_object 
import py4godot.classes.RDPipelineSpecializationConstantTypedArray as py4godot_rdpipelinespecializationconstanttypedarray 
from py4godot.wrappers.wrappers import CPPRenderingDeviceWrapper

class RenderingDevice(py4godot_object.Object):
  r'''
		`RenderingDevice` is an abstraction for working with modern low-level graphics APIs such as Vulkan. Compared to `RenderingServer` (which works with Godot's own rendering subsystems), `RenderingDevice` is much lower-level and allows working more directly with the underlying graphics APIs. `RenderingDevice` is used in Godot to provide support for several modern low-level graphics APIs while reducing the amount of code duplication required. `RenderingDevice` can also be used in your own projects to perform things that are not exposed by `RenderingServer` or high-level nodes, such as using compute shaders.
		On startup, Godot creates a global `RenderingDevice` which can be retrieved using `RenderingServer.get_rendering_device`. This global `RenderingDevice` performs drawing to the screen.
		**Local RenderingDevices:** Using `RenderingServer.create_local_rendering_device`, you can create "secondary" rendering devices to perform drawing and GPU compute operations on separate threads.
		**Note:** `RenderingDevice` assumes intermediate knowledge of modern graphics APIs such as Vulkan, Direct3D 12, Metal or WebGPU. These graphics APIs are lower-level than OpenGL or Direct3D 11, requiring you to perform what was previously done by the graphics driver itself. If you have difficulty understanding the concepts used in this class, follow the `url=https://vulkan-tutorial.com/`Vulkan Tutorial`/url` or `url=https://vkguide.dev/`Vulkan Guide`/url`. It's recommended to have existing modern OpenGL or Direct3D 11 knowledge before attempting to learn a low-level graphics API.
		**Note:** `RenderingDevice` is not available when running in headless mode or when using the Compatibility rendering method.
	'''
  @staticmethod
  def constructor():
    class_ = RenderingDevice.construct_without_init()
    class_._ptr = constructor(683,0, ())
    return class_
  @staticmethod
  def new():
    class_ = RenderingDevice.construct_without_init()
    class_._ptr = constructor(683,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPRenderingDeviceWrapper()
    if c_utils.shouldCreateObject:
      self._ptr = constructor(683,0, ())


  def generate_wrapper(self):
    return CPPRenderingDeviceWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = RenderingDevice.__new__(RenderingDevice)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'RenderingDevice'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = RenderingDevice.construct_without_init()
    cls._ptr = CPPRenderingDeviceWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = RenderingDevice.construct_without_init()
    cls._ptr = CPPRenderingDeviceWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def texture_create(self, format:'py4godot_rdtextureformat.RDTextureFormat'   , view:'py4godot_rdtextureview.RDTextureView'   , data:'py4godot_packedbytearraytypedarray.PackedByteArrayTypedArray' = None  ) -> typing.Union['RID']:
    r'''
				Creates a new texture. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
				**Note:** `data` takes an `Array` of `PackedByteArray`s. For `constant TEXTURE_TYPE_1D`, `constant TEXTURE_TYPE_2D`, and `constant TEXTURE_TYPE_3D` types, this array should only have one element, a `PackedByteArray` containing all the data for the texture. For `_ARRAY` and `_CUBE` types, the length should be the same as the number of `RDTextureFormat.array_layers` in `format`.
				**Note:** Not to be confused with `RenderingServer.texture_2d_create`, which creates the Godot-specific `Texture2D` resource as opposed to the graphics API's own texture type.
			'''



    assert(not format is None)
    assert isinstance(format, get_class('RDTextureFormat')), 'format must be RDTextureFormat'
    assert(not view is None)
    assert isinstance(view, get_class('RDTextureView')), 'view must be RDTextureView'
    assert isinstance(data, get_class('PackedByteArrayTypedArray')), 'data must be PackedByteArrayTypedArray'








    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(49,tuple([format._ptr, view._ptr, data._ptr]))
    return _ret


  @functools.native_method
  def texture_create_shared(self, view:'py4godot_rdtextureview.RDTextureView'   , with_texture:'RID'   ) -> typing.Union['RID']:
    r'''
				Creates a shared texture using the specified `view` and the texture information from `with_texture`.
			'''

    assert(not view is None)
    assert isinstance(view, get_class('RDTextureView')), 'view must be RDTextureView'
    assert(not with_texture is None)
    assert isinstance(with_texture, RID), 'with_texture must be RID'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(50,tuple([view._ptr, with_texture._ptr]))
    return _ret


  @functools.native_method
  def texture_create_shared_from_slice(self, view:'py4godot_rdtextureview.RDTextureView'   , with_texture:'RID'   , layer:'int'   , mipmap:'int'   , mipmaps:'int' =1  , slice_type:'int'  =0) -> typing.Union['RID']:
    r'''
				Creates a shared texture using the specified `view` and the texture information from `with_texture`'s `layer` and `mipmap`. The number of included mipmaps from the original texture can be controlled using the `mipmaps` parameter. Only relevant for textures with multiple layers, such as 3D textures, texture arrays and cubemaps. For single-layer textures, use `texture_create_shared`.
				For 2D textures (which only have one layer), `layer` must be `0`.
				**Note:** Layer slicing is only supported for 2D texture arrays, not 3D textures or cubemaps.
			'''



    assert(not view is None)
    assert isinstance(view, get_class('RDTextureView')), 'view must be RDTextureView'
    assert(not with_texture is None)
    assert isinstance(with_texture, RID), 'with_texture must be RID'
    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert isinstance(mipmap, (int, float)), 'mipmap must be int or float'
    assert isinstance(mipmaps, (int, float)), 'mipmaps must be int or float'
    assert isinstance(slice_type, (int, float)), 'slice_type must be int or float'











    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(51,tuple([view._ptr, with_texture._ptr, layer, mipmap, mipmaps, slice_type]))
    return _ret


  @functools.native_method
  def texture_create_from_extension(self, type:'int'  , format:'int'  , samples:'int'  , usage_flags:'int'   , image:'int'   , width:'int'   , height:'int'   , depth:'int'   , layers:'int'   , mipmaps:'int' =1  ) -> typing.Union['RID']:
    r'''
				Returns an RID for an existing `image` (`VkImage`) with the given `type`, `format`, `samples`, `usage_flags`, `width`, `height`, `depth`, `layers`, and `mipmaps`. This can be used to allow Godot to render onto foreign images.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'
    assert isinstance(format, (int, float)), 'format must be int or float'
    assert isinstance(samples, (int, float)), 'samples must be int or float'
    assert isinstance(usage_flags, (int, float)), 'usage_flags must be int or float'
    assert isinstance(image, (int, float)), 'image must be int or float'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'
    assert isinstance(depth, (int, float)), 'depth must be int or float'
    assert isinstance(layers, (int, float)), 'layers must be int or float'
    assert isinstance(mipmaps, (int, float)), 'mipmaps must be int or float'















    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(52,tuple([type, format, samples, usage_flags, image, width, height, depth, layers, mipmaps]))
    return _ret


  @functools.native_method
  def texture_update(self, texture:'RID'   , layer:'int'   , data:'PackedByteArray'   ) -> typing.Union[int]:
    r'''
				Updates texture data with new data, replacing the previous data in place. The updated texture data must have the same dimensions and format. For 2D textures (which only have one layer), `layer` must be `0`. Returns `constant @GlobalScope.OK` if the update was successful, `constant @GlobalScope.ERR_INVALID_PARAMETER` otherwise.
				**Note:** Updating textures is forbidden during creation of a draw or compute list.
				**Note:** The existing `texture` can't be updated while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to `constant FINAL_ACTION_CONTINUE`) to update this texture.
				**Note:** The existing `texture` requires the `constant TEXTURE_USAGE_CAN_UPDATE_BIT` to be updatable.
			'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'
    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert(not data is None)
    assert isinstance(data, PackedByteArray), 'data must be PackedByteArray'








    _ret:int
    _ret = self._ptr.call_with_return(53,tuple([texture._ptr, layer, data._ptr]))
    return _ret


  @functools.native_method
  def texture_get_data(self, texture:'RID'   , layer:'int'   ) -> typing.Union['PackedByteArray']:
    r'''
				Returns the `texture` data for the specified `layer` as raw binary data. For 2D textures (which only have one layer), `layer` must be `0`.
				**Note:** `texture` can't be retrieved while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to `constant FINAL_ACTION_CONTINUE`) to retrieve this texture. Otherwise, an error is printed and an empty `PackedByteArray` is returned.
				**Note:** `texture` requires the `constant TEXTURE_USAGE_CAN_COPY_FROM_BIT` to be retrieved. Otherwise, an error is printed and an empty `PackedByteArray` is returned.
				**Note:** This method will block the GPU from working until the data is retrieved. Refer to `texture_get_data_async` for an alternative that returns the data in more performant way.
			'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'
    assert isinstance(layer, (int, float)), 'layer must be int or float'







    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(54,tuple([texture._ptr, layer]))
    return _ret


  @functools.native_method
  def texture_get_data_async(self, texture:'RID'   , layer:'int'   , callback:'Callable'   ) -> typing.Union[int]:
    r'''
				Asynchronous version of `texture_get_data`. RenderingDevice will call `callback` in a certain amount of frames with the data the texture had at the time of the request.
				**Note:** At the moment, the delay corresponds to the amount of frames specified by `ProjectSettings.rendering/rendering_device/vsync/frame_queue_size`.
				**Note:** Downloading large textures can have a prohibitive cost for real-time even when using the asynchronous method due to hardware bandwidth limitations. When dealing with large resources, you can adjust settings such as `ProjectSettings.rendering/rendering_device/staging_buffer/texture_download_region_size_px` and `ProjectSettings.rendering/rendering_device/staging_buffer/block_size_kb` to improve the transfer speed at the cost of extra memory.
				```gdscript
				func _texture_get_data_callback(array):
					value = array.decode_u32(0)

				...

				rd.texture_get_data_async(texture, 0, _texture_get_data_callback)
				```
			'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'
    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'








    _ret:int
    _ret = self._ptr.call_with_return(55,tuple([texture._ptr, layer, callback._ptr]))
    return _ret


  @functools.native_method
  def texture_is_format_supported_for_usage(self, format:'int'  , usage_flags:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the specified `format` is supported for the given `usage_flags`, `false` otherwise.
			'''

    assert isinstance(format, (int, float)), 'format must be int or float'
    assert isinstance(usage_flags, (int, float)), 'usage_flags must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(56,tuple([format, usage_flags]))
    return _ret


  @functools.native_method
  def texture_is_shared(self, texture:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the `texture` is shared, `false` otherwise. See `RDTextureView`.
			'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'






    _ret = 0
    _ret = self._ptr.call_with_return(57,tuple([texture._ptr]))
    return _ret


  @functools.native_method
  def texture_is_valid(self, texture:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the `texture` is valid, `false` otherwise.
			'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'






    _ret = 0
    _ret = self._ptr.call_with_return(58,tuple([texture._ptr]))
    return _ret


  @functools.native_method
  def texture_set_discardable(self, texture:'RID'   , discardable:'bool'   ) -> None:
    r'''
				Updates the discardable property of `texture`.
				If a texture is discardable, its contents do not need to be preserved between frames. This flag is only relevant when the texture is used as target in a draw list.
				This information is used by `RenderingDevice` to figure out if a texture's contents can be discarded, eliminating unnecessary writes to memory and boosting performance.
			'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'
    assert isinstance(discardable, bool), 'discardable must be bool'







    self._ptr.call_with_return(59,tuple([texture._ptr, discardable]))

  @functools.native_method
  def texture_is_discardable(self, texture:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the `texture` is discardable, `false` otherwise. See `RDTextureFormat` or `texture_set_discardable`.
			'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'






    _ret = 0
    _ret = self._ptr.call_with_return(60,tuple([texture._ptr]))
    return _ret


  @functools.native_method
  def texture_copy(self, from_texture:'RID'   , to_texture:'RID'   , from_pos:'Vector3'   , to_pos:'Vector3'   , size:'Vector3'   , src_mipmap:'int'   , dst_mipmap:'int'   , src_layer:'int'   , dst_layer:'int'   ) -> typing.Union[int]:
    r'''
				Copies the `from_texture` to `to_texture` with the specified `from_pos`, `to_pos` and `size` coordinates. The Z axis of the `from_pos`, `to_pos` and `size` must be `0` for 2-dimensional textures. Source and destination mipmaps/layers must also be specified, with these parameters being `0` for textures without mipmaps or single-layer textures. Returns `constant @GlobalScope.OK` if the texture copy was successful or `constant @GlobalScope.ERR_INVALID_PARAMETER` otherwise.
				**Note:** `from_texture` texture can't be copied while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to `constant FINAL_ACTION_CONTINUE`) to copy this texture.
				**Note:** `from_texture` texture requires the `constant TEXTURE_USAGE_CAN_COPY_FROM_BIT` to be retrieved.
				**Note:** `to_texture` can't be copied while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to `constant FINAL_ACTION_CONTINUE`) to copy this texture.
				**Note:** `to_texture` requires the `constant TEXTURE_USAGE_CAN_COPY_TO_BIT` to be retrieved.
				**Note:** `from_texture` and `to_texture` must be of the same type (color or depth).
			'''

    assert(not from_texture is None)
    assert isinstance(from_texture, RID), 'from_texture must be RID'
    assert(not to_texture is None)
    assert isinstance(to_texture, RID), 'to_texture must be RID'
    assert(not from_pos is None)
    assert isinstance(from_pos, Vector3), 'from_pos must be Vector3'
    assert(not to_pos is None)
    assert isinstance(to_pos, Vector3), 'to_pos must be Vector3'
    assert(not size is None)
    assert isinstance(size, Vector3), 'size must be Vector3'
    assert isinstance(src_mipmap, (int, float)), 'src_mipmap must be int or float'
    assert isinstance(dst_mipmap, (int, float)), 'dst_mipmap must be int or float'
    assert isinstance(src_layer, (int, float)), 'src_layer must be int or float'
    assert isinstance(dst_layer, (int, float)), 'dst_layer must be int or float'














    _ret:int
    _ret = self._ptr.call_with_return(61,tuple([from_texture._ptr, to_texture._ptr, from_pos._ptr, to_pos._ptr, size._ptr, src_mipmap, dst_mipmap, src_layer, dst_layer]))
    return _ret


  @functools.native_method
  def texture_clear(self, texture:'RID'   , color:'Color'   , base_mipmap:'int'   , mipmap_count:'int'   , base_layer:'int'   , layer_count:'int'   ) -> typing.Union[int]:
    r'''
				Clears the specified `texture` by replacing all of its pixels with the specified `color`. `base_mipmap` and `mipmap_count` determine which mipmaps of the texture are affected by this clear operation, while `base_layer` and `layer_count` determine which layers of a 3D texture (or texture array) are affected by this clear operation. For 2D textures (which only have one layer by design), `base_layer` must be `0` and `layer_count` must be `1`.
				**Note:** `texture` can't be cleared while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to `constant FINAL_ACTION_CONTINUE`) to clear this texture.
			'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'
    assert isinstance(base_mipmap, (int, float)), 'base_mipmap must be int or float'
    assert isinstance(mipmap_count, (int, float)), 'mipmap_count must be int or float'
    assert isinstance(base_layer, (int, float)), 'base_layer must be int or float'
    assert isinstance(layer_count, (int, float)), 'layer_count must be int or float'











    _ret:int
    _ret = self._ptr.call_with_return(62,tuple([texture._ptr, color._ptr, base_mipmap, mipmap_count, base_layer, layer_count]))
    return _ret


  @functools.native_method
  def texture_resolve_multisample(self, from_texture:'RID'   , to_texture:'RID'   ) -> typing.Union[int]:
    r'''
				Resolves the `from_texture` texture onto `to_texture` with multisample antialiasing enabled. This must be used when rendering a framebuffer for MSAA to work. Returns `constant @GlobalScope.OK` if successful, `constant @GlobalScope.ERR_INVALID_PARAMETER` otherwise.
				**Note:** `from_texture` and `to_texture` textures must have the same dimension, format and type (color or depth).
				**Note:** `from_texture` can't be copied while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to `constant FINAL_ACTION_CONTINUE`) to resolve this texture.
				**Note:** `from_texture` requires the `constant TEXTURE_USAGE_CAN_COPY_FROM_BIT` to be retrieved.
				**Note:** `from_texture` must be multisampled and must also be 2D (or a slice of a 3D/cubemap texture).
				**Note:** `to_texture` can't be copied while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to `constant FINAL_ACTION_CONTINUE`) to resolve this texture.
				**Note:** `to_texture` texture requires the `constant TEXTURE_USAGE_CAN_COPY_TO_BIT` to be retrieved.
				**Note:** `to_texture` texture must **not** be multisampled and must also be 2D (or a slice of a 3D/cubemap texture).
			'''

    assert(not from_texture is None)
    assert isinstance(from_texture, RID), 'from_texture must be RID'
    assert(not to_texture is None)
    assert isinstance(to_texture, RID), 'to_texture must be RID'







    _ret:int
    _ret = self._ptr.call_with_return(63,tuple([from_texture._ptr, to_texture._ptr]))
    return _ret


  @functools.native_method
  def texture_get_format(self, texture:'RID'   ) -> typing.Union['py4godot_rdtextureformat.RDTextureFormat']:
    r'''
				Returns the data format used to create this texture.
			'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'






    _ret = classes.Object.Object.construct_without_init() #Smart casted to: RDTextureFormat
    _ret._ptr = self._ptr.call_with_return(64,tuple([texture._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def texture_get_native_handle(self, texture:'RID'   ) -> typing.Union[int]:
    r'''
				Returns the internal graphics handle for this texture object. For use when communicating with third-party APIs mostly with GDExtension.
				**Note:** This function returns a `uint64_t` which internally maps to a `GLuint` (OpenGL) or `VkImage` (Vulkan).
			'''

    assert(not texture is None)
    assert isinstance(texture, RID), 'texture must be RID'






    _ret = 0
    _ret = self._ptr.call_with_return(65,tuple([texture._ptr]))
    return _ret


  @functools.native_method
  def framebuffer_format_create(self, attachments:'py4godot_rdattachmentformattypedarray.RDAttachmentFormatTypedArray'   , view_count:'int' =1  ) -> typing.Union[int]:
    r'''
				Creates a new framebuffer format with the specified `attachments` and `view_count`. Returns the new framebuffer's unique framebuffer format ID.
				If `view_count` is greater than or equal to `2`, enables multiview which is used for VR rendering. This requires support for the Vulkan multiview extension.
			'''

    assert isinstance(attachments, get_class('RDAttachmentFormatTypedArray')), 'attachments must be RDAttachmentFormatTypedArray'
    assert isinstance(view_count, (int, float)), 'view_count must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(66,tuple([attachments._ptr, view_count]))
    return _ret


  @functools.native_method
  def framebuffer_format_create_multipass(self, attachments:'py4godot_rdattachmentformattypedarray.RDAttachmentFormatTypedArray'   , passes:'py4godot_rdframebufferpasstypedarray.RDFramebufferPassTypedArray'   , view_count:'int' =1  ) -> typing.Union[int]:
    r'''
				Creates a multipass framebuffer format with the specified `attachments`, `passes` and `view_count` and returns its ID. If `view_count` is greater than or equal to `2`, enables multiview which is used for VR rendering. This requires support for the Vulkan multiview extension.
			'''

    assert isinstance(attachments, get_class('RDAttachmentFormatTypedArray')), 'attachments must be RDAttachmentFormatTypedArray'
    assert isinstance(passes, get_class('RDFramebufferPassTypedArray')), 'passes must be RDFramebufferPassTypedArray'
    assert isinstance(view_count, (int, float)), 'view_count must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(67,tuple([attachments._ptr, passes._ptr, view_count]))
    return _ret


  @functools.native_method
  def framebuffer_format_create_empty(self, samples:'int'  =0) -> typing.Union[int]:
    r'''
				Creates a new empty framebuffer format with the specified number of `samples` and returns its ID.
			'''



    assert isinstance(samples, (int, float)), 'samples must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(68,tuple([samples]))
    return _ret


  @functools.native_method
  def framebuffer_format_get_texture_samples(self, format:'int'   , render_pass:'int' =0  ) -> typing.Union[int]:
    r'''
				Returns the number of texture samples used for the given framebuffer `format` ID (returned by `framebuffer_get_format`).
			'''

    assert isinstance(format, (int, float)), 'format must be int or float'
    assert isinstance(render_pass, (int, float)), 'render_pass must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(69,tuple([format, render_pass]))
    return _ret


  @functools.native_method
  def framebuffer_create(self, textures:'py4godot_ridtypedarray.RIDTypedArray'   , validate_with_format:'int' =-1  , view_count:'int' =1  ) -> typing.Union['RID']:
    r'''
				Creates a new framebuffer. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			'''

    assert isinstance(textures, get_class('RIDTypedArray')), 'textures must be RIDTypedArray'
    assert isinstance(validate_with_format, (int, float)), 'validate_with_format must be int or float'
    assert isinstance(view_count, (int, float)), 'view_count must be int or float'








    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(70,tuple([textures._ptr, validate_with_format, view_count]))
    return _ret


  @functools.native_method
  def framebuffer_create_multipass(self, textures:'py4godot_ridtypedarray.RIDTypedArray'   , passes:'py4godot_rdframebufferpasstypedarray.RDFramebufferPassTypedArray'   , validate_with_format:'int' =-1  , view_count:'int' =1  ) -> typing.Union['RID']:
    r'''
				Creates a new multipass framebuffer. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			'''

    assert isinstance(textures, get_class('RIDTypedArray')), 'textures must be RIDTypedArray'
    assert isinstance(passes, get_class('RDFramebufferPassTypedArray')), 'passes must be RDFramebufferPassTypedArray'
    assert isinstance(validate_with_format, (int, float)), 'validate_with_format must be int or float'
    assert isinstance(view_count, (int, float)), 'view_count must be int or float'









    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(71,tuple([textures._ptr, passes._ptr, validate_with_format, view_count]))
    return _ret


  @functools.native_method
  def framebuffer_create_empty(self, size:'Vector2i'   , samples:'int'  =0, validate_with_format:'int' =-1  ) -> typing.Union['RID']:
    r'''
				Creates a new empty framebuffer. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			'''



    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(samples, (int, float)), 'samples must be int or float'
    assert isinstance(validate_with_format, (int, float)), 'validate_with_format must be int or float'








    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(72,tuple([size._ptr, samples, validate_with_format]))
    return _ret


  @functools.native_method
  def framebuffer_get_format(self, framebuffer:'RID'   ) -> typing.Union[int]:
    r'''
				Returns the format ID of the framebuffer specified by the `framebuffer` RID. This ID is guaranteed to be unique for the same formats and does not need to be freed.
			'''

    assert(not framebuffer is None)
    assert isinstance(framebuffer, RID), 'framebuffer must be RID'






    _ret = 0
    _ret = self._ptr.call_with_return(73,tuple([framebuffer._ptr]))
    return _ret


  @functools.native_method
  def framebuffer_is_valid(self, framebuffer:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the framebuffer specified by the `framebuffer` RID is valid, `false` otherwise.
			'''

    assert(not framebuffer is None)
    assert isinstance(framebuffer, RID), 'framebuffer must be RID'






    _ret = 0
    _ret = self._ptr.call_with_return(74,tuple([framebuffer._ptr]))
    return _ret


  @functools.native_method
  def sampler_create(self, state:'py4godot_rdsamplerstate.RDSamplerState'   ) -> typing.Union['RID']:
    r'''
				Creates a new sampler. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			'''

    assert(not state is None)
    assert isinstance(state, get_class('RDSamplerState')), 'state must be RDSamplerState'






    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(75,tuple([state._ptr]))
    return _ret


  @functools.native_method
  def sampler_is_format_supported_for_filter(self, format:'int'  , sampler_filter:'int'  ) -> typing.Union[bool]:
    r'''
				Returns `true` if implementation supports using a texture of `format` with the given `sampler_filter`.
			'''

    assert isinstance(format, (int, float)), 'format must be int or float'
    assert isinstance(sampler_filter, (int, float)), 'sampler_filter must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(76,tuple([format, sampler_filter]))
    return _ret


  @functools.native_method
  def vertex_buffer_create(self, size_bytes:'int'   , data:'PackedByteArray' = None  , creation_bits:'int' =0  ) -> typing.Union['RID']:
    r'''
				Creates a new vertex buffer. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			'''
    if data is None:
      data = PackedByteArray.new0()

    if data is None:
      data = PackedByteArray.new0()


    assert isinstance(size_bytes, (int, float)), 'size_bytes must be int or float'
    assert isinstance(creation_bits, (int, float)), 'creation_bits must be int or float'








    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(77,tuple([size_bytes, data._ptr, creation_bits]))
    return _ret


  @functools.native_method
  def vertex_format_create(self, vertex_descriptions:'py4godot_rdvertexattributetypedarray.RDVertexAttributeTypedArray'   ) -> typing.Union[int]:
    r'''
				Creates a new vertex format with the specified `vertex_descriptions`. Returns a unique vertex format ID corresponding to the newly created vertex format.
			'''

    assert isinstance(vertex_descriptions, get_class('RDVertexAttributeTypedArray')), 'vertex_descriptions must be RDVertexAttributeTypedArray'






    _ret = 0
    _ret = self._ptr.call_with_return(78,tuple([vertex_descriptions._ptr]))
    return _ret


  @functools.native_method
  def vertex_array_create(self, vertex_count:'int'   , vertex_format:'int'   , src_buffers:'py4godot_ridtypedarray.RIDTypedArray'   , offsets:'PackedInt64Array' = None  ) -> typing.Union['RID']:
    r'''
				Creates a vertex array based on the specified buffers. Optionally, `offsets` (in bytes) may be defined for each buffer.
			'''
    if offsets is None:
      offsets = PackedInt64Array.new0()
    if offsets is None:
      offsets = PackedInt64Array.new0()

    assert isinstance(vertex_count, (int, float)), 'vertex_count must be int or float'
    assert isinstance(vertex_format, (int, float)), 'vertex_format must be int or float'
    assert isinstance(src_buffers, get_class('RIDTypedArray')), 'src_buffers must be RIDTypedArray'









    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(79,tuple([vertex_count, vertex_format, src_buffers._ptr, offsets._ptr]))
    return _ret


  @functools.native_method
  def index_buffer_create(self, size_indices:'int'   , format:'int'  , data:'PackedByteArray' = None  , use_restart_indices:'bool' =False  , creation_bits:'int' =0  ) -> typing.Union['RID']:
    r'''
				Creates a new index buffer. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			'''
    if data is None:
      data = PackedByteArray.new0()

    if data is None:
      data = PackedByteArray.new0()


    assert isinstance(size_indices, (int, float)), 'size_indices must be int or float'
    assert isinstance(format, (int, float)), 'format must be int or float'
    assert isinstance(use_restart_indices, bool), 'use_restart_indices must be bool'
    assert isinstance(creation_bits, (int, float)), 'creation_bits must be int or float'










    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(80,tuple([size_indices, format, data._ptr, use_restart_indices, creation_bits]))
    return _ret


  @functools.native_method
  def index_array_create(self, index_buffer:'RID'   , index_offset:'int'   , index_count:'int'   ) -> typing.Union['RID']:
    r'''
				Creates a new index array. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			'''

    assert(not index_buffer is None)
    assert isinstance(index_buffer, RID), 'index_buffer must be RID'
    assert isinstance(index_offset, (int, float)), 'index_offset must be int or float'
    assert isinstance(index_count, (int, float)), 'index_count must be int or float'








    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(81,tuple([index_buffer._ptr, index_offset, index_count]))
    return _ret


  @functools.native_method
  def shader_compile_spirv_from_source(self, shader_source:'py4godot_rdshadersource.RDShaderSource'   , allow_cache:'bool' =True  ) -> typing.Union['py4godot_rdshaderspirv.RDShaderSPIRV']:
    r'''
				Compiles a SPIR-V from the shader source code in `shader_source` and returns the SPIR-V as an `RDShaderSPIRV`. This intermediate language shader is portable across different GPU models and driver versions, but cannot be run directly by GPUs until compiled into a binary shader using `shader_compile_binary_from_spirv`.
				If `allow_cache` is `true`, make use of the shader cache generated by Godot. This avoids a potentially lengthy shader compilation step if the shader is already in cache. If `allow_cache` is `false`, Godot's shader cache is ignored and the shader will always be recompiled.
			'''

    assert(not shader_source is None)
    assert isinstance(shader_source, get_class('RDShaderSource')), 'shader_source must be RDShaderSource'
    assert isinstance(allow_cache, bool), 'allow_cache must be bool'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: RDShaderSPIRV
    _ret._ptr = self._ptr.call_with_return(82,tuple([shader_source._ptr, allow_cache]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def shader_compile_binary_from_spirv(self, spirv_data:'py4godot_rdshaderspirv.RDShaderSPIRV'   , name:'str' =""  ) -> typing.Union['PackedByteArray']:
    r'''
				Compiles a binary shader from `spirv_data` and returns the compiled binary data as a `PackedByteArray`. This compiled shader is specific to the GPU model and driver version used; it will not work on different GPU models or even different driver versions. See also `shader_compile_spirv_from_source`.
				`name` is an optional human-readable name that can be given to the compiled shader for organizational purposes.
			'''
    if name is None:
      name = String.new0()
    if name is None:
      name = String.new0()

    assert(not spirv_data is None)
    assert isinstance(spirv_data, get_class('RDShaderSPIRV')), 'spirv_data must be RDShaderSPIRV'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(83,tuple([spirv_data._ptr, py_string_name._ptr]))
    return _ret


  @functools.native_method
  def shader_create_from_spirv(self, spirv_data:'py4godot_rdshaderspirv.RDShaderSPIRV'   , name:'str' =""  ) -> typing.Union['RID']:
    r'''
				Creates a new shader instance from SPIR-V intermediate code. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method. See also `shader_compile_spirv_from_source` and `shader_create_from_bytecode`.
			'''
    if name is None:
      name = String.new0()
    if name is None:
      name = String.new0()

    assert(not spirv_data is None)
    assert isinstance(spirv_data, get_class('RDShaderSPIRV')), 'spirv_data must be RDShaderSPIRV'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(84,tuple([spirv_data._ptr, py_string_name._ptr]))
    return _ret


  @functools.native_method
  def shader_create_from_bytecode(self, binary_data:'PackedByteArray'   , placeholder_rid:'RID' = None  ) -> typing.Union['RID']:
    r'''
				Creates a new shader instance from a binary compiled shader. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method. See also `shader_compile_binary_from_spirv` and `shader_create_from_spirv`.
			'''
    if placeholder_rid is None:
      placeholder_rid = RID.new0()
    if placeholder_rid is None:
      placeholder_rid = RID.new0()

    assert(not binary_data is None)
    assert isinstance(binary_data, PackedByteArray), 'binary_data must be PackedByteArray'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(85,tuple([binary_data._ptr, placeholder_rid._ptr]))
    return _ret


  @functools.native_method
  def shader_create_placeholder(self) -> typing.Union['RID']:
    r'''
				Create a placeholder RID by allocating an RID without initializing it for use in `shader_create_from_bytecode`. This allows you to create an RID for a shader and pass it around, but defer compiling the shader to a later time.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(86,tuple([]))
    return _ret


  @functools.native_method
  def shader_get_vertex_input_attribute_mask(self, shader:'RID'   ) -> typing.Union[int]:
    r'''
				Returns the internal vertex input mask. Internally, the vertex input mask is an unsigned integer consisting of the locations (specified in GLSL via. `layout(location = ...)`) of the input variables (specified in GLSL by the `in` keyword).
			'''

    assert(not shader is None)
    assert isinstance(shader, RID), 'shader must be RID'






    _ret = 0
    _ret = self._ptr.call_with_return(87,tuple([shader._ptr]))
    return _ret


  @functools.native_method
  def uniform_buffer_create(self, size_bytes:'int'   , data:'PackedByteArray' = None  , creation_bits:'int' =0  ) -> typing.Union['RID']:
    r'''
				Creates a new uniform buffer. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			'''
    if data is None:
      data = PackedByteArray.new0()

    if data is None:
      data = PackedByteArray.new0()


    assert isinstance(size_bytes, (int, float)), 'size_bytes must be int or float'
    assert isinstance(creation_bits, (int, float)), 'creation_bits must be int or float'








    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(88,tuple([size_bytes, data._ptr, creation_bits]))
    return _ret


  @functools.native_method
  def storage_buffer_create(self, size_bytes:'int'   , data:'PackedByteArray' = None  , usage:'int' =0  , creation_bits:'int' =0  ) -> typing.Union['RID']:
    r'''
				Creates a `url=https://vkguide.dev/docs/chapter-4/storage_buffers/`storage buffer`/url` with the specified `data` and `usage`. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			'''
    if data is None:
      data = PackedByteArray.new0()


    if data is None:
      data = PackedByteArray.new0()



    assert isinstance(size_bytes, (int, float)), 'size_bytes must be int or float'
    assert isinstance(usage, (int, float)), 'usage must be int or float'
    assert isinstance(creation_bits, (int, float)), 'creation_bits must be int or float'









    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(89,tuple([size_bytes, data._ptr, usage, creation_bits]))
    return _ret


  @functools.native_method
  def texture_buffer_create(self, size_bytes:'int'   , format:'int'  , data:'PackedByteArray' = None  ) -> typing.Union['RID']:
    r'''
				Creates a new texture buffer. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			'''
    if data is None:
      data = PackedByteArray.new0()
    if data is None:
      data = PackedByteArray.new0()

    assert isinstance(size_bytes, (int, float)), 'size_bytes must be int or float'
    assert isinstance(format, (int, float)), 'format must be int or float'








    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(90,tuple([size_bytes, format, data._ptr]))
    return _ret


  @functools.native_method
  def uniform_set_create(self, uniforms:'py4godot_rduniformtypedarray.RDUniformTypedArray'   , shader:'RID'   , shader_set:'int'   ) -> typing.Union['RID']:
    r'''
				Creates a new uniform set. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			'''

    assert isinstance(uniforms, get_class('RDUniformTypedArray')), 'uniforms must be RDUniformTypedArray'
    assert(not shader is None)
    assert isinstance(shader, RID), 'shader must be RID'
    assert isinstance(shader_set, (int, float)), 'shader_set must be int or float'








    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(91,tuple([uniforms._ptr, shader._ptr, shader_set]))
    return _ret


  @functools.native_method
  def uniform_set_is_valid(self, uniform_set:'RID'   ) -> typing.Union[bool]:
    r'''
				Checks if the `uniform_set` is valid, i.e. is owned.
			'''

    assert(not uniform_set is None)
    assert isinstance(uniform_set, RID), 'uniform_set must be RID'






    _ret = 0
    _ret = self._ptr.call_with_return(92,tuple([uniform_set._ptr]))
    return _ret


  @functools.native_method
  def buffer_copy(self, src_buffer:'RID'   , dst_buffer:'RID'   , src_offset:'int'   , dst_offset:'int'   , size:'int'   ) -> typing.Union[int]:
    r'''
				Copies `size` bytes from the `src_buffer` at `src_offset` into `dst_buffer` at `dst_offset`.
				Prints an error if:
				- `size` exceeds the size of either `src_buffer` or `dst_buffer` at their corresponding offsets
				- a draw list is currently active (created by `draw_list_begin`)
				- a compute list is currently active (created by `compute_list_begin`)
			'''

    assert(not src_buffer is None)
    assert isinstance(src_buffer, RID), 'src_buffer must be RID'
    assert(not dst_buffer is None)
    assert isinstance(dst_buffer, RID), 'dst_buffer must be RID'
    assert isinstance(src_offset, (int, float)), 'src_offset must be int or float'
    assert isinstance(dst_offset, (int, float)), 'dst_offset must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'










    _ret:int
    _ret = self._ptr.call_with_return(93,tuple([src_buffer._ptr, dst_buffer._ptr, src_offset, dst_offset, size]))
    return _ret


  @functools.native_method
  def buffer_update(self, buffer:'RID'   , offset:'int'   , size_bytes:'int'   , data:'PackedByteArray'   ) -> typing.Union[int]:
    r'''
				Updates a region of `size_bytes` bytes, starting at `offset`, in the buffer, with the specified `data`.
				Prints an error if:
				- the region specified by `offset` + `size_bytes` exceeds the buffer
				- a draw list is currently active (created by `draw_list_begin`)
				- a compute list is currently active (created by `compute_list_begin`)
			'''

    assert(not buffer is None)
    assert isinstance(buffer, RID), 'buffer must be RID'
    assert isinstance(offset, (int, float)), 'offset must be int or float'
    assert isinstance(size_bytes, (int, float)), 'size_bytes must be int or float'
    assert(not data is None)
    assert isinstance(data, PackedByteArray), 'data must be PackedByteArray'









    _ret:int
    _ret = self._ptr.call_with_return(94,tuple([buffer._ptr, offset, size_bytes, data._ptr]))
    return _ret


  @functools.native_method
  def buffer_clear(self, buffer:'RID'   , offset:'int'   , size_bytes:'int'   ) -> typing.Union[int]:
    r'''
				Clears the contents of the `buffer`, clearing `size_bytes` bytes, starting at `offset`.
				Prints an error if:
				- the size isn't a multiple of four
				- the region specified by `offset` + `size_bytes` exceeds the buffer
				- a draw list is currently active (created by `draw_list_begin`)
				- a compute list is currently active (created by `compute_list_begin`)
			'''

    assert(not buffer is None)
    assert isinstance(buffer, RID), 'buffer must be RID'
    assert isinstance(offset, (int, float)), 'offset must be int or float'
    assert isinstance(size_bytes, (int, float)), 'size_bytes must be int or float'








    _ret:int
    _ret = self._ptr.call_with_return(95,tuple([buffer._ptr, offset, size_bytes]))
    return _ret


  @functools.native_method
  def buffer_get_data(self, buffer:'RID'   , offset_bytes:'int' =0  , size_bytes:'int' =0  ) -> typing.Union['PackedByteArray']:
    r'''
				Returns a copy of the data of the specified `buffer`, optionally `offset_bytes` and `size_bytes` can be set to copy only a portion of the buffer.
				**Note:** This method will block the GPU from working until the data is retrieved. Refer to `buffer_get_data_async` for an alternative that returns the data in more performant way.
			'''

    assert(not buffer is None)
    assert isinstance(buffer, RID), 'buffer must be RID'
    assert isinstance(offset_bytes, (int, float)), 'offset_bytes must be int or float'
    assert isinstance(size_bytes, (int, float)), 'size_bytes must be int or float'








    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(96,tuple([buffer._ptr, offset_bytes, size_bytes]))
    return _ret


  @functools.native_method
  def buffer_get_data_async(self, buffer:'RID'   , callback:'Callable'   , offset_bytes:'int' =0  , size_bytes:'int' =0  ) -> typing.Union[int]:
    r'''
				Asynchronous version of `buffer_get_data`. RenderingDevice will call `callback` in a certain amount of frames with the data the buffer had at the time of the request.
				**Note:** At the moment, the delay corresponds to the amount of frames specified by `ProjectSettings.rendering/rendering_device/vsync/frame_queue_size`.
				**Note:** Downloading large buffers can have a prohibitive cost for real-time even when using the asynchronous method due to hardware bandwidth limitations. When dealing with large resources, you can adjust settings such as `ProjectSettings.rendering/rendering_device/staging_buffer/block_size_kb` to improve the transfer speed at the cost of extra memory.
				```gdscript
				func _buffer_get_data_callback(array):
					value = array.decode_u32(0)

				...

				rd.buffer_get_data_async(buffer, _buffer_get_data_callback)
				```
			'''

    assert(not buffer is None)
    assert isinstance(buffer, RID), 'buffer must be RID'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'
    assert isinstance(offset_bytes, (int, float)), 'offset_bytes must be int or float'
    assert isinstance(size_bytes, (int, float)), 'size_bytes must be int or float'









    _ret:int
    _ret = self._ptr.call_with_return(97,tuple([buffer._ptr, callback._ptr, offset_bytes, size_bytes]))
    return _ret


  @functools.native_method
  def buffer_get_device_address(self, buffer:'RID'   ) -> typing.Union[int]:
    r'''
				Returns the address of the given `buffer` which can be passed to shaders in any way to access underlying data. Buffer must have been created with this feature enabled.
				**Note:** You must check that the GPU supports this functionality by calling `has_feature` with `constant SUPPORTS_BUFFER_DEVICE_ADDRESS` as a parameter.
			'''

    assert(not buffer is None)
    assert isinstance(buffer, RID), 'buffer must be RID'






    _ret = 0
    _ret = self._ptr.call_with_return(98,tuple([buffer._ptr]))
    return _ret


  @functools.native_method
  def render_pipeline_create(self, shader:'RID'   , framebuffer_format:'int'   , vertex_format:'int'   , primitive:'int'  , rasterization_state:'py4godot_rdpipelinerasterizationstate.RDPipelineRasterizationState'   , multisample_state:'py4godot_rdpipelinemultisamplestate.RDPipelineMultisampleState'   , stencil_state:'py4godot_rdpipelinedepthstencilstate.RDPipelineDepthStencilState'   , color_blend_state:'py4godot_rdpipelinecolorblendstate.RDPipelineColorBlendState'   , dynamic_state_flags:'int' =0  , for_render_pass:'int' =0  , specialization_constants:'py4godot_rdpipelinespecializationconstanttypedarray.RDPipelineSpecializationConstantTypedArray' = None  ) -> typing.Union['RID']:
    r'''
				Creates a new render pipeline. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			'''





    assert(not shader is None)
    assert isinstance(shader, RID), 'shader must be RID'
    assert isinstance(framebuffer_format, (int, float)), 'framebuffer_format must be int or float'
    assert isinstance(vertex_format, (int, float)), 'vertex_format must be int or float'
    assert isinstance(primitive, (int, float)), 'primitive must be int or float'
    assert(not rasterization_state is None)
    assert isinstance(rasterization_state, get_class('RDPipelineRasterizationState')), 'rasterization_state must be RDPipelineRasterizationState'
    assert(not multisample_state is None)
    assert isinstance(multisample_state, get_class('RDPipelineMultisampleState')), 'multisample_state must be RDPipelineMultisampleState'
    assert(not stencil_state is None)
    assert isinstance(stencil_state, get_class('RDPipelineDepthStencilState')), 'stencil_state must be RDPipelineDepthStencilState'
    assert(not color_blend_state is None)
    assert isinstance(color_blend_state, get_class('RDPipelineColorBlendState')), 'color_blend_state must be RDPipelineColorBlendState'
    assert isinstance(dynamic_state_flags, (int, float)), 'dynamic_state_flags must be int or float'
    assert isinstance(for_render_pass, (int, float)), 'for_render_pass must be int or float'
    assert isinstance(specialization_constants, get_class('RDPipelineSpecializationConstantTypedArray')), 'specialization_constants must be RDPipelineSpecializationConstantTypedArray'
















    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(99,tuple([shader._ptr, framebuffer_format, vertex_format, primitive, rasterization_state._ptr, multisample_state._ptr, stencil_state._ptr, color_blend_state._ptr, dynamic_state_flags, for_render_pass, specialization_constants._ptr]))
    return _ret


  @functools.native_method
  def render_pipeline_is_valid(self, render_pipeline:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the render pipeline specified by the `render_pipeline` RID is valid, `false` otherwise.
			'''

    assert(not render_pipeline is None)
    assert isinstance(render_pipeline, RID), 'render_pipeline must be RID'






    _ret = 0
    _ret = self._ptr.call_with_return(100,tuple([render_pipeline._ptr]))
    return _ret


  @functools.native_method
  def compute_pipeline_create(self, shader:'RID'   , specialization_constants:'py4godot_rdpipelinespecializationconstanttypedarray.RDPipelineSpecializationConstantTypedArray' = None  ) -> typing.Union['RID']:
    r'''
				Creates a new compute pipeline. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			'''



    assert(not shader is None)
    assert isinstance(shader, RID), 'shader must be RID'
    assert isinstance(specialization_constants, get_class('RDPipelineSpecializationConstantTypedArray')), 'specialization_constants must be RDPipelineSpecializationConstantTypedArray'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(101,tuple([shader._ptr, specialization_constants._ptr]))
    return _ret


  @functools.native_method
  def compute_pipeline_is_valid(self, compute_pipeline:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the compute pipeline specified by the `compute_pipeline` RID is valid, `false` otherwise.
			'''

    assert(not compute_pipeline is None)
    assert isinstance(compute_pipeline, RID), 'compute_pipeline must be RID'






    _ret = 0
    _ret = self._ptr.call_with_return(102,tuple([compute_pipeline._ptr]))
    return _ret


  @functools.native_method
  def screen_get_width(self, screen:'int' =0  ) -> typing.Union[int]:
    r'''
				Returns the window width matching the graphics API context for the given window ID (in pixels). Despite the parameter being named `screen`, this returns the _window_ size. See also `screen_get_height`.
				**Note:** Only the main `RenderingDevice` returned by `RenderingServer.get_rendering_device` has a width. If called on a local `RenderingDevice`, this method prints an error and returns `constant INVALID_ID`.
			'''

    assert isinstance(screen, (int, float)), 'screen must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(103,tuple([screen]))
    return _ret


  @functools.native_method
  def screen_get_height(self, screen:'int' =0  ) -> typing.Union[int]:
    r'''
				Returns the window height matching the graphics API context for the given window ID (in pixels). Despite the parameter being named `screen`, this returns the _window_ size. See also `screen_get_width`.
				**Note:** Only the main `RenderingDevice` returned by `RenderingServer.get_rendering_device` has a height. If called on a local `RenderingDevice`, this method prints an error and returns `constant INVALID_ID`.
			'''

    assert isinstance(screen, (int, float)), 'screen must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(104,tuple([screen]))
    return _ret


  @functools.native_method
  def screen_get_framebuffer_format(self, screen:'int' =0  ) -> typing.Union[int]:
    r'''
				Returns the framebuffer format of the given screen.
				**Note:** Only the main `RenderingDevice` returned by `RenderingServer.get_rendering_device` has a format. If called on a local `RenderingDevice`, this method prints an error and returns `constant INVALID_ID`.
			'''

    assert isinstance(screen, (int, float)), 'screen must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(105,tuple([screen]))
    return _ret


  @functools.native_method
  def draw_list_begin_for_screen(self, screen:'int' =0  , clear_color:'Color' = None  ) -> typing.Union[int]:
    r'''
				High-level variant of `draw_list_begin`, with the parameters automatically being adjusted for drawing onto the window specified by the `screen` ID.
				**Note:** Cannot be used with local RenderingDevices, as these don't have a screen. If called on a local RenderingDevice, `draw_list_begin_for_screen` returns `constant INVALID_ID`.
			'''
    if clear_color is None:
      clear_color = Color.new0()
    if clear_color is None:
      clear_color = Color.new0()

    assert isinstance(screen, (int, float)), 'screen must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(106,tuple([screen, clear_color._ptr]))
    return _ret


  @functools.native_method
  def draw_list_begin(self, framebuffer:'RID'   , draw_flags:'int' =0  , clear_color_values:'PackedColorArray' = None  , clear_depth_value:'float' =1.0  , clear_stencil_value:'int' =0  , region:'Rect2' = None  , breadcrumb:'int' =0  ) -> typing.Union[int]:
    r'''
				Starts a list of raster drawing commands created with the `draw_*` methods. The returned value should be passed to other `draw_list_*` functions.
				Multiple draw lists cannot be created at the same time; you must finish the previous draw list first using `draw_list_end`.
				A simple drawing operation might look like this (code is not a complete example):
				```gdscript
				var rd = RenderingDevice.new()
				var clear_colors = PackedColorArray(`Color(0, 0, 0, 0), Color(0, 0, 0, 0), Color(0, 0, 0, 0)`)
				var draw_list = rd.draw_list_begin(framebuffers_, RenderingDevice.CLEAR_COLOR_ALL, clear_colors, true, 1.0f, true, 0, Rect2(), RenderingDevice.OPAQUE_PASS)

				# Draw opaque.
				rd.draw_list_bind_render_pipeline(draw_list, raster_pipeline)
				rd.draw_list_bind_uniform_set(draw_list, raster_base_uniform, 0)
				rd.draw_list_set_push_constant(draw_list, raster_push_constant, raster_push_constant.size())
				rd.draw_list_draw(draw_list, false, 1, slice_triangle_count_ * 3)
				# Draw wire.
				rd.draw_list_bind_render_pipeline(draw_list, raster_pipeline_wire)
				rd.draw_list_bind_uniform_set(draw_list, raster_base_uniform, 0)
				rd.draw_list_set_push_constant(draw_list, raster_push_constant, raster_push_constant.size())
				rd.draw_list_draw(draw_list, false, 1, slice_triangle_count_ * 3)

				rd.draw_list_end()
				```
				The `draw_flags` indicates if the texture attachments of the framebuffer should be cleared or ignored. Only one of the two flags can be used for each individual attachment. Ignoring an attachment means that any contents that existed before the draw list will be completely discarded, reducing the memory bandwidth used by the render pass but producing garbage results if the pixels aren't replaced. The default behavior allows the engine to figure out the right operation to use if the texture is discardable, which can result in increased performance. See `RDTextureFormat` or `texture_set_discardable`.
				The `breadcrumb` parameter can be an arbitrary 32-bit integer that is useful to diagnose GPU crashes. If Godot is built in dev or debug mode; when the GPU crashes Godot will dump all shaders that were being executed at the time of the crash and the breadcrumb is useful to diagnose what passes did those shaders belong to.
				It does not affect rendering behavior and can be set to 0. It is recommended to use `enum BreadcrumbMarker` enumerations for consistency but it's not required. It is also possible to use bitwise operations to add extra data. e.g.
				```gdscript
				rd.draw_list_begin(fb_, RenderingDevice.CLEAR_COLOR_ALL, clear_colors, true, 1.0f, true, 0, Rect2(), RenderingDevice.OPAQUE_PASS | 5)
				```
			'''

    if clear_color_values is None:
      clear_color_values = PackedColorArray.new0()
    if region is None:
      region = Rect2.new0()

    if clear_color_values is None:
      clear_color_values = PackedColorArray.new0()
    if region is None:
      region = Rect2.new0()

    assert(not framebuffer is None)
    assert isinstance(framebuffer, RID), 'framebuffer must be RID'
    assert isinstance(draw_flags, (int, float)), 'draw_flags must be int or float'
    assert isinstance(clear_depth_value, (int, float)), 'clear_depth_value must be int or float'
    assert isinstance(clear_stencil_value, (int, float)), 'clear_stencil_value must be int or float'
    assert isinstance(breadcrumb, (int, float)), 'breadcrumb must be int or float'












    _ret = 0
    _ret = self._ptr.call_with_return(107,tuple([framebuffer._ptr, draw_flags, clear_color_values._ptr, clear_depth_value, clear_stencil_value, region._ptr, breadcrumb]))
    return _ret


  @functools.native_method
  def draw_list_begin_split(self, framebuffer:'RID'   , splits:'int'   , initial_color_action:'int'  , final_color_action:'int'  , initial_depth_action:'int'  , final_depth_action:'int'  , clear_color_values:'PackedColorArray' = None  , clear_depth:'float' =1.0  , clear_stencil:'int' =0  , region:'Rect2' = None  , storage_textures:'py4godot_ridtypedarray.RIDTypedArray' = None  ) -> typing.Union['PackedInt64Array']:
    r'''
				This method does nothing and always returns an empty `PackedInt64Array`.
			'''
    if clear_color_values is None:
      clear_color_values = PackedColorArray.new0()
    if region is None:
      region = Rect2.new0()

    if clear_color_values is None:
      clear_color_values = PackedColorArray.new0()
    if region is None:
      region = Rect2.new0()


    assert(not framebuffer is None)
    assert isinstance(framebuffer, RID), 'framebuffer must be RID'
    assert isinstance(splits, (int, float)), 'splits must be int or float'
    assert isinstance(initial_color_action, (int, float)), 'initial_color_action must be int or float'
    assert isinstance(final_color_action, (int, float)), 'final_color_action must be int or float'
    assert isinstance(initial_depth_action, (int, float)), 'initial_depth_action must be int or float'
    assert isinstance(final_depth_action, (int, float)), 'final_depth_action must be int or float'
    assert isinstance(clear_depth, (int, float)), 'clear_depth must be int or float'
    assert isinstance(clear_stencil, (int, float)), 'clear_stencil must be int or float'
    assert isinstance(storage_textures, get_class('RIDTypedArray')), 'storage_textures must be RIDTypedArray'
















    _ret = PackedInt64Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(108,tuple([framebuffer._ptr, splits, initial_color_action, final_color_action, initial_depth_action, final_depth_action, clear_color_values._ptr, clear_depth, clear_stencil, region._ptr, storage_textures._ptr]))
    return _ret


  @functools.native_method
  def draw_list_set_blend_constants(self, draw_list:'int'   , color:'Color'   ) -> None:
    r'''
				Sets blend constants for the specified `draw_list` to `color`. Blend constants are used only if the graphics pipeline is created with `constant DYNAMIC_STATE_BLEND_CONSTANTS` flag set.
			'''

    assert isinstance(draw_list, (int, float)), 'draw_list must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(109,tuple([draw_list, color._ptr]))

  @functools.native_method
  def draw_list_bind_render_pipeline(self, draw_list:'int'   , render_pipeline:'RID'   ) -> None:
    r'''
				Binds `render_pipeline` to the specified `draw_list`.
			'''

    assert isinstance(draw_list, (int, float)), 'draw_list must be int or float'
    assert(not render_pipeline is None)
    assert isinstance(render_pipeline, RID), 'render_pipeline must be RID'







    self._ptr.call_with_return(110,tuple([draw_list, render_pipeline._ptr]))

  @functools.native_method
  def draw_list_bind_uniform_set(self, draw_list:'int'   , uniform_set:'RID'   , set_index:'int'   ) -> None:
    r'''
				Binds `uniform_set` to the specified `draw_list`. A `set_index` must also be specified, which is an identifier starting from `0` that must match the one expected by the draw list.
			'''

    assert isinstance(draw_list, (int, float)), 'draw_list must be int or float'
    assert(not uniform_set is None)
    assert isinstance(uniform_set, RID), 'uniform_set must be RID'
    assert isinstance(set_index, (int, float)), 'set_index must be int or float'








    self._ptr.call_with_return(111,tuple([draw_list, uniform_set._ptr, set_index]))

  @functools.native_method
  def draw_list_bind_vertex_array(self, draw_list:'int'   , vertex_array:'RID'   ) -> None:
    r'''
				Binds `vertex_array` to the specified `draw_list`.
			'''

    assert isinstance(draw_list, (int, float)), 'draw_list must be int or float'
    assert(not vertex_array is None)
    assert isinstance(vertex_array, RID), 'vertex_array must be RID'







    self._ptr.call_with_return(112,tuple([draw_list, vertex_array._ptr]))

  @functools.native_method
  def draw_list_bind_index_array(self, draw_list:'int'   , index_array:'RID'   ) -> None:
    r'''
				Binds `index_array` to the specified `draw_list`.
			'''

    assert isinstance(draw_list, (int, float)), 'draw_list must be int or float'
    assert(not index_array is None)
    assert isinstance(index_array, RID), 'index_array must be RID'







    self._ptr.call_with_return(113,tuple([draw_list, index_array._ptr]))

  @functools.native_method
  def draw_list_set_push_constant(self, draw_list:'int'   , buffer:'PackedByteArray'   , size_bytes:'int'   ) -> None:
    r'''
				Sets the push constant data to `buffer` for the specified `draw_list`. The shader determines how this binary data is used. The buffer's size in bytes must also be specified in `size_bytes` (this can be obtained by calling the `PackedByteArray.size` method on the passed `buffer`).
			'''

    assert isinstance(draw_list, (int, float)), 'draw_list must be int or float'
    assert(not buffer is None)
    assert isinstance(buffer, PackedByteArray), 'buffer must be PackedByteArray'
    assert isinstance(size_bytes, (int, float)), 'size_bytes must be int or float'








    self._ptr.call_with_return(114,tuple([draw_list, buffer._ptr, size_bytes]))

  @functools.native_method
  def draw_list_draw(self, draw_list:'int'   , use_indices:'bool'   , instances:'int'   , procedural_vertex_count:'int' =0  ) -> None:
    r'''
				Submits `draw_list` for rendering on the GPU. This is the raster equivalent to `compute_list_dispatch`.
			'''

    assert isinstance(draw_list, (int, float)), 'draw_list must be int or float'
    assert isinstance(use_indices, bool), 'use_indices must be bool'
    assert isinstance(instances, (int, float)), 'instances must be int or float'
    assert isinstance(procedural_vertex_count, (int, float)), 'procedural_vertex_count must be int or float'









    self._ptr.call_with_return(115,tuple([draw_list, use_indices, instances, procedural_vertex_count]))

  @functools.native_method
  def draw_list_draw_indirect(self, draw_list:'int'   , use_indices:'bool'   , buffer:'RID'   , offset:'int' =0  , draw_count:'int' =1  , stride:'int' =0  ) -> None:
    r'''
				Submits `draw_list` for rendering on the GPU with the given parameters stored in the `buffer` at `offset`. Parameters being integers: vertex count, instance count, first vertex, first instance. And when using indices: index count, instance count, first index, vertex offset, first instance. Buffer must have been created with `constant STORAGE_BUFFER_USAGE_DISPATCH_INDIRECT` flag.
			'''

    assert isinstance(draw_list, (int, float)), 'draw_list must be int or float'
    assert isinstance(use_indices, bool), 'use_indices must be bool'
    assert(not buffer is None)
    assert isinstance(buffer, RID), 'buffer must be RID'
    assert isinstance(offset, (int, float)), 'offset must be int or float'
    assert isinstance(draw_count, (int, float)), 'draw_count must be int or float'
    assert isinstance(stride, (int, float)), 'stride must be int or float'











    self._ptr.call_with_return(116,tuple([draw_list, use_indices, buffer._ptr, offset, draw_count, stride]))

  @functools.native_method
  def draw_list_enable_scissor(self, draw_list:'int'   , rect:'Rect2' = None  ) -> None:
    r'''
				Creates a scissor rectangle and enables it for the specified `draw_list`. Scissor rectangles are used for clipping by discarding fragments that fall outside a specified rectangular portion of the screen. See also `draw_list_disable_scissor`.
				**Note:** The specified `rect` is automatically intersected with the screen's dimensions, which means it cannot exceed the screen's dimensions.
			'''
    if rect is None:
      rect = Rect2.new0()
    if rect is None:
      rect = Rect2.new0()

    assert isinstance(draw_list, (int, float)), 'draw_list must be int or float'







    self._ptr.call_with_return(117,tuple([draw_list, rect._ptr]))

  @functools.native_method
  def draw_list_disable_scissor(self, draw_list:'int'   ) -> None:
    r'''
				Removes and disables the scissor rectangle for the specified `draw_list`. See also `draw_list_enable_scissor`.
			'''

    assert isinstance(draw_list, (int, float)), 'draw_list must be int or float'






    self._ptr.call_with_return(118,tuple([draw_list]))

  @functools.native_method
  def draw_list_switch_to_next_pass(self) -> typing.Union[int]:
    r'''
				Switches to the next draw pass.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(119,tuple([]))
    return _ret


  @functools.native_method
  def draw_list_switch_to_next_pass_split(self, splits:'int'   ) -> typing.Union['PackedInt64Array']:
    r'''
				This method does nothing and always returns an empty `PackedInt64Array`.
			'''

    assert isinstance(splits, (int, float)), 'splits must be int or float'






    _ret = PackedInt64Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(120,tuple([splits]))
    return _ret


  @functools.native_method
  def draw_list_end(self) -> None:
    r'''
				Finishes a list of raster drawing commands created with the `draw_*` methods.
			'''




    self._ptr.call_with_return(121,tuple([]))

  @functools.native_method
  def compute_list_begin(self) -> typing.Union[int]:
    r'''
				Starts a list of compute commands created with the `compute_*` methods. The returned value should be passed to other `compute_list_*` functions.
				Multiple compute lists cannot be created at the same time; you must finish the previous compute list first using `compute_list_end`.
				A simple compute operation might look like this (code is not a complete example):
				```gdscript
				var rd = RenderingDevice.new()
				var compute_list = rd.compute_list_begin()

				rd.compute_list_bind_compute_pipeline(compute_list, compute_shader_dilate_pipeline)
				rd.compute_list_bind_uniform_set(compute_list, compute_base_uniform_set, 0)
				rd.compute_list_bind_uniform_set(compute_list, dilate_uniform_set, 1)

				for i in atlas_slices:
					rd.compute_list_set_push_constant(compute_list, push_constant, push_constant.size())
					rd.compute_list_dispatch(compute_list, group_size.x, group_size.y, group_size.z)
					# No barrier, let them run all together.

				rd.compute_list_end()
				```
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(122,tuple([]))
    return _ret


  @functools.native_method
  def compute_list_bind_compute_pipeline(self, compute_list:'int'   , compute_pipeline:'RID'   ) -> None:
    r'''
				Tells the GPU what compute pipeline to use when processing the compute list. If the shader has changed since the last time this function was called, Godot will unbind all descriptor sets and will re-bind them inside `compute_list_dispatch`.
			'''

    assert isinstance(compute_list, (int, float)), 'compute_list must be int or float'
    assert(not compute_pipeline is None)
    assert isinstance(compute_pipeline, RID), 'compute_pipeline must be RID'







    self._ptr.call_with_return(123,tuple([compute_list, compute_pipeline._ptr]))

  @functools.native_method
  def compute_list_set_push_constant(self, compute_list:'int'   , buffer:'PackedByteArray'   , size_bytes:'int'   ) -> None:
    r'''
				Sets the push constant data to `buffer` for the specified `compute_list`. The shader determines how this binary data is used. The buffer's size in bytes must also be specified in `size_bytes` (this can be obtained by calling the `PackedByteArray.size` method on the passed `buffer`).
			'''

    assert isinstance(compute_list, (int, float)), 'compute_list must be int or float'
    assert(not buffer is None)
    assert isinstance(buffer, PackedByteArray), 'buffer must be PackedByteArray'
    assert isinstance(size_bytes, (int, float)), 'size_bytes must be int or float'








    self._ptr.call_with_return(124,tuple([compute_list, buffer._ptr, size_bytes]))

  @functools.native_method
  def compute_list_bind_uniform_set(self, compute_list:'int'   , uniform_set:'RID'   , set_index:'int'   ) -> None:
    r'''
				Binds the `uniform_set` to this `compute_list`. Godot ensures that all textures in the uniform set have the correct Vulkan access masks. If Godot had to change access masks of textures, it will raise a Vulkan image memory barrier.
			'''

    assert isinstance(compute_list, (int, float)), 'compute_list must be int or float'
    assert(not uniform_set is None)
    assert isinstance(uniform_set, RID), 'uniform_set must be RID'
    assert isinstance(set_index, (int, float)), 'set_index must be int or float'








    self._ptr.call_with_return(125,tuple([compute_list, uniform_set._ptr, set_index]))

  @functools.native_method
  def compute_list_dispatch(self, compute_list:'int'   , x_groups:'int'   , y_groups:'int'   , z_groups:'int'   ) -> None:
    r'''
				Submits the compute list for processing on the GPU. This is the compute equivalent to `draw_list_draw`.
			'''

    assert isinstance(compute_list, (int, float)), 'compute_list must be int or float'
    assert isinstance(x_groups, (int, float)), 'x_groups must be int or float'
    assert isinstance(y_groups, (int, float)), 'y_groups must be int or float'
    assert isinstance(z_groups, (int, float)), 'z_groups must be int or float'









    self._ptr.call_with_return(126,tuple([compute_list, x_groups, y_groups, z_groups]))

  @functools.native_method
  def compute_list_dispatch_indirect(self, compute_list:'int'   , buffer:'RID'   , offset:'int'   ) -> None:
    r'''
				Submits the compute list for processing on the GPU with the given group counts stored in the `buffer` at `offset`. Buffer must have been created with `constant STORAGE_BUFFER_USAGE_DISPATCH_INDIRECT` flag.
			'''

    assert isinstance(compute_list, (int, float)), 'compute_list must be int or float'
    assert(not buffer is None)
    assert isinstance(buffer, RID), 'buffer must be RID'
    assert isinstance(offset, (int, float)), 'offset must be int or float'








    self._ptr.call_with_return(127,tuple([compute_list, buffer._ptr, offset]))

  @functools.native_method
  def compute_list_add_barrier(self, compute_list:'int'   ) -> None:
    r'''
				Raises a Vulkan compute barrier in the specified `compute_list`.
			'''

    assert isinstance(compute_list, (int, float)), 'compute_list must be int or float'






    self._ptr.call_with_return(128,tuple([compute_list]))

  @functools.native_method
  def compute_list_end(self) -> None:
    r'''
				Finishes a list of compute commands created with the `compute_*` methods.
			'''




    self._ptr.call_with_return(129,tuple([]))

  @functools.native_method
  def free_rid(self, rid:'RID'   ) -> None:
    r'''
				Tries to free an object in the RenderingDevice. To avoid memory leaks, this should be called after using an object as memory management does not occur automatically when using RenderingDevice directly.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'






    self._ptr.call_with_return(130,tuple([rid._ptr]))

  @functools.native_method
  def capture_timestamp(self, name:'str'   ) -> None:
    r'''
				Creates a timestamp marker with the specified `name`. This is used for performance reporting with the `get_captured_timestamp_cpu_time`, `get_captured_timestamp_gpu_time` and `get_captured_timestamp_name` methods.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'




    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(131,tuple([py_string_name._ptr]))

  @functools.native_method
  def get_captured_timestamps_count(self) -> typing.Union[int]:
    r'''
				Returns the total number of timestamps (rendering steps) available for profiling.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(132,tuple([]))
    return _ret


  @functools.native_method
  def get_captured_timestamps_frame(self) -> typing.Union[int]:
    r'''
				Returns the index of the last frame rendered that has rendering timestamps available for querying.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(133,tuple([]))
    return _ret


  @functools.native_method
  def get_captured_timestamp_gpu_time(self, index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the timestamp in GPU time for the rendering step specified by `index` (in microseconds since the engine started). See also `get_captured_timestamp_cpu_time` and `capture_timestamp`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(134,tuple([index]))
    return _ret


  @functools.native_method
  def get_captured_timestamp_cpu_time(self, index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the timestamp in CPU time for the rendering step specified by `index` (in microseconds since the engine started). See also `get_captured_timestamp_gpu_time` and `capture_timestamp`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(135,tuple([index]))
    return _ret


  @functools.native_method
  def get_captured_timestamp_name(self, index:'int'   ) -> typing.Union[str]:
    r'''
				Returns the timestamp's name for the rendering step specified by `index`. See also `capture_timestamp`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'






    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(136,tuple([index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def has_feature(self, feature:'int'  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the `feature` is supported by the GPU.
			'''

    assert isinstance(feature, (int, float)), 'feature must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(137,tuple([feature]))
    return _ret


  @functools.native_method
  def limit_get(self, limit:'int'  ) -> typing.Union[int]:
    r'''
				Returns the value of the specified `limit`. This limit varies depending on the current graphics hardware (and sometimes the driver version). If the given limit is exceeded, rendering errors will occur.
				Limits for various graphics hardware can be found in the `url=https://vulkan.gpuinfo.org/`Vulkan Hardware Database`/url`.
			'''

    assert isinstance(limit, (int, float)), 'limit must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(138,tuple([limit]))
    return _ret


  @functools.native_method
  def get_frame_delay(self) -> typing.Union[int]:
    r'''
				Returns the frame count kept by the graphics API. Higher values result in higher input lag, but with more consistent throughput. For the main `RenderingDevice`, frames are cycled (usually 3 with triple-buffered V-Sync enabled). However, local `RenderingDevice`s only have 1 frame.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(139,tuple([]))
    return _ret


  @functools.native_method
  def submit(self) -> None:
    r'''
				Pushes the frame setup and draw command buffers then marks the local device as currently processing (which allows calling `sync`).
				**Note:** Only available in local RenderingDevices.
			'''




    self._ptr.call_with_return(140,tuple([]))

  @functools.native_method
  def sync(self) -> None:
    r'''
				Forces a synchronization between the CPU and GPU, which may be required in certain cases. Only call this when needed, as CPU-GPU synchronization has a performance cost.
				**Note:** Only available in local RenderingDevices.
				**Note:** `sync` can only be called after a `submit`.
			'''




    self._ptr.call_with_return(141,tuple([]))

  @functools.native_method
  def barrier(self, from_:'int' =32767  , to:'int' =32767  ) -> None:
    r'''
				This method does nothing.
			'''





    assert isinstance(from_, (int, float)), 'from_ must be int or float'
    assert isinstance(to, (int, float)), 'to must be int or float'







    self._ptr.call_with_return(142,tuple([from_, to]))

  @functools.native_method
  def full_barrier(self) -> None:
    r'''
				This method does nothing.
			'''




    self._ptr.call_with_return(143,tuple([]))

  @functools.native_method
  def create_local_device(self) -> typing.Union['typing.Self']:
    r'''
				Create a new local `RenderingDevice`. This is most useful for performing compute operations on the GPU independently from the rest of the engine.
			'''




    _ret = RenderingDevice.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(144,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_resource_name(self, id:'RID'   , name:'str'   ) -> None:
    r'''
				Sets the resource name for `id` to `name`. This is used for debugging with third-party tools such as `url=https://renderdoc.org/`RenderDoc`/url`.
				The following types of resources can be named: texture, sampler, vertex buffer, index buffer, uniform buffer, texture buffer, storage buffer, uniform set buffer, shader, render pipeline and compute pipeline. Framebuffers cannot be named. Attempting to name an incompatible resource type will print an error.
				**Note:** Resource names are only set when the engine runs in verbose mode (`OS.is_stdout_verbose` = `true`), or when using an engine build compiled with the `dev_mode=yes` SCons option. The graphics driver must also support the `VK_EXT_DEBUG_UTILS_EXTENSION_NAME` Vulkan extension for named resources to work.
			'''

    assert(not id is None)
    assert isinstance(id, RID), 'id must be RID'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(145,tuple([id._ptr, py_string_name._ptr]))

  @functools.native_method
  def draw_command_begin_label(self, name:'str'   , color:'Color'   ) -> None:
    r'''
				Create a command buffer debug label region that can be displayed in third-party tools such as `url=https://renderdoc.org/`RenderDoc`/url`. All regions must be ended with a `draw_command_end_label` call. When viewed from the linear series of submissions to a single queue, calls to `draw_command_begin_label` and `draw_command_end_label` must be matched and balanced.
				The `VK_EXT_DEBUG_UTILS_EXTENSION_NAME` Vulkan extension must be available and enabled for command buffer debug label region to work. See also `draw_command_end_label`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'




    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)


    self._ptr.call_with_return(146,tuple([py_string_name._ptr, color._ptr]))

  @functools.native_method
  def draw_command_insert_label(self, name:'str'   , color:'Color'   ) -> None:
    r'''
				This method does nothing.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'




    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)


    self._ptr.call_with_return(147,tuple([py_string_name._ptr, color._ptr]))

  @functools.native_method
  def draw_command_end_label(self) -> None:
    r'''
				Ends the command buffer debug label region started by a `draw_command_begin_label` call.
			'''




    self._ptr.call_with_return(148,tuple([]))

  @functools.native_method
  def get_device_vendor_name(self) -> typing.Union[str]:
    r'''
				Returns the vendor of the video adapter (e.g. "NVIDIA Corporation"). Equivalent to `RenderingServer.get_video_adapter_vendor`. See also `get_device_name`.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(149,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_device_name(self) -> typing.Union[str]:
    r'''
				Returns the name of the video adapter (e.g. "GeForce GTX 1080/PCIe/SSE2"). Equivalent to `RenderingServer.get_video_adapter_name`. See also `get_device_vendor_name`.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(150,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_device_pipeline_cache_uuid(self) -> typing.Union[str]:
    r'''
				Returns the universally unique identifier for the pipeline cache. This is used to cache shader files on disk, which avoids shader recompilations on subsequent engine runs. This UUID varies depending on the graphics card model, but also the driver version. Therefore, updating graphics drivers will invalidate the shader cache.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(151,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_memory_usage(self, type:'int'  ) -> typing.Union[int]:
    r'''
				Returns the memory usage in bytes corresponding to the given `type`. When using Vulkan, these statistics are calculated by `url=https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator`Vulkan Memory Allocator`/url`.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(152,tuple([type]))
    return _ret


  @functools.native_method
  def get_driver_resource(self, resource:'int'  , rid:'RID'   , index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the unique identifier of the driver `resource` for the specified `rid`. Some driver resource types ignore the specified `rid`. `index` is always ignored but must be specified anyway.
			'''

    assert isinstance(resource, (int, float)), 'resource must be int or float'
    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(153,tuple([resource, rid._ptr, index]))
    return _ret


  @functools.native_method
  def get_perf_report(self) -> typing.Union[str]:
    r'''
				Returns a string with a performance report from the past frame. Updates every frame.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(154,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_driver_and_device_memory_report(self) -> typing.Union[str]:
    r'''
				Returns string report in CSV format using the following methods:
				- `get_tracked_object_name`
				- `get_tracked_object_type_count`
				- `get_driver_total_memory`
				- `get_driver_allocation_count`
				- `get_driver_memory_by_object_type`
				- `get_driver_allocs_by_object_type`
				- `get_device_total_memory`
				- `get_device_allocation_count`
				- `get_device_memory_by_object_type`
				- `get_device_allocs_by_object_type`
				This is only used by Vulkan in debug builds. Godot must also be started with the `--extra-gpu-memory-tracking` `url=$DOCS_URL/tutorials/editor/command_line_tutorial.html`command line argument`/url`.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(155,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_tracked_object_name(self, type_index:'int'   ) -> typing.Union[str]:
    r'''
				Returns the name of the type of object for the given `type_index`. This value must be in range ``0; get_tracked_object_type_count - 1``. If `get_tracked_object_type_count` is 0, then type argument is ignored and always returns the same string.
				The return value is important because it gives meaning to the types passed to `get_driver_memory_by_object_type`, `get_driver_allocs_by_object_type`, `get_device_memory_by_object_type`, and `get_device_allocs_by_object_type`. Examples of strings it can return (not exhaustive):
				- DEVICE_MEMORY
				- PIPELINE_CACHE
				- SWAPCHAIN_KHR
				- COMMAND_POOL
				Thus if e.g. `get_tracked_object_name(5)` returns "COMMAND_POOL", then `get_device_memory_by_object_type(5)` returns the bytes used by the GPU for command pools.
				This is only used by Vulkan in debug builds. Godot must also be started with the `--extra-gpu-memory-tracking` `url=$DOCS_URL/tutorials/editor/command_line_tutorial.html`command line argument`/url`.
			'''

    assert isinstance(type_index, (int, float)), 'type_index must be int or float'






    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(156,tuple([type_index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_tracked_object_type_count(self) -> typing.Union[int]:
    r'''
				Returns how many types of trackable objects there are.
				This is only used by Vulkan in debug builds. Godot must also be started with the `--extra-gpu-memory-tracking` `url=$DOCS_URL/tutorials/editor/command_line_tutorial.html`command line argument`/url`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(157,tuple([]))
    return _ret


  @functools.native_method
  def get_driver_total_memory(self) -> typing.Union[int]:
    r'''
				Returns how much bytes the GPU driver is using for internal driver structures.
				This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(158,tuple([]))
    return _ret


  @functools.native_method
  def get_driver_allocation_count(self) -> typing.Union[int]:
    r'''
				Returns how many allocations the GPU driver has performed for internal driver structures.
				This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(159,tuple([]))
    return _ret


  @functools.native_method
  def get_driver_memory_by_object_type(self, type:'int'   ) -> typing.Union[int]:
    r'''
				Same as `get_driver_total_memory` but filtered for a given object type.
				The type argument must be in range ``0; get_tracked_object_type_count - 1``. If `get_tracked_object_type_count` is 0, then type argument is ignored and always returns 0.
				This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(160,tuple([type]))
    return _ret


  @functools.native_method
  def get_driver_allocs_by_object_type(self, type:'int'   ) -> typing.Union[int]:
    r'''
				Same as `get_driver_allocation_count` but filtered for a given object type.
				The type argument must be in range ``0; get_tracked_object_type_count - 1``. If `get_tracked_object_type_count` is 0, then type argument is ignored and always returns 0.
				This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(161,tuple([type]))
    return _ret


  @functools.native_method
  def get_device_total_memory(self) -> typing.Union[int]:
    r'''
				Returns how much bytes the GPU is using.
				This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(162,tuple([]))
    return _ret


  @functools.native_method
  def get_device_allocation_count(self) -> typing.Union[int]:
    r'''
				Returns how many allocations the GPU has performed for internal driver structures.
				This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(163,tuple([]))
    return _ret


  @functools.native_method
  def get_device_memory_by_object_type(self, type:'int'   ) -> typing.Union[int]:
    r'''
				Same as `get_device_total_memory` but filtered for a given object type.
				The type argument must be in range ``0; get_tracked_object_type_count - 1``. If `get_tracked_object_type_count` is 0, then type argument is ignored and always returns 0.
				This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(164,tuple([type]))
    return _ret


  @functools.native_method
  def get_device_allocs_by_object_type(self, type:'int'   ) -> typing.Union[int]:
    r'''
				Same as `get_device_allocation_count` but filtered for a given object type.
				The type argument must be in range ``0; get_tracked_object_type_count - 1``. If `get_tracked_object_type_count` is 0, then type argument is ignored and always returns 0.
				This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'






    _ret = 0
    _ret = self._ptr.call_with_return(165,tuple([type]))
    return _ret



register_cast_function('RenderingDevice', RenderingDevice.cast)
register_class('RenderingDevice', RenderingDevice)
