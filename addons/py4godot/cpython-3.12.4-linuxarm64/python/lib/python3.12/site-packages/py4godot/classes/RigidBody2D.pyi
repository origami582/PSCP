from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.D as __d__
import py4godot.classes.r as __r__
import py4godot.classes.a as __a__
import py4godot.classes.PhysicsMaterial as __physicsmaterial__
import py4godot.classes.RigidBody2D as __rigidbody2d__
import py4godot.classes.A as __a__
import py4godot.classes.d as __d__
import py4godot.classes.PhysicsBody2D as __physicsbody2d__
import py4godot.classes.PhysicsDirectBodyState2D as __physicsdirectbodystate2d__
import py4godot.classes.N as __n__
import py4godot.classes.p as __p__
import py4godot.classes.o as __o__
import py4godot.classes.y as __y__
import py4godot.classes.PhysicalBone2D as __physicalbone2d__
import py4godot.classes.2 as __2__
import py4godot.classes.e as __e__
import py4godot.classes.T as __t__


class FreezeMode:
  FREEZE_MODE_STATIC:int = 0
  FREEZE_MODE_KINEMATIC:int = 1
class CenterOfMassMode:
  CENTER_OF_MASS_MODE_AUTO:int = 0
  CENTER_OF_MASS_MODE_CUSTOM:int = 1
class DampMode:
  DAMP_MODE_COMBINE:int = 0
  DAMP_MODE_REPLACE:int = 1
class CCDMode:
  CCD_MODE_DISABLED:int = 0
  CCD_MODE_CAST_RAY:int = 1
  CCD_MODE_CAST_SHAPE:int = 2


class RigidBody2D(__physicsbody2d__.PhysicsBody2D):
  """
		`RigidBody2D` implements full 2D physics. It cannot be controlled directly, instead, you must apply forces to it (gravity, impulses, etc.), and the physics simulation will calculate the resulting movement, rotation, react to collisions, and affect other physics bodies in its path.
		The body's behavior can be adjusted via `lock_rotation`, `freeze`, and `freeze_mode`. By changing various properties of the object, such as `mass`, you can control how the physics simulation acts on it.
		A rigid body will always maintain its shape and size, even when forces are applied to it. It is useful for objects that can be interacted with in an environment, such as a tree that can be knocked over or a stack of crates that can be pushed around.
		If you need to directly affect the body, prefer `_integrate_forces` as it allows you to directly access the physics state.
		If you need to override the default physics behavior, you can write a custom force integration function. See `custom_integrator`.
		**Note:** Changing the 2D transform or `linear_velocity` of a `RigidBody2D` very often may lead to some unpredictable behaviors. This also happens when a `RigidBody2D` is the descendant of a constantly moving node, like another `RigidBody2D`, as that will cause its global transform to be set whenever its ancestor moves.
	"""
  body_shape_entered: BuiltinSignal
  body_shape_exited: BuiltinSignal
  body_entered: BuiltinSignal
  body_exited: BuiltinSignal
  sleeping_state_changed: BuiltinSignal

  @staticmethod
  def constructor()->RigidBody2D:pass



  @staticmethod
  def cast(other:__object__.Object)->RigidBody2D:pass


  @property
  def mass(self)->float:
    """"""
    pass
  @mass.setter
  def mass(self,  value:float)->None:
    """"""
    pass
  @property
  def physics_material_override(self)->__physicsmaterial__.PhysicsMaterial:
    """"""
    pass
  @physics_material_override.setter
  def physics_material_override(self,  value:__physicsmaterial__.PhysicsMaterial)->None:
    """"""
    pass
  @property
  def gravity_scale(self)->float:
    """"""
    pass
  @gravity_scale.setter
  def gravity_scale(self,  value:float)->None:
    """"""
    pass
  @property
  def center_of_mass_mode(self)->int:
    """"""
    pass
  @center_of_mass_mode.setter
  def center_of_mass_mode(self,  value:int)->None:
    """"""
    pass
  @property
  def center_of_mass(self)->__core__.Vector2:
    """"""
    pass
  @center_of_mass.setter
  def center_of_mass(self,  value:__core__.Vector2)->None:
    """"""
    pass
  @property
  def inertia(self)->float:
    """"""
    pass
  @inertia.setter
  def inertia(self,  value:float)->None:
    """"""
    pass
  @property
  def sleeping(self)->bool:
    """"""
    pass
  @sleeping.setter
  def sleeping(self,  value:bool)->None:
    """"""
    pass
  @property
  def can_sleep(self)->bool:
    """"""
    pass
  @can_sleep.setter
  def can_sleep(self,  value:bool)->None:
    """"""
    pass
  @property
  def lock_rotation(self)->bool:
    """"""
    pass
  @lock_rotation.setter
  def lock_rotation(self,  value:bool)->None:
    """"""
    pass
  @property
  def freeze(self)->bool:
    """"""
    pass
  @freeze.setter
  def freeze(self,  value:bool)->None:
    """"""
    pass
  @property
  def freeze_mode(self)->int:
    """"""
    pass
  @freeze_mode.setter
  def freeze_mode(self,  value:int)->None:
    """"""
    pass
  @property
  def custom_integrator(self)->bool:
    """"""
    pass
  @custom_integrator.setter
  def custom_integrator(self,  value:bool)->None:
    """"""
    pass
  @property
  def continuous_cd(self)->int:
    """"""
    pass
  @continuous_cd.setter
  def continuous_cd(self,  value:int)->None:
    """"""
    pass
  @property
  def contact_monitor(self)->bool:
    """"""
    pass
  @contact_monitor.setter
  def contact_monitor(self,  value:bool)->None:
    """"""
    pass
  @property
  def max_contacts_reported(self)->int:
    """"""
    pass
  @max_contacts_reported.setter
  def max_contacts_reported(self,  value:int)->None:
    """"""
    pass
  @property
  def linear_velocity(self)->__core__.Vector2:
    """"""
    pass
  @linear_velocity.setter
  def linear_velocity(self,  value:__core__.Vector2)->None:
    """"""
    pass
  @property
  def linear_damp_mode(self)->int:
    """"""
    pass
  @linear_damp_mode.setter
  def linear_damp_mode(self,  value:int)->None:
    """"""
    pass
  @property
  def linear_damp(self)->float:
    """"""
    pass
  @linear_damp.setter
  def linear_damp(self,  value:float)->None:
    """"""
    pass
  @property
  def angular_velocity(self)->float:
    """"""
    pass
  @angular_velocity.setter
  def angular_velocity(self,  value:float)->None:
    """"""
    pass
  @property
  def angular_damp_mode(self)->int:
    """"""
    pass
  @angular_damp_mode.setter
  def angular_damp_mode(self,  value:int)->None:
    """"""
    pass
  @property
  def angular_damp(self)->float:
    """"""
    pass
  @angular_damp.setter
  def angular_damp(self,  value:float)->None:
    """"""
    pass
  @property
  def constant_force(self)->__core__.Vector2:
    """"""
    pass
  @constant_force.setter
  def constant_force(self,  value:__core__.Vector2)->None:
    """"""
    pass
  @property
  def constant_torque(self)->float:
    """"""
    pass
  @constant_torque.setter
  def constant_torque(self,  value:float)->None:
    """"""
    pass
  def _integrate_forces(self, state:__physicsdirectbodystate2d__.PhysicsDirectBodyState2D)->None:
    """
				Called during physics processing, allowing you to read and safely modify the simulation state for the object. By default, it is called before the standard force integration, but the `custom_integrator` property allows you to disable the standard force integration and do fully custom force integration for a body.
			"""
    pass

  def set_mass(self, mass:float)->None:
    """"""
    pass

  def get_mass(self)->float:
    """"""
    pass

  def get_inertia(self)->float:
    """"""
    pass

  def set_inertia(self, inertia:float)->None:
    """"""
    pass

  def set_center_of_mass_mode(self, mode:int )->None:
    """"""
    pass

  def get_center_of_mass_mode(self)->int:
    """"""
    pass

  def set_center_of_mass(self, center_of_mass:__core__.Vector2)->None:
    """"""
    pass

  def get_center_of_mass(self)->__core__.Vector2:
    """"""
    pass

  def set_physics_material_override(self, physics_material_override:__physicsmaterial__.PhysicsMaterial)->None:
    """"""
    pass

  def get_physics_material_override(self)->__physicsmaterial__.PhysicsMaterial:
    """"""
    pass

  def set_gravity_scale(self, gravity_scale:float)->None:
    """"""
    pass

  def get_gravity_scale(self)->float:
    """"""
    pass

  def set_linear_damp_mode(self, linear_damp_mode:int )->None:
    """"""
    pass

  def get_linear_damp_mode(self)->int:
    """"""
    pass

  def set_angular_damp_mode(self, angular_damp_mode:int )->None:
    """"""
    pass

  def get_angular_damp_mode(self)->int:
    """"""
    pass

  def set_linear_damp(self, linear_damp:float)->None:
    """"""
    pass

  def get_linear_damp(self)->float:
    """"""
    pass

  def set_angular_damp(self, angular_damp:float)->None:
    """"""
    pass

  def get_angular_damp(self)->float:
    """"""
    pass

  def set_linear_velocity(self, linear_velocity:__core__.Vector2)->None:
    """"""
    pass

  def get_linear_velocity(self)->__core__.Vector2:
    """"""
    pass

  def set_angular_velocity(self, angular_velocity:float)->None:
    """"""
    pass

  def get_angular_velocity(self)->float:
    """"""
    pass

  def set_max_contacts_reported(self, amount:int)->None:
    """"""
    pass

  def get_max_contacts_reported(self)->int:
    """"""
    pass

  def get_contact_count(self)->int:
    """
				Returns the number of contacts this body has with other bodies. By default, this returns 0 unless bodies are configured to monitor contacts (see `contact_monitor`).
				**Note:** To retrieve the colliding bodies, use `get_colliding_bodies`.
			"""
    pass

  def set_use_custom_integrator(self, enable:bool)->None:
    """"""
    pass

  def is_using_custom_integrator(self)->bool:
    """"""
    pass

  def set_contact_monitor(self, enabled:bool)->None:
    """"""
    pass

  def is_contact_monitor_enabled(self)->bool:
    """"""
    pass

  def set_continuous_collision_detection_mode(self, mode:int )->None:
    """"""
    pass

  def get_continuous_collision_detection_mode(self)->int:
    """"""
    pass

  def set_axis_velocity(self, axis_velocity:__core__.Vector2)->None:
    """
				Sets the body's velocity on the given axis. The velocity in the given vector axis will be set as the given vector length. This is useful for jumping behavior.
			"""
    pass

  def apply_central_impulse(self, impulse:__core__.Vector2= __core__.Vector2.new0())->None:
    """
				Applies a directional impulse without affecting rotation.
				An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
				This is equivalent to using `apply_impulse` at the body's center of mass.
			"""
    pass

  def apply_impulse(self, impulse:__core__.Vector2, position:__core__.Vector2= __core__.Vector2.new0())->None:
    """
				Applies a positioned impulse to the body.
				An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
				`position` is the offset from the body origin in global coordinates.
			"""
    pass

  def apply_torque_impulse(self, torque:float)->None:
    """
				Applies a rotational impulse to the body without affecting the position.
				An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
				**Note:** `inertia` is required for this to work. To have `inertia`, an active `CollisionShape2D` must be a child of the node, or you can manually set `inertia`.
			"""
    pass

  def apply_central_force(self, force:__core__.Vector2)->None:
    """
				Applies a directional force without affecting rotation. A force is time dependent and meant to be applied every physics update.
				This is equivalent to using `apply_force` at the body's center of mass.
			"""
    pass

  def apply_force(self, force:__core__.Vector2, position:__core__.Vector2= __core__.Vector2.new0())->None:
    """
				Applies a positioned force to the body. A force is time dependent and meant to be applied every physics update.
				`position` is the offset from the body origin in global coordinates.
			"""
    pass

  def apply_torque(self, torque:float)->None:
    """
				Applies a rotational force without affecting position. A force is time dependent and meant to be applied every physics update.
				**Note:** `inertia` is required for this to work. To have `inertia`, an active `CollisionShape2D` must be a child of the node, or you can manually set `inertia`.
			"""
    pass

  def add_constant_central_force(self, force:__core__.Vector2)->None:
    """
				Adds a constant directional force without affecting rotation that keeps being applied over time until cleared with `constant_force = Vector2(0, 0)`.
				This is equivalent to using `add_constant_force` at the body's center of mass.
			"""
    pass

  def add_constant_force(self, force:__core__.Vector2, position:__core__.Vector2= __core__.Vector2.new0())->None:
    """
				Adds a constant positioned force to the body that keeps being applied over time until cleared with `constant_force = Vector2(0, 0)`.
				`position` is the offset from the body origin in global coordinates.
			"""
    pass

  def add_constant_torque(self, torque:float)->None:
    """
				Adds a constant rotational force without affecting position that keeps being applied over time until cleared with `constant_torque = 0`.
			"""
    pass

  def set_constant_force(self, force:__core__.Vector2)->None:
    """"""
    pass

  def get_constant_force(self)->__core__.Vector2:
    """"""
    pass

  def set_constant_torque(self, torque:float)->None:
    """"""
    pass

  def get_constant_torque(self)->float:
    """"""
    pass

  def set_sleeping(self, sleeping:bool)->None:
    """"""
    pass

  def is_sleeping(self)->bool:
    """"""
    pass

  def set_can_sleep(self, able_to_sleep:bool)->None:
    """"""
    pass

  def is_able_to_sleep(self)->bool:
    """"""
    pass

  def set_lock_rotation_enabled(self, lock_rotation:bool)->None:
    """"""
    pass

  def is_lock_rotation_enabled(self)->bool:
    """"""
    pass

  def set_freeze_enabled(self, freeze_mode:bool)->None:
    """"""
    pass

  def is_freeze_enabled(self)->bool:
    """"""
    pass

  def set_freeze_mode(self, freeze_mode:int )->None:
    """"""
    pass

  def get_freeze_mode(self)->int:
    """"""
    pass

  def get_colliding_bodies(self)->typedarray::Node2D:
    """
				Returns a list of the bodies colliding with this one. Requires `contact_monitor` to be set to `true` and `max_contacts_reported` to be set high enough to detect all the collisions.
				**Note:** The result of this test is not immediate after moving objects. For performance, list of collisions is updated once per frame and before the physics step. Consider using signals instead.
			"""
    pass


