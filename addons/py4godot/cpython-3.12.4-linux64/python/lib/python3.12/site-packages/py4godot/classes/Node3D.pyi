from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.NavigationLink3D as __navigationlink3d__
import py4godot.classes.GPUParticlesCollisionBox3D as __gpuparticlescollisionbox3d__
import py4godot.classes.CSGCombiner3D as __csgcombiner3d__
import py4godot.classes.Skeleton3D as __skeleton3d__
import py4godot.classes.LookAtModifier3D as __lookatmodifier3d__
import py4godot.classes.RootMotionView as __rootmotionview__
import py4godot.classes.SpringBoneCollisionCapsule3D as __springbonecollisioncapsule3d__
import py4godot.classes.PathFollow3D as __pathfollow3d__
import py4godot.classes.DirectionalLight3D as __directionallight3d__
import py4godot.classes.PhysicalBoneSimulator3D as __physicalbonesimulator3d__
import py4godot.classes.MeshInstance3D as __meshinstance3d__
import py4godot.classes.m as __m__
import py4godot.classes.o as __o__
import py4godot.classes.SpotLight3D as __spotlight3d__
import py4godot.classes.SliderJoint3D as __sliderjoint3d__
import py4godot.classes.CSGMesh3D as __csgmesh3d__
import py4godot.classes.SpringBoneCollisionSphere3D as __springbonecollisionsphere3d__
import py4godot.classes.SoftBody3D as __softbody3d__
import py4godot.classes.Node as __node__
import py4godot.classes.GPUParticles3D as __gpuparticles3d__
import py4godot.classes.CSGPrimitive3D as __csgprimitive3d__
import py4godot.classes.GridMap as __gridmap__
import py4godot.classes.Camera3D as __camera3d__
import py4godot.classes.OccluderInstance3D as __occluderinstance3d__
import py4godot.classes.Decal as __decal__
import py4godot.classes.y as __y__
import py4godot.classes.OpenXRCompositionLayerQuad as __openxrcompositionlayerquad__
import py4godot.classes.SpriteBase3D as __spritebase3d__
import py4godot.classes.VisualInstance3D as __visualinstance3d__
import py4godot.classes.D as __d__
import py4godot.classes.ShapeCast3D as __shapecast3d__
import py4godot.classes.PhysicalBone3D as __physicalbone3d__
import py4godot.classes.CSGSphere3D as __csgsphere3d__
import py4godot.classes.GPUParticlesCollisionSDF3D as __gpuparticlescollisionsdf3d__
import py4godot.classes.GPUParticlesCollisionSphere3D as __gpuparticlescollisionsphere3d__
import py4godot.classes.VisibleOnScreenNotifier3D as __visibleonscreennotifier3d__
import py4godot.classes.NavigationRegion3D as __navigationregion3d__
import py4godot.classes.CSGShape3D as __csgshape3d__
import py4godot.classes.i as __i__
import py4godot.classes.Marker3D as __marker3d__
import py4godot.classes.CollisionPolygon3D as __collisionpolygon3d__
import py4godot.classes.XRAnchor3D as __xranchor3d__
import py4godot.classes.T as __t__
import py4godot.classes.SpringBoneCollision3D as __springbonecollision3d__
import py4godot.classes.r as __r__
import py4godot.classes.XRController3D as __xrcontroller3d__
import py4godot.classes.OpenXRCompositionLayerCylinder as __openxrcompositionlayercylinder__
import py4godot.classes.SpringBoneCollisionPlane3D as __springbonecollisionplane3d__
import py4godot.classes.CSGPolygon3D as __csgpolygon3d__
import py4godot.classes.d as __d__
import py4godot.classes.RayCast3D as __raycast3d__
import py4godot.classes.Area3D as __area3d__
import py4godot.classes.AnimatedSprite3D as __animatedsprite3d__
import py4godot.classes.XRBodyModifier3D as __xrbodymodifier3d__
import py4godot.classes.HingeJoint3D as __hingejoint3d__
import py4godot.classes.GPUParticlesCollisionHeightField3D as __gpuparticlescollisionheightfield3d__
import py4godot.classes.GPUParticlesCollision3D as __gpuparticlescollision3d__
import py4godot.classes.CSGTorus3D as __csgtorus3d__
import py4godot.classes.3 as __3__
import py4godot.classes.Light3D as __light3d__
import py4godot.classes.OpenXRHand as __openxrhand__
import py4godot.classes.GPUParticlesAttractorBox3D as __gpuparticlesattractorbox3d__
import py4godot.classes.BoneAttachment3D as __boneattachment3d__
import py4godot.classes.XRCamera3D as __xrcamera3d__
import py4godot.classes.p as __p__
import py4godot.classes.NavigationObstacle3D as __navigationobstacle3d__
import py4godot.classes.StaticBody3D as __staticbody3d__
import py4godot.classes.Sprite3D as __sprite3d__
import py4godot.classes.GPUParticlesAttractor3D as __gpuparticlesattractor3d__
import py4godot.classes.XRFaceModifier3D as __xrfacemodifier3d__
import py4godot.classes.OpenXRCompositionLayerEquirect as __openxrcompositionlayerequirect__
import py4godot.classes.CharacterBody3D as __characterbody3d__
import py4godot.classes.GPUParticlesAttractorSphere3D as __gpuparticlesattractorsphere3d__
import py4godot.classes.Joint3D as __joint3d__
import py4godot.classes.AnimatableBody3D as __animatablebody3d__
import py4godot.classes.ConeTwistJoint3D as __conetwistjoint3d__
import py4godot.classes.CSGBox3D as __csgbox3d__
import py4godot.classes.RetargetModifier3D as __retargetmodifier3d__
import py4godot.classes.A as __a__
import py4godot.classes.RigidBody3D as __rigidbody3d__
import py4godot.classes.CollisionShape3D as __collisionshape3d__
import py4godot.classes.CollisionObject3D as __collisionobject3d__
import py4godot.classes.G as __g__
import py4godot.classes.N as __n__
import py4godot.classes.OpenXRCompositionLayer as __openxrcompositionlayer__
import py4godot.classes.CSGCylinder3D as __csgcylinder3d__
import py4godot.classes.ImporterMeshInstance3D as __importermeshinstance3d__
import py4godot.classes.Generic6DOFJoint3D as __generic6dofjoint3d__
import py4godot.classes.SpringBoneSimulator3D as __springbonesimulator3d__
import py4godot.classes.LightmapProbe as __lightmapprobe__
import py4godot.classes.FogVolume as __fogvolume__
import py4godot.classes.AudioStreamPlayer3D as __audiostreamplayer3d__
import py4godot.classes.a as __a__
import py4godot.classes.Node3DGizmo as __node3dgizmo__
import py4godot.classes.z as __z__
import py4godot.classes.CPUParticles3D as __cpuparticles3d__
import py4godot.classes.Node3D as __node3d__
import py4godot.classes.AudioListener3D as __audiolistener3d__
import py4godot.classes.VehicleWheel3D as __vehiclewheel3d__
import py4godot.classes.VoxelGI as __voxelgi__
import py4godot.classes.GeometryInstance3D as __geometryinstance3d__
import py4godot.classes.XROrigin3D as __xrorigin3d__
import py4godot.classes.SpringArm3D as __springarm3d__
import py4godot.classes.Path3D as __path3d__
import py4godot.classes.RemoteTransform3D as __remotetransform3d__
import py4godot.classes.PinJoint3D as __pinjoint3d__
import py4godot.classes.e as __e__
import py4godot.classes.SkeletonIK3D as __skeletonik3d__
import py4godot.classes.OpenXRVisibilityMask as __openxrvisibilitymask__
import py4godot.classes.ReflectionProbe as __reflectionprobe__
import py4godot.classes.SkeletonModifier3D as __skeletonmodifier3d__
import py4godot.classes.VehicleBody3D as __vehiclebody3d__
import py4godot.classes.MultiMeshInstance3D as __multimeshinstance3d__
import py4godot.classes.PhysicsBody3D as __physicsbody3d__
import py4godot.classes.XRNode3D as __xrnode3d__
import py4godot.classes.XRHandModifier3D as __xrhandmodifier3d__
import py4godot.classes.GPUParticlesAttractorVectorField3D as __gpuparticlesattractorvectorfield3d__
import py4godot.classes.World3D as __world3d__
import py4godot.classes.Label3D as __label3d__
import py4godot.classes.OmniLight3D as __omnilight3d__
import py4godot.classes.VisibleOnScreenEnabler3D as __visibleonscreenenabler3d__
import py4godot.classes.LightmapGI as __lightmapgi__


class RotationEditMode:
  ROTATION_EDIT_MODE_EULER:int = 0
  ROTATION_EDIT_MODE_QUATERNION:int = 1
  ROTATION_EDIT_MODE_BASIS:int = 2


class Node3D(__node__.Node):
  """
		The `Node3D` node is the base representation of a node in 3D space. All other 3D nodes inherit from this class.
		Affine operations (translation, rotation, scale) are calculated in the coordinate system relative to the parent, unless the `Node3D`'s `top_level` is `true`. In this coordinate system, affine operations correspond to direct affine operations on the `Node3D`'s `transform`. The term _parent space_ refers to this coordinate system. The coordinate system that is attached to the `Node3D` itself is referred to as object-local coordinate system, or _local space_.
		**Note:** Unless otherwise specified, all methods that need angle parameters must receive angles in _radians_. To convert degrees to radians, use `@GlobalScope.deg_to_rad`.
		**Note:** In Godot 3 and older, `Node3D` was named _Spatial_.
	"""
  visibility_changed: BuiltinSignal

  @staticmethod
  def constructor()->Node3D:pass



  @staticmethod
  def cast(other:__object__.Object)->Node3D:pass


  @property
  def transform(self)->__core__.Transform3D:
    """"""
    pass
  @transform.setter
  def transform(self,  value:__core__.Transform3D)->None:
    """"""
    pass
  @property
  def global_transform(self)->__core__.Transform3D:
    """"""
    pass
  @global_transform.setter
  def global_transform(self,  value:__core__.Transform3D)->None:
    """"""
    pass
  @property
  def position(self)->__core__.Vector3:
    """"""
    pass
  @position.setter
  def position(self,  value:__core__.Vector3)->None:
    """"""
    pass
  @property
  def rotation(self)->__core__.Vector3:
    """"""
    pass
  @rotation.setter
  def rotation(self,  value:__core__.Vector3)->None:
    """"""
    pass
  @property
  def rotation_degrees(self)->__core__.Vector3:
    """"""
    pass
  @rotation_degrees.setter
  def rotation_degrees(self,  value:__core__.Vector3)->None:
    """"""
    pass
  @property
  def quaternion(self)->__core__.Quaternion:
    """"""
    pass
  @quaternion.setter
  def quaternion(self,  value:__core__.Quaternion)->None:
    """"""
    pass
  @property
  def basis(self)->__core__.Basis:
    """"""
    pass
  @basis.setter
  def basis(self,  value:__core__.Basis)->None:
    """"""
    pass
  @property
  def scale(self)->__core__.Vector3:
    """"""
    pass
  @scale.setter
  def scale(self,  value:__core__.Vector3)->None:
    """"""
    pass
  @property
  def rotation_edit_mode(self)->int:
    """"""
    pass
  @rotation_edit_mode.setter
  def rotation_edit_mode(self,  value:int)->None:
    """"""
    pass
  @property
  def rotation_order(self)->int:
    """"""
    pass
  @rotation_order.setter
  def rotation_order(self,  value:int)->None:
    """"""
    pass
  @property
  def top_level(self)->bool:
    """"""
    pass
  @top_level.setter
  def top_level(self,  value:bool)->None:
    """"""
    pass
  @property
  def global_position(self)->__core__.Vector3:
    """"""
    pass
  @global_position.setter
  def global_position(self,  value:__core__.Vector3)->None:
    """"""
    pass
  @property
  def global_basis(self)->__core__.Basis:
    """"""
    pass
  @global_basis.setter
  def global_basis(self,  value:__core__.Basis)->None:
    """"""
    pass
  @property
  def global_rotation(self)->__core__.Vector3:
    """"""
    pass
  @global_rotation.setter
  def global_rotation(self,  value:__core__.Vector3)->None:
    """"""
    pass
  @property
  def global_rotation_degrees(self)->__core__.Vector3:
    """"""
    pass
  @global_rotation_degrees.setter
  def global_rotation_degrees(self,  value:__core__.Vector3)->None:
    """"""
    pass
  @property
  def visible(self)->bool:
    """"""
    pass
  @visible.setter
  def visible(self,  value:bool)->None:
    """"""
    pass
  @property
  def visibility_parent(self)->__core__.NodePath:
    """"""
    pass
  @visibility_parent.setter
  def visibility_parent(self,  value:__core__.NodePath)->None:
    """"""
    pass
  def set_transform(self, local:__core__.Transform3D)->None:
    """"""
    pass

  def get_transform(self)->__core__.Transform3D:
    """"""
    pass

  def set_position(self, position:__core__.Vector3)->None:
    """"""
    pass

  def get_position(self)->__core__.Vector3:
    """"""
    pass

  def set_rotation(self, euler_radians:__core__.Vector3)->None:
    """"""
    pass

  def get_rotation(self)->__core__.Vector3:
    """"""
    pass

  def set_rotation_degrees(self, euler_degrees:__core__.Vector3)->None:
    """"""
    pass

  def get_rotation_degrees(self)->__core__.Vector3:
    """"""
    pass

  def set_rotation_order(self, order:int )->None:
    """"""
    pass

  def get_rotation_order(self)->int:
    """"""
    pass

  def set_rotation_edit_mode(self, edit_mode:int )->None:
    """"""
    pass

  def get_rotation_edit_mode(self)->int:
    """"""
    pass

  def set_scale(self, scale:__core__.Vector3)->None:
    """"""
    pass

  def get_scale(self)->__core__.Vector3:
    """"""
    pass

  def set_quaternion(self, quaternion:__core__.Quaternion)->None:
    """"""
    pass

  def get_quaternion(self)->__core__.Quaternion:
    """"""
    pass

  def set_basis(self, basis:__core__.Basis)->None:
    """"""
    pass

  def get_basis(self)->__core__.Basis:
    """"""
    pass

  def set_global_transform(self, global_:__core__.Transform3D)->None:
    """"""
    pass

  def get_global_transform(self)->__core__.Transform3D:
    """"""
    pass

  def get_global_transform_interpolated(self)->__core__.Transform3D:
    """
				When using physics interpolation, there will be circumstances in which you want to know the interpolated (displayed) transform of a node rather than the standard transform (which may only be accurate to the most recent physics tick).
				This is particularly important for frame-based operations that take place in `Node._process`, rather than `Node._physics_process`. Examples include `Camera3D`s focusing on a node, or finding where to fire lasers from on a frame rather than physics tick.
				**Note:** This function creates an interpolation pump on the `Node3D` the first time it is called, which can respond to physics interpolation resets. If you get problems with "streaking" when initially following a `Node3D`, be sure to call `get_global_transform_interpolated` at least once _before_ resetting the `Node3D` physics interpolation.
			"""
    pass

  def set_global_position(self, position:__core__.Vector3)->None:
    """"""
    pass

  def get_global_position(self)->__core__.Vector3:
    """"""
    pass

  def set_global_basis(self, basis:__core__.Basis)->None:
    """"""
    pass

  def get_global_basis(self)->__core__.Basis:
    """"""
    pass

  def set_global_rotation(self, euler_radians:__core__.Vector3)->None:
    """"""
    pass

  def get_global_rotation(self)->__core__.Vector3:
    """"""
    pass

  def set_global_rotation_degrees(self, euler_degrees:__core__.Vector3)->None:
    """"""
    pass

  def get_global_rotation_degrees(self)->__core__.Vector3:
    """"""
    pass

  def get_parent_node_3d(self)->__navigationlink3d__.NavigationLink3D|__gpuparticlescollision3d__.GPUParticlesCollision3D|__gpuparticlescollisionbox3d__.GPUParticlesCollisionBox3D|__csgtorus3d__.CSGTorus3D|__csgcombiner3d__.CSGCombiner3D|__skeleton3d__.Skeleton3D|__lookatmodifier3d__.LookAtModifier3D|__light3d__.Light3D|__rootmotionview__.RootMotionView|__openxrhand__.OpenXRHand|__springbonecollisioncapsule3d__.SpringBoneCollisionCapsule3D|__gpuparticlesattractorbox3d__.GPUParticlesAttractorBox3D|__boneattachment3d__.BoneAttachment3D|__pathfollow3d__.PathFollow3D|__directionallight3d__.DirectionalLight3D|__physicalbonesimulator3d__.PhysicalBoneSimulator3D|__meshinstance3d__.MeshInstance3D|__xrcamera3d__.XRCamera3D|__navigationobstacle3d__.NavigationObstacle3D|__staticbody3d__.StaticBody3D|__sprite3d__.Sprite3D|__gpuparticlesattractor3d__.GPUParticlesAttractor3D|__xrfacemodifier3d__.XRFaceModifier3D|__openxrcompositionlayerequirect__.OpenXRCompositionLayerEquirect|__characterbody3d__.CharacterBody3D|__gpuparticlesattractorsphere3d__.GPUParticlesAttractorSphere3D|__joint3d__.Joint3D|__spotlight3d__.SpotLight3D|__animatablebody3d__.AnimatableBody3D|__sliderjoint3d__.SliderJoint3D|__conetwistjoint3d__.ConeTwistJoint3D|__csgbox3d__.CSGBox3D|__retargetmodifier3d__.RetargetModifier3D|__rigidbody3d__.RigidBody3D|__csgmesh3d__.CSGMesh3D|__springbonecollisionsphere3d__.SpringBoneCollisionSphere3D|__softbody3d__.SoftBody3D|__collisionshape3d__.CollisionShape3D|__collisionobject3d__.CollisionObject3D|__openxrcompositionlayer__.OpenXRCompositionLayer|__gpuparticles3d__.GPUParticles3D|__csgprimitive3d__.CSGPrimitive3D|__gridmap__.GridMap|__csgcylinder3d__.CSGCylinder3D|__camera3d__.Camera3D|__occluderinstance3d__.OccluderInstance3D|__importermeshinstance3d__.ImporterMeshInstance3D|__generic6dofjoint3d__.Generic6DOFJoint3D|__springbonesimulator3d__.SpringBoneSimulator3D|__openxrcompositionlayerquad__.OpenXRCompositionLayerQuad|__decal__.Decal|__lightmapprobe__.LightmapProbe|__fogvolume__.FogVolume|__spritebase3d__.SpriteBase3D|__visualinstance3d__.VisualInstance3D|__audiostreamplayer3d__.AudioStreamPlayer3D|__physicalbone3d__.PhysicalBone3D|__shapecast3d__.ShapeCast3D|__csgsphere3d__.CSGSphere3D|__gpuparticlescollisionsdf3d__.GPUParticlesCollisionSDF3D|__gpuparticlescollisionsphere3d__.GPUParticlesCollisionSphere3D|__visibleonscreennotifier3d__.VisibleOnScreenNotifier3D|__navigationregion3d__.NavigationRegion3D|__cpuparticles3d__.CPUParticles3D|__csgshape3d__.CSGShape3D|__node3d__.Node3D|__audiolistener3d__.AudioListener3D|__vehiclewheel3d__.VehicleWheel3D|__voxelgi__.VoxelGI|__geometryinstance3d__.GeometryInstance3D|__xrorigin3d__.XROrigin3D|__springarm3d__.SpringArm3D|__path3d__.Path3D|__marker3d__.Marker3D|__remotetransform3d__.RemoteTransform3D|__pinjoint3d__.PinJoint3D|__collisionpolygon3d__.CollisionPolygon3D|__xranchor3d__.XRAnchor3D|__skeletonik3d__.SkeletonIK3D|__springbonecollision3d__.SpringBoneCollision3D|__xrcontroller3d__.XRController3D|__openxrvisibilitymask__.OpenXRVisibilityMask|__reflectionprobe__.ReflectionProbe|__openxrcompositionlayercylinder__.OpenXRCompositionLayerCylinder|__skeletonmodifier3d__.SkeletonModifier3D|__vehiclebody3d__.VehicleBody3D|__springbonecollisionplane3d__.SpringBoneCollisionPlane3D|__multimeshinstance3d__.MultiMeshInstance3D|__csgpolygon3d__.CSGPolygon3D|__raycast3d__.RayCast3D|__physicsbody3d__.PhysicsBody3D|__xrnode3d__.XRNode3D|__xrhandmodifier3d__.XRHandModifier3D|__gpuparticlesattractorvectorfield3d__.GPUParticlesAttractorVectorField3D|__area3d__.Area3D|__animatedsprite3d__.AnimatedSprite3D|__xrbodymodifier3d__.XRBodyModifier3D|__label3d__.Label3D|__hingejoint3d__.HingeJoint3D|__gpuparticlescollisionheightfield3d__.GPUParticlesCollisionHeightField3D|__omnilight3d__.OmniLight3D|__visibleonscreenenabler3d__.VisibleOnScreenEnabler3D|__lightmapgi__.LightmapGI:
    """
				Returns the parent `Node3D` that directly affects this node's `global_transform`. Returns `null` if no parent exists, the parent is not a `Node3D`, or `top_level` is `true`.
				**Note:** This method is not always equivalent to `Node.get_parent`, which does not take `top_level` into account.
			"""
    pass

  def set_ignore_transform_notification(self, enabled:bool)->None:
    """
				If `true`, the node will not receive `constant NOTIFICATION_TRANSFORM_CHANGED` or `constant NOTIFICATION_LOCAL_TRANSFORM_CHANGED`.
				It may useful to call this method when handling these notifications to prevent infinite recursion.
			"""
    pass

  def set_as_top_level(self, enable:bool)->None:
    """"""
    pass

  def is_set_as_top_level(self)->bool:
    """"""
    pass

  def set_disable_scale(self, disable:bool)->None:
    """
				If `true`, this node's `global_transform` is automatically orthonormalized. This results in this node not appearing distorted, as if its global scale were set to `constant Vector3.ONE` (or its negative counterpart). See also `is_scale_disabled` and `orthonormalize`.
				**Note:** `transform` is not affected by this setting.
			"""
    pass

  def is_scale_disabled(self)->bool:
    """
				Returns `true` if this node's `global_transform` is automatically orthonormalized. This results in this node not appearing distorted, as if its global scale were set to `constant Vector3.ONE` (or its negative counterpart). See also `set_disable_scale` and `orthonormalize`.
				**Note:** `transform` is not affected by this setting.
			"""
    pass

  def get_world_3d(self)->__world3d__.World3D:
    """
				Returns the `World3D` this node is registered to.
				Usually, this is the same as the world used by this node's viewport (see `Node.get_viewport` and `Viewport.find_world_3d`).
			"""
    pass

  def force_update_transform(self)->None:
    """
				Forces the node's `global_transform` to update, by sending `constant NOTIFICATION_TRANSFORM_CHANGED`. Fails if the node is not inside the tree.
				**Note:** For performance reasons, transform changes are usually accumulated and applied _once_ at the end of the frame. The update propagates through `Node3D` children, as well. Therefore, use this method only when you need an up-to-date transform (such as during physics operations).
			"""
    pass

  def set_visibility_parent(self, path:__core__.NodePath|str)->None:
    """"""
    pass

  def get_visibility_parent(self)->__core__.NodePath:
    """"""
    pass

  def update_gizmos(self)->None:
    """
				Updates all the `EditorNode3DGizmo` objects attached to this node. Only works in the editor.
			"""
    pass

  def add_gizmo(self, gizmo:__node3dgizmo__.Node3DGizmo)->None:
    """
				Attaches the given `gizmo` to this node. Only works in the editor.
				**Note:** `gizmo` should be an `EditorNode3DGizmo`. The argument type is `Node3DGizmo` to avoid depending on editor classes in `Node3D`.
			"""
    pass

  def get_gizmos(self)->typedarray::Node3DGizmo:
    """
				Returns all the `EditorNode3DGizmo` objects attached to this node. Only works in the editor.
			"""
    pass

  def clear_gizmos(self)->None:
    """
				Clears all `EditorNode3DGizmo` objects attached to this node. Only works in the editor.
			"""
    pass

  def set_subgizmo_selection(self, gizmo:__node3dgizmo__.Node3DGizmo, id:int, transform:__core__.Transform3D)->None:
    """
				Selects the `gizmo`'s subgizmo with the given `id` and sets its transform. Only works in the editor.
				**Note:** The gizmo object would typically be an instance of `EditorNode3DGizmo`, but the argument type is kept generic to avoid creating a dependency on editor classes in `Node3D`.
			"""
    pass

  def clear_subgizmo_selection(self)->None:
    """
				Deselects all subgizmos for this node. Useful to call when the selected subgizmo may no longer exist after a property change. Only works in the editor.
			"""
    pass

  def set_visible(self, visible:bool)->None:
    """"""
    pass

  def is_visible(self)->bool:
    """"""
    pass

  def is_visible_in_tree(self)->bool:
    """
				Returns `true` if this node is inside the scene tree and the `visible` property is `true` for this node and all of its `Node3D` ancestors _in sequence_. An ancestor of any other type (such as `Node` or `Node2D`) breaks the sequence. See also `Node.get_parent`.
				**Note:** This method cannot take `VisualInstance3D.layers` into account, so even if this method returns `true`, the node may not be rendered.
			"""
    pass

  def show(self)->None:
    """
				Allows this node to be rendered. Equivalent to setting `visible` to `true`. This is the opposite of `hide`.
			"""
    pass

  def hide(self)->None:
    """
				Prevents this node from being rendered. Equivalent to setting `visible` to `false`. This is the opposite of `show`.
			"""
    pass

  def set_notify_local_transform(self, enable:bool)->None:
    """
				If `true`, the node will receive `constant NOTIFICATION_LOCAL_TRANSFORM_CHANGED` whenever `transform` changes.
				**Note:** Some 3D nodes such as `CSGShape3D` or `CollisionShape3D` automatically enable this to function correctly.
			"""
    pass

  def is_local_transform_notification_enabled(self)->bool:
    """
				Returns `true` if the node receives `constant NOTIFICATION_LOCAL_TRANSFORM_CHANGED` whenever `transform` changes. This is enabled with `set_notify_local_transform`.
			"""
    pass

  def set_notify_transform(self, enable:bool)->None:
    """
				If `true`, the node will receive `constant NOTIFICATION_TRANSFORM_CHANGED` whenever `global_transform` changes.
				**Note:** Most 3D nodes such as `VisualInstance3D` or `CollisionObject3D` automatically enable this to function correctly.
				**Note:** In the editor, nodes will propagate this notification to their children if a gizmo is attached (see `add_gizmo`).
			"""
    pass

  def is_transform_notification_enabled(self)->bool:
    """
				Returns `true` if the node receives `constant NOTIFICATION_TRANSFORM_CHANGED` whenever `global_transform` changes. This is enabled with `set_notify_transform`.
			"""
    pass

  def rotate(self, axis:__core__.Vector3, angle:float)->None:
    """
				Rotates this node's `basis` around the `axis` by the given `angle`, in radians. This operation is calculated in parent space (relative to the parent) and preserves the `position`.
			"""
    pass

  def global_rotate(self, axis:__core__.Vector3, angle:float)->None:
    """
				Rotates this node's `global_basis` around the global `axis` by the given `angle`, in radians. This operation is calculated in global space (relative to the world) and preserves the `global_position`.
			"""
    pass

  def global_scale(self, scale:__core__.Vector3)->None:
    """
				Scales this node's `global_basis` by the given `scale` factor. This operation is calculated in global space (relative to the world) and preserves the `global_position`.
				**Note:** This method is not to be confused with the `scale` property.
			"""
    pass

  def global_translate(self, offset:__core__.Vector3)->None:
    """
				Adds the given translation `offset` to the node's `global_position` in global space (relative to the world).
			"""
    pass

  def rotate_object_local(self, axis:__core__.Vector3, angle:float)->None:
    """
				Rotates this node's `basis` around the `axis` by the given `angle`, in radians. This operation is calculated in local space (relative to this node) and preserves the `position`.
			"""
    pass

  def scale_object_local(self, scale:__core__.Vector3)->None:
    """
				Scales this node's `basis` by the given `scale` factor. This operation is calculated in local space (relative to this node) and preserves the `position`.
			"""
    pass

  def translate_object_local(self, offset:__core__.Vector3)->None:
    """
				Adds the given translation `offset` to the node's position, in local space (relative to this node).
			"""
    pass

  def rotate_x(self, angle:float)->None:
    """
				Rotates this node's `basis` around the X axis by the given `angle`, in radians. This operation is calculated in parent space (relative to the parent) and preserves the `position`.
			"""
    pass

  def rotate_y(self, angle:float)->None:
    """
				Rotates this node's `basis` around the Y axis by the given `angle`, in radians. This operation is calculated in parent space (relative to the parent) and preserves the `position`.
			"""
    pass

  def rotate_z(self, angle:float)->None:
    """
				Rotates this node's `basis` around the Z axis by the given `angle`, in radians. This operation is calculated in parent space (relative to the parent) and preserves the `position`.
			"""
    pass

  def translate(self, offset:__core__.Vector3)->None:
    """
				Adds the given translation `offset` to the node's position, in local space (relative to this node).
				**Note:** Prefer using `translate_object_local`, instead, as this method may be changed in a future release.
				**Note:** Despite the naming convention, this operation is **not** calculated in parent space for compatibility reasons. To translate in parent space, add `offset` to the `position` (`node_3d.position += offset`).
			"""
    pass

  def orthonormalize(self)->None:
    """
				Orthonormalizes this node's `basis`. This method sets this node's `scale` to `constant Vector3.ONE` (or its negative counterpart), but preserves the `position` and `rotation`. See also `Transform3D.orthonormalized`.
			"""
    pass

  def set_identity(self)->None:
    """
				Sets this node's `transform` to `constant Transform3D.IDENTITY`, which resets all transformations in parent space (`position`, `rotation`, and `scale`).
			"""
    pass

  def look_at(self, target:__core__.Vector3, up:__core__.Vector3= __core__.Vector3.new0(), use_model_front:bool=False)->None:
    """
				Rotates the node so that the local forward axis (-Z, `constant Vector3.FORWARD`) points toward the `target` position. This operation is calculated in global space (relative to the world).
				The local up axis (+Y) points as close to the `up` vector as possible while staying perpendicular to the local forward axis. The resulting transform is orthogonal, and the scale is preserved. Non-uniform scaling may not work correctly.
				The `target` position cannot be the same as the node's position, the `up` vector cannot be `constant Vector3.ZERO`. Furthermore, the direction from the node's position to the `target` position cannot be parallel to the `up` vector, to avoid an unintended rotation around the local Z axis.
				If `use_model_front` is `true`, the +Z axis (asset front) is treated as forward (implies +X is left) and points toward the `target` position. By default, the -Z axis (camera forward) is treated as forward (implies +X is right).
				**Note:** This method fails if the node is not in the scene tree. If necessary, use `look_at_from_position` instead.
			"""
    pass

  def look_at_from_position(self, position:__core__.Vector3, target:__core__.Vector3, up:__core__.Vector3= __core__.Vector3.new0(), use_model_front:bool=False)->None:
    """
				Moves the node to the specified `position`, then rotates the node to point toward the `target` position, similar to `look_at`. This operation is calculated in global space (relative to the world).
			"""
    pass

  def to_local(self, global_point:__core__.Vector3)->__core__.Vector3:
    """
				Returns the `global_point` converted from global space to this node's local space. This is the opposite of `to_global`.
			"""
    pass

  def to_global(self, local_point:__core__.Vector3)->__core__.Vector3:
    """
				Returns the `local_point` converted from this node's local space to global space. This is the opposite of `to_local`.
			"""
    pass


