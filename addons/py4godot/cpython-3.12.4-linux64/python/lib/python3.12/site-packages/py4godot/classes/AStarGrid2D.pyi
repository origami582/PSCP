from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.D as __d__
import py4godot.classes.c as __c__
import py4godot.classes.r as __r__
import py4godot.classes.RefCounted as __refcounted__
import py4godot.classes.i as __i__
import py4godot.classes.t as __t__
import py4godot.classes.a as __a__
import py4godot.classes.V as __v__
import py4godot.classes.p as __p__
import py4godot.classes.AStarGrid2D as __astargrid2d__
import py4godot.classes.o as __o__
import py4godot.classes.n as __n__
import py4godot.classes.y as __y__
import py4godot.classes.A as __a__
import py4godot.classes.d as __d__
import py4godot.classes.e as __e__
import py4godot.classes.2 as __2__
import py4godot.classes.T as __t__


class Heuristic:
  HEURISTIC_EUCLIDEAN:int = 0
  HEURISTIC_MANHATTAN:int = 1
  HEURISTIC_OCTILE:int = 2
  HEURISTIC_CHEBYSHEV:int = 3
  HEURISTIC_MAX:int = 4
class DiagonalMode:
  DIAGONAL_MODE_ALWAYS:int = 0
  DIAGONAL_MODE_NEVER:int = 1
  DIAGONAL_MODE_AT_LEAST_ONE_WALKABLE:int = 2
  DIAGONAL_MODE_ONLY_IF_NO_OBSTACLES:int = 3
  DIAGONAL_MODE_MAX:int = 4
class CellShape:
  CELL_SHAPE_SQUARE:int = 0
  CELL_SHAPE_ISOMETRIC_RIGHT:int = 1
  CELL_SHAPE_ISOMETRIC_DOWN:int = 2
  CELL_SHAPE_MAX:int = 3


class AStarGrid2D(__refcounted__.RefCounted):
  """
		`AStarGrid2D` is a variant of `AStar2D` that is specialized for partial 2D grids. It is simpler to use because it doesn't require you to manually create points and connect them together. This class also supports multiple types of heuristics, modes for diagonal movement, and a jumping mode to speed up calculations.
		To use `AStarGrid2D`, you only need to set the `region` of the grid, optionally set the `cell_size`, and then call the `update` method:
		
		```gdscript
		var astar_grid = AStarGrid2D.new()
		astar_grid.region = Rect2i(0, 0, 32, 32)
		astar_grid.cell_size = Vector2(16, 16)
		astar_grid.update()
		print(astar_grid.get_id_path(Vector2i(0, 0), Vector2i(3, 4))) # Prints `(0, 0), (1, 1), (2, 2), (3, 3), (3, 4)`
		print(astar_grid.get_point_path(Vector2i(0, 0), Vector2i(3, 4))) # Prints `(0, 0), (16, 16), (32, 32), (48, 48), (48, 64)`
		```
		
		
		To remove a point from the pathfinding grid, it must be set as "solid" with `set_point_solid`.
	"""

  @staticmethod
  def constructor()->AStarGrid2D:pass



  @staticmethod
  def cast(other:__object__.Object)->AStarGrid2D:pass


  @property
  def region(self)->__core__.Rect2i:
    """"""
    pass
  @region.setter
  def region(self,  value:__core__.Rect2i)->None:
    """"""
    pass
  @property
  def size(self)->__core__.Vector2i:
    """"""
    pass
  @size.setter
  def size(self,  value:__core__.Vector2i)->None:
    """"""
    pass
  @property
  def offset(self)->__core__.Vector2:
    """"""
    pass
  @offset.setter
  def offset(self,  value:__core__.Vector2)->None:
    """"""
    pass
  @property
  def cell_size(self)->__core__.Vector2:
    """"""
    pass
  @cell_size.setter
  def cell_size(self,  value:__core__.Vector2)->None:
    """"""
    pass
  @property
  def cell_shape(self)->int:
    """"""
    pass
  @cell_shape.setter
  def cell_shape(self,  value:int)->None:
    """"""
    pass
  @property
  def jumping_enabled(self)->bool:
    """"""
    pass
  @jumping_enabled.setter
  def jumping_enabled(self,  value:bool)->None:
    """"""
    pass
  @property
  def default_compute_heuristic(self)->int:
    """"""
    pass
  @default_compute_heuristic.setter
  def default_compute_heuristic(self,  value:int)->None:
    """"""
    pass
  @property
  def default_estimate_heuristic(self)->int:
    """"""
    pass
  @default_estimate_heuristic.setter
  def default_estimate_heuristic(self,  value:int)->None:
    """"""
    pass
  @property
  def diagonal_mode(self)->int:
    """"""
    pass
  @diagonal_mode.setter
  def diagonal_mode(self,  value:int)->None:
    """"""
    pass
  def _estimate_cost(self, from_id:__core__.Vector2i, end_id:__core__.Vector2i)->float:
    """
				Called when estimating the cost between a point and the path's ending point.
				Note that this function is hidden in the default `AStarGrid2D` class.
			"""
    pass

  def _compute_cost(self, from_id:__core__.Vector2i, to_id:__core__.Vector2i)->float:
    """
				Called when computing the cost between two connected points.
				Note that this function is hidden in the default `AStarGrid2D` class.
			"""
    pass

  def set_region(self, region:__core__.Rect2i)->None:
    """"""
    pass

  def get_region(self)->__core__.Rect2i:
    """"""
    pass

  def set_size(self, size:__core__.Vector2i)->None:
    """"""
    pass

  def get_size(self)->__core__.Vector2i:
    """"""
    pass

  def set_offset(self, offset:__core__.Vector2)->None:
    """"""
    pass

  def get_offset(self)->__core__.Vector2:
    """"""
    pass

  def set_cell_size(self, cell_size:__core__.Vector2)->None:
    """"""
    pass

  def get_cell_size(self)->__core__.Vector2:
    """"""
    pass

  def set_cell_shape(self, cell_shape:int )->None:
    """"""
    pass

  def get_cell_shape(self)->int:
    """"""
    pass

  def is_in_bounds(self, x:int, y:int)->bool:
    """
				Returns `true` if the `x` and `y` is a valid grid coordinate (id), i.e. if it is inside `region`. Equivalent to `region.has_point(Vector2i(x, y))`.
			"""
    pass

  def is_in_boundsv(self, id:__core__.Vector2i)->bool:
    """
				Returns `true` if the `id` vector is a valid grid coordinate, i.e. if it is inside `region`. Equivalent to `region.has_point(id)`.
			"""
    pass

  def is_dirty(self)->bool:
    """
				Indicates that the grid parameters were changed and `update` needs to be called.
			"""
    pass

  def update(self)->None:
    """
				Updates the internal state of the grid according to the parameters to prepare it to search the path. Needs to be called if parameters like `region`, `cell_size` or `offset` are changed. `is_dirty` will return `true` if this is the case and this needs to be called.
				**Note:** All point data (solidity and weight scale) will be cleared.
			"""
    pass

  def set_jumping_enabled(self, enabled:bool)->None:
    """"""
    pass

  def is_jumping_enabled(self)->bool:
    """"""
    pass

  def set_diagonal_mode(self, mode:int )->None:
    """"""
    pass

  def get_diagonal_mode(self)->int:
    """"""
    pass

  def set_default_compute_heuristic(self, heuristic:int )->None:
    """"""
    pass

  def get_default_compute_heuristic(self)->int:
    """"""
    pass

  def set_default_estimate_heuristic(self, heuristic:int )->None:
    """"""
    pass

  def get_default_estimate_heuristic(self)->int:
    """"""
    pass

  def set_point_solid(self, id:__core__.Vector2i, solid:bool=True)->None:
    """
				Disables or enables the specified point for pathfinding. Useful for making an obstacle. By default, all points are enabled.
				**Note:** Calling `update` is not needed after the call of this function.
			"""
    pass

  def is_point_solid(self, id:__core__.Vector2i)->bool:
    """
				Returns `true` if a point is disabled for pathfinding. By default, all points are enabled.
			"""
    pass

  def set_point_weight_scale(self, id:__core__.Vector2i, weight_scale:float)->None:
    """
				Sets the `weight_scale` for the point with the given `id`. The `weight_scale` is multiplied by the result of `_compute_cost` when determining the overall cost of traveling across a segment from a neighboring point to this point.
				**Note:** Calling `update` is not needed after the call of this function.
			"""
    pass

  def get_point_weight_scale(self, id:__core__.Vector2i)->float:
    """
				Returns the weight scale of the point associated with the given `id`.
			"""
    pass

  def fill_solid_region(self, region:__core__.Rect2i, solid:bool=True)->None:
    """
				Fills the given `region` on the grid with the specified value for the solid flag.
				**Note:** Calling `update` is not needed after the call of this function.
			"""
    pass

  def fill_weight_scale_region(self, region:__core__.Rect2i, weight_scale:float)->None:
    """
				Fills the given `region` on the grid with the specified value for the weight scale.
				**Note:** Calling `update` is not needed after the call of this function.
			"""
    pass

  def clear(self)->None:
    """
				Clears the grid and sets the `region` to `Rect2i(0, 0, 0, 0)`.
			"""
    pass

  def get_point_position(self, id:__core__.Vector2i)->__core__.Vector2:
    """
				Returns the position of the point associated with the given `id`.
			"""
    pass

  def get_point_data_in_region(self, region:__core__.Rect2i)->typedarray::Dictionary:
    """
				Returns an array of dictionaries with point data (`id`: `Vector2i`, `position`: `Vector2`, `solid`: `bool`, `weight_scale`: `float`) within a `region`.
			"""
    pass

  def get_point_path(self, from_id:__core__.Vector2i, to_id:__core__.Vector2i, allow_partial_path:bool=False)->__core__.PackedVector2Array:
    """
				Returns an array with the points that are in the path found by `AStarGrid2D` between the given points. The array is ordered from the starting point to the ending point of the path.
				If there is no valid path to the target, and `allow_partial_path` is `true`, returns a path to the point closest to the target that can be reached.
				**Note:** This method is not thread-safe. If called from a `Thread`, it will return an empty array and will print an error message.
				Additionally, when `allow_partial_path` is `true` and `to_id` is solid the search may take an unusually long time to finish.
			"""
    pass

  def get_id_path(self, from_id:__core__.Vector2i, to_id:__core__.Vector2i, allow_partial_path:bool=False)->typedarray::Vector2i:
    """
				Returns an array with the IDs of the points that form the path found by AStar2D between the given points. The array is ordered from the starting point to the ending point of the path.
				If there is no valid path to the target, and `allow_partial_path` is `true`, returns a path to the point closest to the target that can be reached.
				**Note:** When `allow_partial_path` is `true` and `to_id` is solid the search may take an unusually long time to finish.
			"""
    pass


