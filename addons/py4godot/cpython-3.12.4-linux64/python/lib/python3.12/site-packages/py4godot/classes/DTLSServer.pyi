from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.PacketPeerUDP as __packetpeerudp__
import py4godot.classes.PacketPeerDTLS as __packetpeerdtls__
import py4godot.classes.TLSOptions as __tlsoptions__
import py4godot.classes.RefCounted as __refcounted__



class DTLSServer(__refcounted__.RefCounted):
  """
		This class is used to store the state of a DTLS server. Upon `setup` it converts connected `PacketPeerUDP` to `PacketPeerDTLS` accepting them via `take_connection` as DTLS clients. Under the hood, this class is used to store the DTLS state and cookies of the server. The reason of why the state and cookies are needed is outside of the scope of this documentation.
		Below a small example of how to use it:
		
		```gdscript
		# server_node.gd
		extends Node

		var dtls = DTLSServer.new()
		var server = UDPServer.new()
		var peers = ``

		func _ready():
			server.listen(4242)
			var key = load("key.key") # Your private key.
			var cert = load("cert.crt") # Your X509 certificate.
			dtls.setup(TlsOptions.server(key, cert))

		func _process(delta):
			while server.is_connection_available():
				var peer = server.take_connection()
				var dtls_peer = dtls.take_connection(peer)
				if dtls_peer.get_status() != PacketPeerDTLS.STATUS_HANDSHAKING:
					continue # It is normal that 50% of the connections fails due to cookie exchange.
				print("Peer connected!")
				peers.append(dtls_peer)

			for p in peers:
				p.poll() # Must poll to update the state.
				if p.get_status() == PacketPeerDTLS.STATUS_CONNECTED:
					while p.get_available_packet_count() > 0:
						print("Received message from client: %s" % p.get_packet().get_string_from_utf8())
						p.put_packet("Hello DTLS client".to_utf8_buffer())
		```
		
		
		
		```gdscript
		# client_node.gd
		extends Node

		var dtls = PacketPeerDTLS.new()
		var udp = PacketPeerUDP.new()
		var connected = false

		func _ready():
			udp.connect_to_host("127.0.0.1", 4242)
			dtls.connect_to_peer(udp, false) # Use true in production for certificate validation!

		func _process(delta):
			dtls.poll()
			if dtls.get_status() == PacketPeerDTLS.STATUS_CONNECTED:
				if !connected:
					# Try to contact server
					dtls.put_packet("The answer is... 42!".to_utf8_buffer())
				while dtls.get_available_packet_count() > 0:
					print("Connected: %s" % dtls.get_packet().get_string_from_utf8())
					connected = true
		```
		
		
	"""

  @staticmethod
  def constructor()->DTLSServer:pass



  @staticmethod
  def cast(other:__object__.Object)->DTLSServer:pass


  def setup(self, server_options:__tlsoptions__.TLSOptions)->int:
    """
				Setup the DTLS server to use the given `server_options`. See `TLSOptions.server`.
			"""
    pass

  def take_connection(self, udp_peer:__packetpeerudp__.PacketPeerUDP)->__packetpeerdtls__.PacketPeerDTLS:
    """
				Try to initiate the DTLS handshake with the given `udp_peer` which must be already connected (see `PacketPeerUDP.connect_to_host`).
				**Note:** You must check that the state of the return PacketPeerUDP is `constant PacketPeerDTLS.STATUS_HANDSHAKING`, as it is normal that 50% of the new connections will be invalid due to cookie exchange.
			"""
    pass


