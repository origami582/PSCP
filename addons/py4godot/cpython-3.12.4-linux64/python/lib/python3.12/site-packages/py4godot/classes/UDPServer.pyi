from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.PacketPeerUDP as __packetpeerudp__
import py4godot.classes.RefCounted as __refcounted__



class UDPServer(__refcounted__.RefCounted):
  """
		A simple server that opens a UDP socket and returns connected `PacketPeerUDP` upon receiving new packets. See also `PacketPeerUDP.connect_to_host`.
		After starting the server (`listen`), you will need to `poll` it at regular intervals (e.g. inside `Node._process`) for it to process new packets, delivering them to the appropriate `PacketPeerUDP`, and taking new connections.
		Below a small example of how it can be used:
		
		```gdscript
		# server_node.gd
		class_name ServerNode
		extends Node

		var server = UDPServer.new()
		var peers = ``

		func _ready():
			server.listen(4242)

		func _process(delta):
			server.poll() # Important!
			if server.is_connection_available():
				var peer = server.take_connection()
				var packet = peer.get_packet()
				print("Accepted peer: %s:%s" % `peer.get_packet_ip(), peer.get_packet_port()`)
				print("Received data: %s" % `packet.get_string_from_utf8()`)
				# Reply so it knows we received the message.
				peer.put_packet(packet)
				# Keep a reference so we can keep contacting the remote peer.
				peers.append(peer)

			for i in range(0, peers.size()):
				pass # Do something with the connected peers.
		```
		
		
		
		```gdscript
		# client_node.gd
		class_name ClientNode
		extends Node

		var udp = PacketPeerUDP.new()
		var connected = false

		func _ready():
			udp.connect_to_host("127.0.0.1", 4242)

		func _process(delta):
			if !connected:
				# Try to contact server
				udp.put_packet("The answer is... 42!".to_utf8_buffer())
			if udp.get_available_packet_count() > 0:
				print("Connected: %s" % udp.get_packet().get_string_from_utf8())
				connected = true
		```
		
		
	"""

  @staticmethod
  def constructor()->UDPServer:pass



  @staticmethod
  def cast(other:__object__.Object)->UDPServer:pass


  @property
  def max_pending_connections(self)->int:
    """"""
    pass
  @max_pending_connections.setter
  def max_pending_connections(self,  value:int)->None:
    """"""
    pass
  def listen(self, port:int, bind_address:str= __core__.String.new0())->int:
    """
				Starts the server by opening a UDP socket listening on the given `port`. You can optionally specify a `bind_address` to only listen for packets sent to that address. See also `PacketPeerUDP.bind`.
			"""
    pass

  def poll(self)->int:
    """
				Call this method at regular intervals (e.g. inside `Node._process`) to process new packets. Any packet from a known address/port pair will be delivered to the appropriate `PacketPeerUDP`, while any packet received from an unknown address/port pair will be added as a pending connection (see `is_connection_available` and `take_connection`). The maximum number of pending connections is defined via `max_pending_connections`.
			"""
    pass

  def is_connection_available(self)->bool:
    """
				Returns `true` if a packet with a new address/port combination was received on the socket.
			"""
    pass

  def get_local_port(self)->int:
    """
				Returns the local port this server is listening to.
			"""
    pass

  def is_listening(self)->bool:
    """
				Returns `true` if the socket is open and listening on a port.
			"""
    pass

  def take_connection(self)->__packetpeerudp__.PacketPeerUDP:
    """
				Returns the first pending connection (connected to the appropriate address/port). Will return `null` if no new connection is available. See also `is_connection_available`, `PacketPeerUDP.connect_to_host`.
			"""
    pass

  def stop(self)->None:
    """
				Stops the server, closing the UDP socket if open. Will close all connected `PacketPeerUDP` accepted via `take_connection` (remote peers will not be notified).
			"""
    pass

  def set_max_pending_connections(self, max_pending_connections:int)->None:
    """"""
    pass

  def get_max_pending_connections(self)->int:
    """"""
    pass


