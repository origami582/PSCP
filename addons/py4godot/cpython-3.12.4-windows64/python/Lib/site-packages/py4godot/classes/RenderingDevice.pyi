from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.C as __c__
import py4godot.classes.RDTextureView as __rdtextureview__
import py4godot.classes.n as __n__
import py4godot.classes.T as __t__
import py4godot.classes.V as __v__
import py4godot.classes.D as __d__
import py4godot.classes.k as __k__
import py4godot.classes.u as __u__
import py4godot.classes.RDPipelineMultisampleState as __rdpipelinemultisamplestate__
import py4godot.classes.RDShaderSource as __rdshadersource__
import py4godot.classes.RDPipelineRasterizationState as __rdpipelinerasterizationstate__
import py4godot.classes.i as __i__
import py4godot.classes.e as __e__
import py4godot.classes.m as __m__
import py4godot.classes.o as __o__
import py4godot.classes.l as __l__
import py4godot.classes.p as __p__
import py4godot.classes.R as __r__
import py4godot.classes.F as __f__
import py4godot.classes.RenderingDevice as __renderingdevice__
import py4godot.classes.RDSamplerState as __rdsamplerstate__
import py4godot.classes.b as __b__
import py4godot.classes.d as __d__
import py4godot.classes.c as __c__
import py4godot.classes.RDShaderSPIRV as __rdshaderspirv__
import py4godot.classes.r as __r__
import py4godot.classes.RDPipelineColorBlendState as __rdpipelinecolorblendstate__
import py4godot.classes.a as __a__
import py4godot.classes.z as __z__
import py4godot.classes.A as __a__
import py4godot.classes.P as __p__
import py4godot.classes.f as __f__
import py4godot.classes.h as __h__
import py4godot.classes.y as __y__
import py4godot.classes.RDPipelineDepthStencilState as __rdpipelinedepthstencilstate__
import py4godot.classes.Object as __object__
import py4godot.classes.RDTextureFormat as __rdtextureformat__
import py4godot.classes.s as __s__
import py4godot.classes.x as __x__
import py4godot.classes.U as __u__
import py4godot.classes.I as __i__
import py4godot.classes.t as __t__
import py4godot.classes.S as __s__
import py4godot.classes.B as __b__


class DeviceType:
  DEVICE_KIND_OTHER:int = 0
  DEVICE_KIND_INTEGRATED_GPU:int = 1
  DEVICE_KIND_DISCRETE_GPU:int = 2
  DEVICE_KIND_VIRTUAL_GPU:int = 3
  DEVICE_KIND_CPU:int = 4
  DEVICE_KIND_MAX:int = 5
class DriverResource:
  DRIVER_RESOURCE_LOGICAL_DEVICE:int = 0
  DRIVER_RESOURCE_PHYSICAL_DEVICE:int = 1
  DRIVER_RESOURCE_TOPMOST_OBJECT:int = 2
  DRIVER_RESOURCE_COMMAND_QUEUE:int = 3
  DRIVER_RESOURCE_QUEUE_FAMILY:int = 4
  DRIVER_RESOURCE_TEXTURE:int = 5
  DRIVER_RESOURCE_TEXTURE_VIEW:int = 6
  DRIVER_RESOURCE_TEXTURE_DATA_FORMAT:int = 7
  DRIVER_RESOURCE_SAMPLER:int = 8
  DRIVER_RESOURCE_UNIFORM_SET:int = 9
  DRIVER_RESOURCE_BUFFER:int = 10
  DRIVER_RESOURCE_COMPUTE_PIPELINE:int = 11
  DRIVER_RESOURCE_RENDER_PIPELINE:int = 12
  DRIVER_RESOURCE_VULKAN_DEVICE:int = 0
  DRIVER_RESOURCE_VULKAN_PHYSICAL_DEVICE:int = 1
  DRIVER_RESOURCE_VULKAN_INSTANCE:int = 2
  DRIVER_RESOURCE_VULKAN_QUEUE:int = 3
  DRIVER_RESOURCE_VULKAN_QUEUE_FAMILY_INDEX:int = 4
  DRIVER_RESOURCE_VULKAN_IMAGE:int = 5
  DRIVER_RESOURCE_VULKAN_IMAGE_VIEW:int = 6
  DRIVER_RESOURCE_VULKAN_IMAGE_NATIVE_TEXTURE_FORMAT:int = 7
  DRIVER_RESOURCE_VULKAN_SAMPLER:int = 8
  DRIVER_RESOURCE_VULKAN_DESCRIPTOR_SET:int = 9
  DRIVER_RESOURCE_VULKAN_BUFFER:int = 10
  DRIVER_RESOURCE_VULKAN_COMPUTE_PIPELINE:int = 11
  DRIVER_RESOURCE_VULKAN_RENDER_PIPELINE:int = 12
class DataFormat:
  DATA_FORMAT_R4G4_UNORM_PACK8:int = 0
  DATA_FORMAT_R4G4B4A4_UNORM_PACK16:int = 1
  DATA_FORMAT_B4G4R4A4_UNORM_PACK16:int = 2
  DATA_FORMAT_R5G6B5_UNORM_PACK16:int = 3
  DATA_FORMAT_B5G6R5_UNORM_PACK16:int = 4
  DATA_FORMAT_R5G5B5A1_UNORM_PACK16:int = 5
  DATA_FORMAT_B5G5R5A1_UNORM_PACK16:int = 6
  DATA_FORMAT_A1R5G5B5_UNORM_PACK16:int = 7
  DATA_FORMAT_R8_UNORM:int = 8
  DATA_FORMAT_R8_SNORM:int = 9
  DATA_FORMAT_R8_USCALED:int = 10
  DATA_FORMAT_R8_SSCALED:int = 11
  DATA_FORMAT_R8_UINT:int = 12
  DATA_FORMAT_R8_SINT:int = 13
  DATA_FORMAT_R8_SRGB:int = 14
  DATA_FORMAT_R8G8_UNORM:int = 15
  DATA_FORMAT_R8G8_SNORM:int = 16
  DATA_FORMAT_R8G8_USCALED:int = 17
  DATA_FORMAT_R8G8_SSCALED:int = 18
  DATA_FORMAT_R8G8_UINT:int = 19
  DATA_FORMAT_R8G8_SINT:int = 20
  DATA_FORMAT_R8G8_SRGB:int = 21
  DATA_FORMAT_R8G8B8_UNORM:int = 22
  DATA_FORMAT_R8G8B8_SNORM:int = 23
  DATA_FORMAT_R8G8B8_USCALED:int = 24
  DATA_FORMAT_R8G8B8_SSCALED:int = 25
  DATA_FORMAT_R8G8B8_UINT:int = 26
  DATA_FORMAT_R8G8B8_SINT:int = 27
  DATA_FORMAT_R8G8B8_SRGB:int = 28
  DATA_FORMAT_B8G8R8_UNORM:int = 29
  DATA_FORMAT_B8G8R8_SNORM:int = 30
  DATA_FORMAT_B8G8R8_USCALED:int = 31
  DATA_FORMAT_B8G8R8_SSCALED:int = 32
  DATA_FORMAT_B8G8R8_UINT:int = 33
  DATA_FORMAT_B8G8R8_SINT:int = 34
  DATA_FORMAT_B8G8R8_SRGB:int = 35
  DATA_FORMAT_R8G8B8A8_UNORM:int = 36
  DATA_FORMAT_R8G8B8A8_SNORM:int = 37
  DATA_FORMAT_R8G8B8A8_USCALED:int = 38
  DATA_FORMAT_R8G8B8A8_SSCALED:int = 39
  DATA_FORMAT_R8G8B8A8_UINT:int = 40
  DATA_FORMAT_R8G8B8A8_SINT:int = 41
  DATA_FORMAT_R8G8B8A8_SRGB:int = 42
  DATA_FORMAT_B8G8R8A8_UNORM:int = 43
  DATA_FORMAT_B8G8R8A8_SNORM:int = 44
  DATA_FORMAT_B8G8R8A8_USCALED:int = 45
  DATA_FORMAT_B8G8R8A8_SSCALED:int = 46
  DATA_FORMAT_B8G8R8A8_UINT:int = 47
  DATA_FORMAT_B8G8R8A8_SINT:int = 48
  DATA_FORMAT_B8G8R8A8_SRGB:int = 49
  DATA_FORMAT_A8B8G8R8_UNORM_PACK32:int = 50
  DATA_FORMAT_A8B8G8R8_SNORM_PACK32:int = 51
  DATA_FORMAT_A8B8G8R8_USCALED_PACK32:int = 52
  DATA_FORMAT_A8B8G8R8_SSCALED_PACK32:int = 53
  DATA_FORMAT_A8B8G8R8_UINT_PACK32:int = 54
  DATA_FORMAT_A8B8G8R8_SINT_PACK32:int = 55
  DATA_FORMAT_A8B8G8R8_SRGB_PACK32:int = 56
  DATA_FORMAT_A2R10G10B10_UNORM_PACK32:int = 57
  DATA_FORMAT_A2R10G10B10_SNORM_PACK32:int = 58
  DATA_FORMAT_A2R10G10B10_USCALED_PACK32:int = 59
  DATA_FORMAT_A2R10G10B10_SSCALED_PACK32:int = 60
  DATA_FORMAT_A2R10G10B10_UINT_PACK32:int = 61
  DATA_FORMAT_A2R10G10B10_SINT_PACK32:int = 62
  DATA_FORMAT_A2B10G10R10_UNORM_PACK32:int = 63
  DATA_FORMAT_A2B10G10R10_SNORM_PACK32:int = 64
  DATA_FORMAT_A2B10G10R10_USCALED_PACK32:int = 65
  DATA_FORMAT_A2B10G10R10_SSCALED_PACK32:int = 66
  DATA_FORMAT_A2B10G10R10_UINT_PACK32:int = 67
  DATA_FORMAT_A2B10G10R10_SINT_PACK32:int = 68
  DATA_FORMAT_R16_UNORM:int = 69
  DATA_FORMAT_R16_SNORM:int = 70
  DATA_FORMAT_R16_USCALED:int = 71
  DATA_FORMAT_R16_SSCALED:int = 72
  DATA_FORMAT_R16_UINT:int = 73
  DATA_FORMAT_R16_SINT:int = 74
  DATA_FORMAT_R16_SFLOAT:int = 75
  DATA_FORMAT_R16G16_UNORM:int = 76
  DATA_FORMAT_R16G16_SNORM:int = 77
  DATA_FORMAT_R16G16_USCALED:int = 78
  DATA_FORMAT_R16G16_SSCALED:int = 79
  DATA_FORMAT_R16G16_UINT:int = 80
  DATA_FORMAT_R16G16_SINT:int = 81
  DATA_FORMAT_R16G16_SFLOAT:int = 82
  DATA_FORMAT_R16G16B16_UNORM:int = 83
  DATA_FORMAT_R16G16B16_SNORM:int = 84
  DATA_FORMAT_R16G16B16_USCALED:int = 85
  DATA_FORMAT_R16G16B16_SSCALED:int = 86
  DATA_FORMAT_R16G16B16_UINT:int = 87
  DATA_FORMAT_R16G16B16_SINT:int = 88
  DATA_FORMAT_R16G16B16_SFLOAT:int = 89
  DATA_FORMAT_R16G16B16A16_UNORM:int = 90
  DATA_FORMAT_R16G16B16A16_SNORM:int = 91
  DATA_FORMAT_R16G16B16A16_USCALED:int = 92
  DATA_FORMAT_R16G16B16A16_SSCALED:int = 93
  DATA_FORMAT_R16G16B16A16_UINT:int = 94
  DATA_FORMAT_R16G16B16A16_SINT:int = 95
  DATA_FORMAT_R16G16B16A16_SFLOAT:int = 96
  DATA_FORMAT_R32_UINT:int = 97
  DATA_FORMAT_R32_SINT:int = 98
  DATA_FORMAT_R32_SFLOAT:int = 99
  DATA_FORMAT_R32G32_UINT:int = 100
  DATA_FORMAT_R32G32_SINT:int = 101
  DATA_FORMAT_R32G32_SFLOAT:int = 102
  DATA_FORMAT_R32G32B32_UINT:int = 103
  DATA_FORMAT_R32G32B32_SINT:int = 104
  DATA_FORMAT_R32G32B32_SFLOAT:int = 105
  DATA_FORMAT_R32G32B32A32_UINT:int = 106
  DATA_FORMAT_R32G32B32A32_SINT:int = 107
  DATA_FORMAT_R32G32B32A32_SFLOAT:int = 108
  DATA_FORMAT_R64_UINT:int = 109
  DATA_FORMAT_R64_SINT:int = 110
  DATA_FORMAT_R64_SFLOAT:int = 111
  DATA_FORMAT_R64G64_UINT:int = 112
  DATA_FORMAT_R64G64_SINT:int = 113
  DATA_FORMAT_R64G64_SFLOAT:int = 114
  DATA_FORMAT_R64G64B64_UINT:int = 115
  DATA_FORMAT_R64G64B64_SINT:int = 116
  DATA_FORMAT_R64G64B64_SFLOAT:int = 117
  DATA_FORMAT_R64G64B64A64_UINT:int = 118
  DATA_FORMAT_R64G64B64A64_SINT:int = 119
  DATA_FORMAT_R64G64B64A64_SFLOAT:int = 120
  DATA_FORMAT_B10G11R11_UFLOAT_PACK32:int = 121
  DATA_FORMAT_E5B9G9R9_UFLOAT_PACK32:int = 122
  DATA_FORMAT_D16_UNORM:int = 123
  DATA_FORMAT_X8_D24_UNORM_PACK32:int = 124
  DATA_FORMAT_D32_SFLOAT:int = 125
  DATA_FORMAT_S8_UINT:int = 126
  DATA_FORMAT_D16_UNORM_S8_UINT:int = 127
  DATA_FORMAT_D24_UNORM_S8_UINT:int = 128
  DATA_FORMAT_D32_SFLOAT_S8_UINT:int = 129
  DATA_FORMAT_BC1_RGB_UNORM_BLOCK:int = 130
  DATA_FORMAT_BC1_RGB_SRGB_BLOCK:int = 131
  DATA_FORMAT_BC1_RGBA_UNORM_BLOCK:int = 132
  DATA_FORMAT_BC1_RGBA_SRGB_BLOCK:int = 133
  DATA_FORMAT_BC2_UNORM_BLOCK:int = 134
  DATA_FORMAT_BC2_SRGB_BLOCK:int = 135
  DATA_FORMAT_BC3_UNORM_BLOCK:int = 136
  DATA_FORMAT_BC3_SRGB_BLOCK:int = 137
  DATA_FORMAT_BC4_UNORM_BLOCK:int = 138
  DATA_FORMAT_BC4_SNORM_BLOCK:int = 139
  DATA_FORMAT_BC5_UNORM_BLOCK:int = 140
  DATA_FORMAT_BC5_SNORM_BLOCK:int = 141
  DATA_FORMAT_BC6H_UFLOAT_BLOCK:int = 142
  DATA_FORMAT_BC6H_SFLOAT_BLOCK:int = 143
  DATA_FORMAT_BC7_UNORM_BLOCK:int = 144
  DATA_FORMAT_BC7_SRGB_BLOCK:int = 145
  DATA_FORMAT_ETC2_R8G8B8_UNORM_BLOCK:int = 146
  DATA_FORMAT_ETC2_R8G8B8_SRGB_BLOCK:int = 147
  DATA_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK:int = 148
  DATA_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK:int = 149
  DATA_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK:int = 150
  DATA_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK:int = 151
  DATA_FORMAT_EAC_R11_UNORM_BLOCK:int = 152
  DATA_FORMAT_EAC_R11_SNORM_BLOCK:int = 153
  DATA_FORMAT_EAC_R11G11_UNORM_BLOCK:int = 154
  DATA_FORMAT_EAC_R11G11_SNORM_BLOCK:int = 155
  DATA_FORMAT_ASTC_4x4_UNORM_BLOCK:int = 156
  DATA_FORMAT_ASTC_4x4_SRGB_BLOCK:int = 157
  DATA_FORMAT_ASTC_5x4_UNORM_BLOCK:int = 158
  DATA_FORMAT_ASTC_5x4_SRGB_BLOCK:int = 159
  DATA_FORMAT_ASTC_5x5_UNORM_BLOCK:int = 160
  DATA_FORMAT_ASTC_5x5_SRGB_BLOCK:int = 161
  DATA_FORMAT_ASTC_6x5_UNORM_BLOCK:int = 162
  DATA_FORMAT_ASTC_6x5_SRGB_BLOCK:int = 163
  DATA_FORMAT_ASTC_6x6_UNORM_BLOCK:int = 164
  DATA_FORMAT_ASTC_6x6_SRGB_BLOCK:int = 165
  DATA_FORMAT_ASTC_8x5_UNORM_BLOCK:int = 166
  DATA_FORMAT_ASTC_8x5_SRGB_BLOCK:int = 167
  DATA_FORMAT_ASTC_8x6_UNORM_BLOCK:int = 168
  DATA_FORMAT_ASTC_8x6_SRGB_BLOCK:int = 169
  DATA_FORMAT_ASTC_8x8_UNORM_BLOCK:int = 170
  DATA_FORMAT_ASTC_8x8_SRGB_BLOCK:int = 171
  DATA_FORMAT_ASTC_10x5_UNORM_BLOCK:int = 172
  DATA_FORMAT_ASTC_10x5_SRGB_BLOCK:int = 173
  DATA_FORMAT_ASTC_10x6_UNORM_BLOCK:int = 174
  DATA_FORMAT_ASTC_10x6_SRGB_BLOCK:int = 175
  DATA_FORMAT_ASTC_10x8_UNORM_BLOCK:int = 176
  DATA_FORMAT_ASTC_10x8_SRGB_BLOCK:int = 177
  DATA_FORMAT_ASTC_10x10_UNORM_BLOCK:int = 178
  DATA_FORMAT_ASTC_10x10_SRGB_BLOCK:int = 179
  DATA_FORMAT_ASTC_12x10_UNORM_BLOCK:int = 180
  DATA_FORMAT_ASTC_12x10_SRGB_BLOCK:int = 181
  DATA_FORMAT_ASTC_12x12_UNORM_BLOCK:int = 182
  DATA_FORMAT_ASTC_12x12_SRGB_BLOCK:int = 183
  DATA_FORMAT_G8B8G8R8_422_UNORM:int = 184
  DATA_FORMAT_B8G8R8G8_422_UNORM:int = 185
  DATA_FORMAT_G8_B8_R8_3PLANE_420_UNORM:int = 186
  DATA_FORMAT_G8_B8R8_2PLANE_420_UNORM:int = 187
  DATA_FORMAT_G8_B8_R8_3PLANE_422_UNORM:int = 188
  DATA_FORMAT_G8_B8R8_2PLANE_422_UNORM:int = 189
  DATA_FORMAT_G8_B8_R8_3PLANE_444_UNORM:int = 190
  DATA_FORMAT_R10X6_UNORM_PACK16:int = 191
  DATA_FORMAT_R10X6G10X6_UNORM_2PACK16:int = 192
  DATA_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16:int = 193
  DATA_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16:int = 194
  DATA_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16:int = 195
  DATA_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16:int = 196
  DATA_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16:int = 197
  DATA_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16:int = 198
  DATA_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16:int = 199
  DATA_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16:int = 200
  DATA_FORMAT_R12X4_UNORM_PACK16:int = 201
  DATA_FORMAT_R12X4G12X4_UNORM_2PACK16:int = 202
  DATA_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16:int = 203
  DATA_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16:int = 204
  DATA_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16:int = 205
  DATA_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16:int = 206
  DATA_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16:int = 207
  DATA_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16:int = 208
  DATA_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16:int = 209
  DATA_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16:int = 210
  DATA_FORMAT_G16B16G16R16_422_UNORM:int = 211
  DATA_FORMAT_B16G16R16G16_422_UNORM:int = 212
  DATA_FORMAT_G16_B16_R16_3PLANE_420_UNORM:int = 213
  DATA_FORMAT_G16_B16R16_2PLANE_420_UNORM:int = 214
  DATA_FORMAT_G16_B16_R16_3PLANE_422_UNORM:int = 215
  DATA_FORMAT_G16_B16R16_2PLANE_422_UNORM:int = 216
  DATA_FORMAT_G16_B16_R16_3PLANE_444_UNORM:int = 217
  DATA_FORMAT_MAX:int = 218
class BarrierMask:
  BARRIER_MASK_VERTEX:int = 1
  BARRIER_MASK_FRAGMENT:int = 8
  BARRIER_MASK_COMPUTE:int = 2
  BARRIER_MASK_TRANSFER:int = 4
  BARRIER_MASK_RASTER:int = 9
  BARRIER_MASK_ALL_BARRIERS:int = 32767
  BARRIER_MASK_NO_BARRIER:int = 32768
class TextureType:
  TEXTURE_KIND_1D:int = 0
  TEXTURE_KIND_2D:int = 1
  TEXTURE_KIND_3D:int = 2
  TEXTURE_KIND_CUBE:int = 3
  TEXTURE_KIND_1D_ARRAY:int = 4
  TEXTURE_KIND_2D_ARRAY:int = 5
  TEXTURE_KIND_CUBE_ARRAY:int = 6
  TEXTURE_KIND_MAX:int = 7
class TextureSamples:
  TEXTURE_SAMPLES_1:int = 0
  TEXTURE_SAMPLES_2:int = 1
  TEXTURE_SAMPLES_4:int = 2
  TEXTURE_SAMPLES_8:int = 3
  TEXTURE_SAMPLES_16:int = 4
  TEXTURE_SAMPLES_32:int = 5
  TEXTURE_SAMPLES_64:int = 6
  TEXTURE_SAMPLES_MAX:int = 7
class TextureUsageBits:
  TEXTURE_USAGE_SAMPLING_BIT:int = 1
  TEXTURE_USAGE_COLOR_ATTACHMENT_BIT:int = 2
  TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT:int = 4
  TEXTURE_USAGE_STORAGE_BIT:int = 8
  TEXTURE_USAGE_STORAGE_ATOMIC_BIT:int = 16
  TEXTURE_USAGE_CPU_READ_BIT:int = 32
  TEXTURE_USAGE_CAN_UPDATE_BIT:int = 64
  TEXTURE_USAGE_CAN_COPY_FROM_BIT:int = 128
  TEXTURE_USAGE_CAN_COPY_TO_BIT:int = 256
  TEXTURE_USAGE_INPUT_ATTACHMENT_BIT:int = 512
class TextureSwizzle:
  TEXTURE_SWIZZLE_IDENTITY:int = 0
  TEXTURE_SWIZZLE_ZERO:int = 1
  TEXTURE_SWIZZLE_ONE:int = 2
  TEXTURE_SWIZZLE_R:int = 3
  TEXTURE_SWIZZLE_G:int = 4
  TEXTURE_SWIZZLE_B:int = 5
  TEXTURE_SWIZZLE_A:int = 6
  TEXTURE_SWIZZLE_MAX:int = 7
class TextureSliceType:
  TEXTURE_SLICE_2D:int = 0
  TEXTURE_SLICE_CUBEMAP:int = 1
  TEXTURE_SLICE_3D:int = 2
class SamplerFilter:
  SAMPLER_FILTER_NEAREST:int = 0
  SAMPLER_FILTER_LINEAR:int = 1
class SamplerRepeatMode:
  SAMPLER_REPEAT_MODE_REPEAT:int = 0
  SAMPLER_REPEAT_MODE_MIRRORED_REPEAT:int = 1
  SAMPLER_REPEAT_MODE_CLAMP_TO_EDGE:int = 2
  SAMPLER_REPEAT_MODE_CLAMP_TO_BORDER:int = 3
  SAMPLER_REPEAT_MODE_MIRROR_CLAMP_TO_EDGE:int = 4
  SAMPLER_REPEAT_MODE_MAX:int = 5
class SamplerBorderColor:
  SAMPLER_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK:int = 0
  SAMPLER_BORDER_COLOR_INT_TRANSPARENT_BLACK:int = 1
  SAMPLER_BORDER_COLOR_FLOAT_OPAQUE_BLACK:int = 2
  SAMPLER_BORDER_COLOR_INT_OPAQUE_BLACK:int = 3
  SAMPLER_BORDER_COLOR_FLOAT_OPAQUE_WHITE:int = 4
  SAMPLER_BORDER_COLOR_INT_OPAQUE_WHITE:int = 5
  SAMPLER_BORDER_COLOR_MAX:int = 6
class VertexFrequency:
  VERTEX_FREQUENCY_VERTEX:int = 0
  VERTEX_FREQUENCY_INSTANCE:int = 1
class IndexBufferFormat:
  INDEX_BUFFER_FORMAT_UINT16:int = 0
  INDEX_BUFFER_FORMAT_UINT32:int = 1
class StorageBufferUsage:
  STORAGE_BUFFER_USAGE_DISPATCH_INDIRECT:int = 1
class BufferCreationBits:
  BUFFER_CREATION_DEVICE_ADDRESS_BIT:int = 1
  BUFFER_CREATION_AS_STORAGE_BIT:int = 2
class UniformType:
  UNIFORM_KIND_SAMPLER:int = 0
  UNIFORM_KIND_SAMPLER_WITH_TEXTURE:int = 1
  UNIFORM_KIND_TEXTURE:int = 2
  UNIFORM_KIND_IMAGE:int = 3
  UNIFORM_KIND_TEXTURE_BUFFER:int = 4
  UNIFORM_KIND_SAMPLER_WITH_TEXTURE_BUFFER:int = 5
  UNIFORM_KIND_IMAGE_BUFFER:int = 6
  UNIFORM_KIND_UNIFORM_BUFFER:int = 7
  UNIFORM_KIND_STORAGE_BUFFER:int = 8
  UNIFORM_KIND_INPUT_ATTACHMENT:int = 9
  UNIFORM_KIND_MAX:int = 10
class RenderPrimitive:
  RENDER_PRIMITIVE_POINTS:int = 0
  RENDER_PRIMITIVE_LINES:int = 1
  RENDER_PRIMITIVE_LINES_WITH_ADJACENCY:int = 2
  RENDER_PRIMITIVE_LINESTRIPS:int = 3
  RENDER_PRIMITIVE_LINESTRIPS_WITH_ADJACENCY:int = 4
  RENDER_PRIMITIVE_TRIANGLES:int = 5
  RENDER_PRIMITIVE_TRIANGLES_WITH_ADJACENCY:int = 6
  RENDER_PRIMITIVE_TRIANGLE_STRIPS:int = 7
  RENDER_PRIMITIVE_TRIANGLE_STRIPS_WITH_AJACENCY:int = 8
  RENDER_PRIMITIVE_TRIANGLE_STRIPS_WITH_RESTART_INDEX:int = 9
  RENDER_PRIMITIVE_TESSELATION_PATCH:int = 10
  RENDER_PRIMITIVE_MAX:int = 11
class PolygonCullMode:
  POLYGON_CULL_DISABLED:int = 0
  POLYGON_CULL_FRONT:int = 1
  POLYGON_CULL_BACK:int = 2
class PolygonFrontFace:
  POLYGON_FRONT_FACE_CLOCKWISE:int = 0
  POLYGON_FRONT_FACE_COUNTER_CLOCKWISE:int = 1
class StencilOperation:
  STENCIL_OPERATOR_KEEP:int = 0
  STENCIL_OPERATOR_ZERO:int = 1
  STENCIL_OPERATOR_REPLACE:int = 2
  STENCIL_OPERATOR_INCREMENT_AND_CLAMP:int = 3
  STENCIL_OPERATOR_DECREMENT_AND_CLAMP:int = 4
  STENCIL_OPERATOR_INVERT:int = 5
  STENCIL_OPERATOR_INCREMENT_AND_WRAP:int = 6
  STENCIL_OPERATOR_DECREMENT_AND_WRAP:int = 7
  STENCIL_OPERATOR_MAX:int = 8
class CompareOperator:
  COMPARE_OPERATOR_NEVER:int = 0
  COMPARE_OPERATOR_LESS:int = 1
  COMPARE_OPERATOR_EQUAL:int = 2
  COMPARE_OPERATOR_LESS_OR_EQUAL:int = 3
  COMPARE_OPERATOR_GREATER:int = 4
  COMPARE_OPERATOR_NOT_EQUAL:int = 5
  COMPARE_OPERATOR_GREATER_OR_EQUAL:int = 6
  COMPARE_OPERATOR_ALWAYS:int = 7
  COMPARE_OPERATOR_MAX:int = 8
class LogicOperation:
  LOGIC_OPERATOR_CLEAR:int = 0
  LOGIC_OPERATOR_AND:int = 1
  LOGIC_OPERATOR_AND_REVERSE:int = 2
  LOGIC_OPERATOR_COPY:int = 3
  LOGIC_OPERATOR_AND_INVERTED:int = 4
  LOGIC_OPERATOR_NO_OP:int = 5
  LOGIC_OPERATOR_XOR:int = 6
  LOGIC_OPERATOR_OR:int = 7
  LOGIC_OPERATOR_NOR:int = 8
  LOGIC_OPERATOR_EQUIVALENT:int = 9
  LOGIC_OPERATOR_INVERT:int = 10
  LOGIC_OPERATOR_OR_REVERSE:int = 11
  LOGIC_OPERATOR_COPY_INVERTED:int = 12
  LOGIC_OPERATOR_OR_INVERTED:int = 13
  LOGIC_OPERATOR_NAND:int = 14
  LOGIC_OPERATOR_SET:int = 15
  LOGIC_OPERATOR_MAX:int = 16
class BlendFactor:
  BLEND_FACTOR_ZERO:int = 0
  BLEND_FACTOR_ONE:int = 1
  BLEND_FACTOR_SRC_COLOR:int = 2
  BLEND_FACTOR_ONE_MINUS_SRC_COLOR:int = 3
  BLEND_FACTOR_DST_COLOR:int = 4
  BLEND_FACTOR_ONE_MINUS_DST_COLOR:int = 5
  BLEND_FACTOR_SRC_ALPHA:int = 6
  BLEND_FACTOR_ONE_MINUS_SRC_ALPHA:int = 7
  BLEND_FACTOR_DST_ALPHA:int = 8
  BLEND_FACTOR_ONE_MINUS_DST_ALPHA:int = 9
  BLEND_FACTOR_CONSTANT_COLOR:int = 10
  BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR:int = 11
  BLEND_FACTOR_CONSTANT_ALPHA:int = 12
  BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA:int = 13
  BLEND_FACTOR_SRC_ALPHA_SATURATE:int = 14
  BLEND_FACTOR_SRC1_COLOR:int = 15
  BLEND_FACTOR_ONE_MINUS_SRC1_COLOR:int = 16
  BLEND_FACTOR_SRC1_ALPHA:int = 17
  BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA:int = 18
  BLEND_FACTOR_MAX:int = 19
class BlendOperation:
  BLEND_OPERATOR_ADD:int = 0
  BLEND_OPERATOR_SUBTRACT:int = 1
  BLEND_OPERATOR_REVERSE_SUBTRACT:int = 2
  BLEND_OPERATOR_MINIMUM:int = 3
  BLEND_OPERATOR_MAXIMUM:int = 4
  BLEND_OPERATOR_MAX:int = 5
class PipelineDynamicStateFlags:
  DYNAMIC_STATE_LINE_WIDTH:int = 1
  DYNAMIC_STATE_DEPTH_BIAS:int = 2
  DYNAMIC_STATE_BLEND_CONSTANTS:int = 4
  DYNAMIC_STATE_DEPTH_BOUNDS:int = 8
  DYNAMIC_STATE_STENCIL_COMPARE_MASK:int = 16
  DYNAMIC_STATE_STENCIL_WRITE_MASK:int = 32
  DYNAMIC_STATE_STENCIL_REFERENCE:int = 64
class InitialAction:
  INITIAL_ACTION_LOAD:int = 0
  INITIAL_ACTION_CLEAR:int = 1
  INITIAL_ACTION_DISCARD:int = 2
  INITIAL_ACTION_MAX:int = 3
  INITIAL_ACTION_CLEAR_REGION:int = 1
  INITIAL_ACTION_CLEAR_REGION_CONTINUE:int = 1
  INITIAL_ACTION_KEEP:int = 0
  INITIAL_ACTION_DROP:int = 2
  INITIAL_ACTION_CONTINUE:int = 0
class FinalAction:
  FINAL_ACTION_STORE:int = 0
  FINAL_ACTION_DISCARD:int = 1
  FINAL_ACTION_MAX:int = 2
  FINAL_ACTION_READ:int = 0
  FINAL_ACTION_CONTINUE:int = 0
class ShaderStage:
  SHADER_STAGE_VERTEX:int = 0
  SHADER_STAGE_FRAGMENT:int = 1
  SHADER_STAGE_TESSELATION_CONTROL:int = 2
  SHADER_STAGE_TESSELATION_EVALUATION:int = 3
  SHADER_STAGE_COMPUTE:int = 4
  SHADER_STAGE_MAX:int = 5
  SHADER_STAGE_VERTEX_BIT:int = 1
  SHADER_STAGE_FRAGMENT_BIT:int = 2
  SHADER_STAGE_TESSELATION_CONTROL_BIT:int = 4
  SHADER_STAGE_TESSELATION_EVALUATION_BIT:int = 8
  SHADER_STAGE_COMPUTE_BIT:int = 16
class ShaderLanguage:
  SHADER_LANGUAGE_GLSL:int = 0
  SHADER_LANGUAGE_HLSL:int = 1
class PipelineSpecializationConstantType:
  PIPELINE_SPECIALIZATION_CONSTANT_KIND_BOOL:int = 0
  PIPELINE_SPECIALIZATION_CONSTANT_KIND_INT:int = 1
  PIPELINE_SPECIALIZATION_CONSTANT_KIND_FLOAT:int = 2
class Features:
  SUPPORTS_BUFFER_DEVICE_ADDRESS:int = 6
class Limit:
  LIMIT_MAX_BOUND_UNIFORM_SETS:int = 0
  LIMIT_MAX_FRAMEBUFFER_COLOR_ATTACHMENTS:int = 1
  LIMIT_MAX_TEXTURES_PER_UNIFORM_SET:int = 2
  LIMIT_MAX_SAMPLERS_PER_UNIFORM_SET:int = 3
  LIMIT_MAX_STORAGE_BUFFERS_PER_UNIFORM_SET:int = 4
  LIMIT_MAX_STORAGE_IMAGES_PER_UNIFORM_SET:int = 5
  LIMIT_MAX_UNIFORM_BUFFERS_PER_UNIFORM_SET:int = 6
  LIMIT_MAX_DRAW_INDEXED_INDEX:int = 7
  LIMIT_MAX_FRAMEBUFFER_HEIGHT:int = 8
  LIMIT_MAX_FRAMEBUFFER_WIDTH:int = 9
  LIMIT_MAX_TEXTURE_ARRAY_LAYERS:int = 10
  LIMIT_MAX_TEXTURE_SIZE_1D:int = 11
  LIMIT_MAX_TEXTURE_SIZE_2D:int = 12
  LIMIT_MAX_TEXTURE_SIZE_3D:int = 13
  LIMIT_MAX_TEXTURE_SIZE_CUBE:int = 14
  LIMIT_MAX_TEXTURES_PER_SHADER_STAGE:int = 15
  LIMIT_MAX_SAMPLERS_PER_SHADER_STAGE:int = 16
  LIMIT_MAX_STORAGE_BUFFERS_PER_SHADER_STAGE:int = 17
  LIMIT_MAX_STORAGE_IMAGES_PER_SHADER_STAGE:int = 18
  LIMIT_MAX_UNIFORM_BUFFERS_PER_SHADER_STAGE:int = 19
  LIMIT_MAX_PUSH_CONSTANT_SIZE:int = 20
  LIMIT_MAX_UNIFORM_BUFFER_SIZE:int = 21
  LIMIT_MAX_VERTEX_INPUT_ATTRIBUTE_OFFSET:int = 22
  LIMIT_MAX_VERTEX_INPUT_ATTRIBUTES:int = 23
  LIMIT_MAX_VERTEX_INPUT_BINDINGS:int = 24
  LIMIT_MAX_VERTEX_INPUT_BINDING_STRIDE:int = 25
  LIMIT_MIN_UNIFORM_BUFFER_OFFSET_ALIGNMENT:int = 26
  LIMIT_MAX_COMPUTE_SHARED_MEMORY_SIZE:int = 27
  LIMIT_MAX_COMPUTE_WORKGROUP_COUNT_X:int = 28
  LIMIT_MAX_COMPUTE_WORKGROUP_COUNT_Y:int = 29
  LIMIT_MAX_COMPUTE_WORKGROUP_COUNT_Z:int = 30
  LIMIT_MAX_COMPUTE_WORKGROUP_INVOCATIONS:int = 31
  LIMIT_MAX_COMPUTE_WORKGROUP_SIZE_X:int = 32
  LIMIT_MAX_COMPUTE_WORKGROUP_SIZE_Y:int = 33
  LIMIT_MAX_COMPUTE_WORKGROUP_SIZE_Z:int = 34
  LIMIT_MAX_VIEWPORT_DIMENSIONS_X:int = 35
  LIMIT_MAX_VIEWPORT_DIMENSIONS_Y:int = 36
  LIMIT_METALFX_TEMPORAL_SCALER_MIN_SCALE:int = 46
  LIMIT_METALFX_TEMPORAL_SCALER_MAX_SCALE:int = 47
class MemoryType:
  MEMORY_TEXTURES:int = 0
  MEMORY_BUFFERS:int = 1
  MEMORY_TOTAL:int = 2
class BreadcrumbMarker:
  NONE:int = 0
  REFLECTION_PROBES:int = 65536
  SKY_PASS:int = 131072
  LIGHTMAPPER_PASS:int = 196608
  SHADOW_PASS_DIRECTIONAL:int = 262144
  SHADOW_PASS_CUBE:int = 327680
  OPAQUE_PASS:int = 393216
  ALPHA_PASS:int = 458752
  TRANSPARENT_PASS:int = 524288
  POST_PROCESSING_PASS:int = 589824
  BLIT_PASS:int = 655360
  UI_PASS:int = 720896
  DEBUG_PASS:int = 786432
class DrawFlags:
  DRAW_DEFAULT_ALL:int = 0
  DRAW_CLEAR_COLOR_0:int = 1
  DRAW_CLEAR_COLOR_1:int = 2
  DRAW_CLEAR_COLOR_2:int = 4
  DRAW_CLEAR_COLOR_3:int = 8
  DRAW_CLEAR_COLOR_4:int = 16
  DRAW_CLEAR_COLOR_5:int = 32
  DRAW_CLEAR_COLOR_6:int = 64
  DRAW_CLEAR_COLOR_7:int = 128
  DRAW_CLEAR_COLOR_MASK:int = 255
  DRAW_CLEAR_COLOR_ALL:int = 255
  DRAW_IGNORE_COLOR_0:int = 256
  DRAW_IGNORE_COLOR_1:int = 512
  DRAW_IGNORE_COLOR_2:int = 1024
  DRAW_IGNORE_COLOR_3:int = 2048
  DRAW_IGNORE_COLOR_4:int = 4096
  DRAW_IGNORE_COLOR_5:int = 8192
  DRAW_IGNORE_COLOR_6:int = 16384
  DRAW_IGNORE_COLOR_7:int = 32768
  DRAW_IGNORE_COLOR_MASK:int = 65280
  DRAW_IGNORE_COLOR_ALL:int = 65280
  DRAW_CLEAR_DEPTH:int = 65536
  DRAW_IGNORE_DEPTH:int = 131072
  DRAW_CLEAR_STENCIL:int = 262144
  DRAW_IGNORE_STENCIL:int = 524288
  DRAW_CLEAR_ALL:int = 327935
  DRAW_IGNORE_ALL:int = 720640


class RenderingDevice(__object__.Object):
  """
		`RenderingDevice` is an abstraction for working with modern low-level graphics APIs such as Vulkan. Compared to `RenderingServer` (which works with Godot's own rendering subsystems), `RenderingDevice` is much lower-level and allows working more directly with the underlying graphics APIs. `RenderingDevice` is used in Godot to provide support for several modern low-level graphics APIs while reducing the amount of code duplication required. `RenderingDevice` can also be used in your own projects to perform things that are not exposed by `RenderingServer` or high-level nodes, such as using compute shaders.
		On startup, Godot creates a global `RenderingDevice` which can be retrieved using `RenderingServer.get_rendering_device`. This global `RenderingDevice` performs drawing to the screen.
		**Local RenderingDevices:** Using `RenderingServer.create_local_rendering_device`, you can create "secondary" rendering devices to perform drawing and GPU compute operations on separate threads.
		**Note:** `RenderingDevice` assumes intermediate knowledge of modern graphics APIs such as Vulkan, Direct3D 12, Metal or WebGPU. These graphics APIs are lower-level than OpenGL or Direct3D 11, requiring you to perform what was previously done by the graphics driver itself. If you have difficulty understanding the concepts used in this class, follow the `url=https://vulkan-tutorial.com/`Vulkan Tutorial`/url` or `url=https://vkguide.dev/`Vulkan Guide`/url`. It's recommended to have existing modern OpenGL or Direct3D 11 knowledge before attempting to learn a low-level graphics API.
		**Note:** `RenderingDevice` is not available when running in headless mode or when using the Compatibility rendering method.
	"""

  @staticmethod
  def constructor()->RenderingDevice:pass



  @staticmethod
  def cast(other:__object__.Object)->RenderingDevice:pass


  def texture_create(self, format:__rdtextureformat__.RDTextureFormat, view:__rdtextureview__.RDTextureView, data:__core__.Array=[])->__core__.RID:
    """
				Creates a new texture. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
				**Note:** `data` takes an `Array` of `PackedByteArray`s. For `constant TEXTURE_TYPE_1D`, `constant TEXTURE_TYPE_2D`, and `constant TEXTURE_TYPE_3D` types, this array should only have one element, a `PackedByteArray` containing all the data for the texture. For `_ARRAY` and `_CUBE` types, the length should be the same as the number of `RDTextureFormat.array_layers` in `format`.
				**Note:** Not to be confused with `RenderingServer.texture_2d_create`, which creates the Godot-specific `Texture2D` resource as opposed to the graphics API's own texture type.
			"""
    pass

  def texture_create_shared(self, view:__rdtextureview__.RDTextureView, with_texture:__core__.RID)->__core__.RID:
    """
				Creates a shared texture using the specified `view` and the texture information from `with_texture`.
			"""
    pass

  def texture_create_shared_from_slice(self, view:__rdtextureview__.RDTextureView, with_texture:__core__.RID, layer:int, mipmap:int, mipmaps:int=1, slice_type:int =0)->__core__.RID:
    """
				Creates a shared texture using the specified `view` and the texture information from `with_texture`'s `layer` and `mipmap`. The number of included mipmaps from the original texture can be controlled using the `mipmaps` parameter. Only relevant for textures with multiple layers, such as 3D textures, texture arrays and cubemaps. For single-layer textures, use `texture_create_shared`.
				For 2D textures (which only have one layer), `layer` must be `0`.
				**Note:** Layer slicing is only supported for 2D texture arrays, not 3D textures or cubemaps.
			"""
    pass

  def texture_create_from_extension(self, type:int , format:int , samples:int , usage_flags:int, image:int, width:int, height:int, depth:int, layers:int)->__core__.RID:
    """
				Returns an RID for an existing `image` (`VkImage`) with the given `type`, `format`, `samples`, `usage_flags`, `width`, `height`, `depth`, `layers`, and `mipmaps`. This can be used to allow Godot to render onto foreign images.
			"""
    pass

  def texture_update(self, texture:__core__.RID, layer:int, data:__core__.PackedByteArray)->int:
    """
				Updates texture data with new data, replacing the previous data in place. The updated texture data must have the same dimensions and format. For 2D textures (which only have one layer), `layer` must be `0`. Returns `constant @GlobalScope.OK` if the update was successful, `constant @GlobalScope.ERR_INVALID_PARAMETER` otherwise.
				**Note:** Updating textures is forbidden during creation of a draw or compute list.
				**Note:** The existing `texture` can't be updated while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to `constant FINAL_ACTION_CONTINUE`) to update this texture.
				**Note:** The existing `texture` requires the `constant TEXTURE_USAGE_CAN_UPDATE_BIT` to be updatable.
			"""
    pass

  def texture_get_data(self, texture:__core__.RID, layer:int)->__core__.PackedByteArray:
    """
				Returns the `texture` data for the specified `layer` as raw binary data. For 2D textures (which only have one layer), `layer` must be `0`.
				**Note:** `texture` can't be retrieved while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to `constant FINAL_ACTION_CONTINUE`) to retrieve this texture. Otherwise, an error is printed and an empty `PackedByteArray` is returned.
				**Note:** `texture` requires the `constant TEXTURE_USAGE_CAN_COPY_FROM_BIT` to be retrieved. Otherwise, an error is printed and an empty `PackedByteArray` is returned.
				**Note:** This method will block the GPU from working until the data is retrieved. Refer to `texture_get_data_async` for an alternative that returns the data in more performant way.
			"""
    pass

  def texture_get_data_async(self, texture:__core__.RID, layer:int, callback:__core__.Callable)->int:
    """
				Asynchronous version of `texture_get_data`. RenderingDevice will call `callback` in a certain amount of frames with the data the texture had at the time of the request.
				**Note:** At the moment, the delay corresponds to the amount of frames specified by `ProjectSettings.rendering/rendering_device/vsync/frame_queue_size`.
				**Note:** Downloading large textures can have a prohibitive cost for real-time even when using the asynchronous method due to hardware bandwidth limitations. When dealing with large resources, you can adjust settings such as `ProjectSettings.rendering/rendering_device/staging_buffer/texture_download_region_size_px` and `ProjectSettings.rendering/rendering_device/staging_buffer/block_size_kb` to improve the transfer speed at the cost of extra memory.
				```gdscript
				func _texture_get_data_callback(array):
					value = array.decode_u32(0)

				...

				rd.texture_get_data_async(texture, 0, _texture_get_data_callback)
				```
			"""
    pass

  def texture_is_format_supported_for_usage(self, format:int , usage_flags:int)->bool:
    """
				Returns `true` if the specified `format` is supported for the given `usage_flags`, `false` otherwise.
			"""
    pass

  def texture_is_shared(self, texture:__core__.RID)->bool:
    """
				Returns `true` if the `texture` is shared, `false` otherwise. See `RDTextureView`.
			"""
    pass

  def texture_is_valid(self, texture:__core__.RID)->bool:
    """
				Returns `true` if the `texture` is valid, `false` otherwise.
			"""
    pass

  def texture_set_discardable(self, texture:__core__.RID, discardable:bool)->None:
    """
				Updates the discardable property of `texture`.
				If a texture is discardable, its contents do not need to be preserved between frames. This flag is only relevant when the texture is used as target in a draw list.
				This information is used by `RenderingDevice` to figure out if a texture's contents can be discarded, eliminating unnecessary writes to memory and boosting performance.
			"""
    pass

  def texture_is_discardable(self, texture:__core__.RID)->bool:
    """
				Returns `true` if the `texture` is discardable, `false` otherwise. See `RDTextureFormat` or `texture_set_discardable`.
			"""
    pass

  def texture_copy(self, from_texture:__core__.RID, to_texture:__core__.RID, from_pos:__core__.Vector3, to_pos:__core__.Vector3, size:__core__.Vector3, src_mipmap:int, dst_mipmap:int, src_layer:int, dst_layer:int)->int:
    """
				Copies the `from_texture` to `to_texture` with the specified `from_pos`, `to_pos` and `size` coordinates. The Z axis of the `from_pos`, `to_pos` and `size` must be `0` for 2-dimensional textures. Source and destination mipmaps/layers must also be specified, with these parameters being `0` for textures without mipmaps or single-layer textures. Returns `constant @GlobalScope.OK` if the texture copy was successful or `constant @GlobalScope.ERR_INVALID_PARAMETER` otherwise.
				**Note:** `from_texture` texture can't be copied while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to `constant FINAL_ACTION_CONTINUE`) to copy this texture.
				**Note:** `from_texture` texture requires the `constant TEXTURE_USAGE_CAN_COPY_FROM_BIT` to be retrieved.
				**Note:** `to_texture` can't be copied while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to `constant FINAL_ACTION_CONTINUE`) to copy this texture.
				**Note:** `to_texture` requires the `constant TEXTURE_USAGE_CAN_COPY_TO_BIT` to be retrieved.
				**Note:** `from_texture` and `to_texture` must be of the same type (color or depth).
			"""
    pass

  def texture_clear(self, texture:__core__.RID, color:__core__.Color, base_mipmap:int, mipmap_count:int, base_layer:int, layer_count:int)->int:
    """
				Clears the specified `texture` by replacing all of its pixels with the specified `color`. `base_mipmap` and `mipmap_count` determine which mipmaps of the texture are affected by this clear operation, while `base_layer` and `layer_count` determine which layers of a 3D texture (or texture array) are affected by this clear operation. For 2D textures (which only have one layer by design), `base_layer` must be `0` and `layer_count` must be `1`.
				**Note:** `texture` can't be cleared while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to `constant FINAL_ACTION_CONTINUE`) to clear this texture.
			"""
    pass

  def texture_resolve_multisample(self, from_texture:__core__.RID, to_texture:__core__.RID)->int:
    """
				Resolves the `from_texture` texture onto `to_texture` with multisample antialiasing enabled. This must be used when rendering a framebuffer for MSAA to work. Returns `constant @GlobalScope.OK` if successful, `constant @GlobalScope.ERR_INVALID_PARAMETER` otherwise.
				**Note:** `from_texture` and `to_texture` textures must have the same dimension, format and type (color or depth).
				**Note:** `from_texture` can't be copied while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to `constant FINAL_ACTION_CONTINUE`) to resolve this texture.
				**Note:** `from_texture` requires the `constant TEXTURE_USAGE_CAN_COPY_FROM_BIT` to be retrieved.
				**Note:** `from_texture` must be multisampled and must also be 2D (or a slice of a 3D/cubemap texture).
				**Note:** `to_texture` can't be copied while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to `constant FINAL_ACTION_CONTINUE`) to resolve this texture.
				**Note:** `to_texture` texture requires the `constant TEXTURE_USAGE_CAN_COPY_TO_BIT` to be retrieved.
				**Note:** `to_texture` texture must **not** be multisampled and must also be 2D (or a slice of a 3D/cubemap texture).
			"""
    pass

  def texture_get_format(self, texture:__core__.RID)->__rdtextureformat__.RDTextureFormat:
    """
				Returns the data format used to create this texture.
			"""
    pass

  def texture_get_native_handle(self, texture:__core__.RID)->int:
    """
				Returns the internal graphics handle for this texture object. For use when communicating with third-party APIs mostly with GDExtension.
				**Note:** This function returns a `uint64_t` which internally maps to a `GLuint` (OpenGL) or `VkImage` (Vulkan).
			"""
    pass

  def framebuffer_format_create(self, attachments:__core__.Array, view_count:int=1)->int:
    """
				Creates a new framebuffer format with the specified `attachments` and `view_count`. Returns the new framebuffer's unique framebuffer format ID.
				If `view_count` is greater than or equal to `2`, enables multiview which is used for VR rendering. This requires support for the Vulkan multiview extension.
			"""
    pass

  def framebuffer_format_create_multipass(self, attachments:__core__.Array, passes:__core__.Array, view_count:int=1)->int:
    """
				Creates a multipass framebuffer format with the specified `attachments`, `passes` and `view_count` and returns its ID. If `view_count` is greater than or equal to `2`, enables multiview which is used for VR rendering. This requires support for the Vulkan multiview extension.
			"""
    pass

  def framebuffer_format_create_empty(self, samples:int =0)->int:
    """
				Creates a new empty framebuffer format with the specified number of `samples` and returns its ID.
			"""
    pass

  def framebuffer_format_get_texture_samples(self, format:int, render_pass:int=0)->int:
    """
				Returns the number of texture samples used for the given framebuffer `format` ID (returned by `framebuffer_get_format`).
			"""
    pass

  def framebuffer_create(self, textures:__core__.Array, validate_with_format:int=-1, view_count:int=1)->__core__.RID:
    """
				Creates a new framebuffer. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			"""
    pass

  def framebuffer_create_multipass(self, textures:__core__.Array, passes:__core__.Array, validate_with_format:int=-1, view_count:int=1)->__core__.RID:
    """
				Creates a new multipass framebuffer. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			"""
    pass

  def framebuffer_create_empty(self, size:__core__.Vector2i, samples:int =0, validate_with_format:int=-1)->__core__.RID:
    """
				Creates a new empty framebuffer. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			"""
    pass

  def framebuffer_get_format(self, framebuffer:__core__.RID)->int:
    """
				Returns the format ID of the framebuffer specified by the `framebuffer` RID. This ID is guaranteed to be unique for the same formats and does not need to be freed.
			"""
    pass

  def framebuffer_is_valid(self, framebuffer:__core__.RID)->bool:
    """
				Returns `true` if the framebuffer specified by the `framebuffer` RID is valid, `false` otherwise.
			"""
    pass

  def sampler_create(self, state:__rdsamplerstate__.RDSamplerState)->__core__.RID:
    """
				Creates a new sampler. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			"""
    pass

  def sampler_is_format_supported_for_filter(self, format:int , sampler_filter:int )->bool:
    """
				Returns `true` if implementation supports using a texture of `format` with the given `sampler_filter`.
			"""
    pass

  def vertex_buffer_create(self, size_bytes:int, data:__core__.PackedByteArray= __core__.PackedByteArray.new0(), creation_bits:int=0)->__core__.RID:
    """
				Creates a new vertex buffer. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			"""
    pass

  def vertex_format_create(self, vertex_descriptions:__core__.Array)->int:
    """
				Creates a new vertex format with the specified `vertex_descriptions`. Returns a unique vertex format ID corresponding to the newly created vertex format.
			"""
    pass

  def vertex_array_create(self, vertex_count:int, vertex_format:int, src_buffers:__core__.Array, offsets:__core__.PackedInt64Array= __core__.PackedInt64Array.new0())->__core__.RID:
    """
				Creates a vertex array based on the specified buffers. Optionally, `offsets` (in bytes) may be defined for each buffer.
			"""
    pass

  def index_buffer_create(self, size_indices:int, format:int , data:__core__.PackedByteArray= __core__.PackedByteArray.new0(), use_restart_indices:bool=False, creation_bits:int=0)->__core__.RID:
    """
				Creates a new index buffer. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			"""
    pass

  def index_array_create(self, index_buffer:__core__.RID, index_offset:int, index_count:int)->__core__.RID:
    """
				Creates a new index array. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			"""
    pass

  def shader_compile_spirv_from_source(self, shader_source:__rdshadersource__.RDShaderSource, allow_cache:bool=True)->__rdshaderspirv__.RDShaderSPIRV:
    """
				Compiles a SPIR-V from the shader source code in `shader_source` and returns the SPIR-V as an `RDShaderSPIRV`. This intermediate language shader is portable across different GPU models and driver versions, but cannot be run directly by GPUs until compiled into a binary shader using `shader_compile_binary_from_spirv`.
				If `allow_cache` is `true`, make use of the shader cache generated by Godot. This avoids a potentially lengthy shader compilation step if the shader is already in cache. If `allow_cache` is `false`, Godot's shader cache is ignored and the shader will always be recompiled.
			"""
    pass

  def shader_compile_binary_from_spirv(self, spirv_data:__rdshaderspirv__.RDShaderSPIRV, name:str= __core__.String.new0())->__core__.PackedByteArray:
    """
				Compiles a binary shader from `spirv_data` and returns the compiled binary data as a `PackedByteArray`. This compiled shader is specific to the GPU model and driver version used; it will not work on different GPU models or even different driver versions. See also `shader_compile_spirv_from_source`.
				`name` is an optional human-readable name that can be given to the compiled shader for organizational purposes.
			"""
    pass

  def shader_create_from_spirv(self, spirv_data:__rdshaderspirv__.RDShaderSPIRV, name:str= __core__.String.new0())->__core__.RID:
    """
				Creates a new shader instance from SPIR-V intermediate code. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method. See also `shader_compile_spirv_from_source` and `shader_create_from_bytecode`.
			"""
    pass

  def shader_create_from_bytecode(self, binary_data:__core__.PackedByteArray, placeholder_rid:__core__.RID= __core__.RID.new0())->__core__.RID:
    """
				Creates a new shader instance from a binary compiled shader. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method. See also `shader_compile_binary_from_spirv` and `shader_create_from_spirv`.
			"""
    pass

  def shader_create_placeholder(self)->__core__.RID:
    """
				Create a placeholder RID by allocating an RID without initializing it for use in `shader_create_from_bytecode`. This allows you to create an RID for a shader and pass it around, but defer compiling the shader to a later time.
			"""
    pass

  def shader_get_vertex_input_attribute_mask(self, shader:__core__.RID)->int:
    """
				Returns the internal vertex input mask. Internally, the vertex input mask is an unsigned integer consisting of the locations (specified in GLSL via. `layout(location = ...)`) of the input variables (specified in GLSL by the `in` keyword).
			"""
    pass

  def uniform_buffer_create(self, size_bytes:int, data:__core__.PackedByteArray= __core__.PackedByteArray.new0(), creation_bits:int=0)->__core__.RID:
    """
				Creates a new uniform buffer. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			"""
    pass

  def storage_buffer_create(self, size_bytes:int, data:__core__.PackedByteArray= __core__.PackedByteArray.new0(), usage:int=0, creation_bits:int=0)->__core__.RID:
    """
				Creates a `url=https://vkguide.dev/docs/chapter-4/storage_buffers/`storage buffer`/url` with the specified `data` and `usage`. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			"""
    pass

  def texture_buffer_create(self, size_bytes:int, format:int , data:__core__.PackedByteArray= __core__.PackedByteArray.new0())->__core__.RID:
    """
				Creates a new texture buffer. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			"""
    pass

  def uniform_set_create(self, uniforms:__core__.Array, shader:__core__.RID, shader_set:int)->__core__.RID:
    """
				Creates a new uniform set. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			"""
    pass

  def uniform_set_is_valid(self, uniform_set:__core__.RID)->bool:
    """
				Checks if the `uniform_set` is valid, i.e. is owned.
			"""
    pass

  def buffer_copy(self, src_buffer:__core__.RID, dst_buffer:__core__.RID, src_offset:int, dst_offset:int, size:int)->int:
    """
				Copies `size` bytes from the `src_buffer` at `src_offset` into `dst_buffer` at `dst_offset`.
				Prints an error if:
				- `size` exceeds the size of either `src_buffer` or `dst_buffer` at their corresponding offsets
				- a draw list is currently active (created by `draw_list_begin`)
				- a compute list is currently active (created by `compute_list_begin`)
			"""
    pass

  def buffer_update(self, buffer:__core__.RID, offset:int, size_bytes:int, data:__core__.PackedByteArray)->int:
    """
				Updates a region of `size_bytes` bytes, starting at `offset`, in the buffer, with the specified `data`.
				Prints an error if:
				- the region specified by `offset` + `size_bytes` exceeds the buffer
				- a draw list is currently active (created by `draw_list_begin`)
				- a compute list is currently active (created by `compute_list_begin`)
			"""
    pass

  def buffer_clear(self, buffer:__core__.RID, offset:int, size_bytes:int)->int:
    """
				Clears the contents of the `buffer`, clearing `size_bytes` bytes, starting at `offset`.
				Prints an error if:
				- the size isn't a multiple of four
				- the region specified by `offset` + `size_bytes` exceeds the buffer
				- a draw list is currently active (created by `draw_list_begin`)
				- a compute list is currently active (created by `compute_list_begin`)
			"""
    pass

  def buffer_get_data(self, buffer:__core__.RID, offset_bytes:int=0, size_bytes:int=0)->__core__.PackedByteArray:
    """
				Returns a copy of the data of the specified `buffer`, optionally `offset_bytes` and `size_bytes` can be set to copy only a portion of the buffer.
				**Note:** This method will block the GPU from working until the data is retrieved. Refer to `buffer_get_data_async` for an alternative that returns the data in more performant way.
			"""
    pass

  def buffer_get_data_async(self, buffer:__core__.RID, callback:__core__.Callable, offset_bytes:int=0, size_bytes:int=0)->int:
    """
				Asynchronous version of `buffer_get_data`. RenderingDevice will call `callback` in a certain amount of frames with the data the buffer had at the time of the request.
				**Note:** At the moment, the delay corresponds to the amount of frames specified by `ProjectSettings.rendering/rendering_device/vsync/frame_queue_size`.
				**Note:** Downloading large buffers can have a prohibitive cost for real-time even when using the asynchronous method due to hardware bandwidth limitations. When dealing with large resources, you can adjust settings such as `ProjectSettings.rendering/rendering_device/staging_buffer/block_size_kb` to improve the transfer speed at the cost of extra memory.
				```gdscript
				func _buffer_get_data_callback(array):
					value = array.decode_u32(0)

				...

				rd.buffer_get_data_async(buffer, _buffer_get_data_callback)
				```
			"""
    pass

  def buffer_get_device_address(self, buffer:__core__.RID)->int:
    """
				Returns the address of the given `buffer` which can be passed to shaders in any way to access underlying data. Buffer must have been created with this feature enabled.
				**Note:** You must check that the GPU supports this functionality by calling `has_feature` with `constant SUPPORTS_BUFFER_DEVICE_ADDRESS` as a parameter.
			"""
    pass

  def render_pipeline_create(self, shader:__core__.RID, framebuffer_format:int, vertex_format:int, primitive:int , rasterization_state:__rdpipelinerasterizationstate__.RDPipelineRasterizationState, multisample_state:__rdpipelinemultisamplestate__.RDPipelineMultisampleState, stencil_state:__rdpipelinedepthstencilstate__.RDPipelineDepthStencilState, color_blend_state:__rdpipelinecolorblendstate__.RDPipelineColorBlendState, dynamic_state_flags:int=0, for_render_pass:int=0, specialization_constants:__core__.Array=Array[RDPipelineSpecializationConstant]([]))->__core__.RID:
    """
				Creates a new render pipeline. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			"""
    pass

  def render_pipeline_is_valid(self, render_pipeline:__core__.RID)->bool:
    """
				Returns `true` if the render pipeline specified by the `render_pipeline` RID is valid, `false` otherwise.
			"""
    pass

  def compute_pipeline_create(self, shader:__core__.RID, specialization_constants:__core__.Array=Array[RDPipelineSpecializationConstant]([]))->__core__.RID:
    """
				Creates a new compute pipeline. It can be accessed with the RID that is returned.
				Once finished with your RID, you will want to free the RID using the RenderingDevice's `free_rid` method.
			"""
    pass

  def compute_pipeline_is_valid(self, compute_pipeline:__core__.RID)->bool:
    """
				Returns `true` if the compute pipeline specified by the `compute_pipeline` RID is valid, `false` otherwise.
			"""
    pass

  def screen_get_width(self, screen:int=0)->int:
    """
				Returns the window width matching the graphics API context for the given window ID (in pixels). Despite the parameter being named `screen`, this returns the _window_ size. See also `screen_get_height`.
				**Note:** Only the main `RenderingDevice` returned by `RenderingServer.get_rendering_device` has a width. If called on a local `RenderingDevice`, this method prints an error and returns `constant INVALID_ID`.
			"""
    pass

  def screen_get_height(self, screen:int=0)->int:
    """
				Returns the window height matching the graphics API context for the given window ID (in pixels). Despite the parameter being named `screen`, this returns the _window_ size. See also `screen_get_width`.
				**Note:** Only the main `RenderingDevice` returned by `RenderingServer.get_rendering_device` has a height. If called on a local `RenderingDevice`, this method prints an error and returns `constant INVALID_ID`.
			"""
    pass

  def screen_get_framebuffer_format(self, screen:int=0)->int:
    """
				Returns the framebuffer format of the given screen.
				**Note:** Only the main `RenderingDevice` returned by `RenderingServer.get_rendering_device` has a format. If called on a local `RenderingDevice`, this method prints an error and returns `constant INVALID_ID`.
			"""
    pass

  def draw_list_begin_for_screen(self, screen:int=0, clear_color:__core__.Color= __core__.Color.new0())->int:
    """
				High-level variant of `draw_list_begin`, with the parameters automatically being adjusted for drawing onto the window specified by the `screen` ID.
				**Note:** Cannot be used with local RenderingDevices, as these don't have a screen. If called on a local RenderingDevice, `draw_list_begin_for_screen` returns `constant INVALID_ID`.
			"""
    pass

  def draw_list_begin(self, framebuffer:__core__.RID, draw_flags:int=0, clear_color_values:__core__.PackedColorArray= __core__.PackedColorArray.new0(), clear_depth_value:float=1.0, clear_stencil_value:int=0, region:__core__.Rect2= __core__.Rect2.new0(), breadcrumb:int=0)->int:
    """
				Starts a list of raster drawing commands created with the `draw_*` methods. The returned value should be passed to other `draw_list_*` functions.
				Multiple draw lists cannot be created at the same time; you must finish the previous draw list first using `draw_list_end`.
				A simple drawing operation might look like this (code is not a complete example):
				```gdscript
				var rd = RenderingDevice.new()
				var clear_colors = PackedColorArray(`Color(0, 0, 0, 0), Color(0, 0, 0, 0), Color(0, 0, 0, 0)`)
				var draw_list = rd.draw_list_begin(framebuffers_, RenderingDevice.CLEAR_COLOR_ALL, clear_colors, true, 1.0f, true, 0, Rect2(), RenderingDevice.OPAQUE_PASS)

				# Draw opaque.
				rd.draw_list_bind_render_pipeline(draw_list, raster_pipeline)
				rd.draw_list_bind_uniform_set(draw_list, raster_base_uniform, 0)
				rd.draw_list_set_push_constant(draw_list, raster_push_constant, raster_push_constant.size())
				rd.draw_list_draw(draw_list, false, 1, slice_triangle_count_ * 3)
				# Draw wire.
				rd.draw_list_bind_render_pipeline(draw_list, raster_pipeline_wire)
				rd.draw_list_bind_uniform_set(draw_list, raster_base_uniform, 0)
				rd.draw_list_set_push_constant(draw_list, raster_push_constant, raster_push_constant.size())
				rd.draw_list_draw(draw_list, false, 1, slice_triangle_count_ * 3)

				rd.draw_list_end()
				```
				The `draw_flags` indicates if the texture attachments of the framebuffer should be cleared or ignored. Only one of the two flags can be used for each individual attachment. Ignoring an attachment means that any contents that existed before the draw list will be completely discarded, reducing the memory bandwidth used by the render pass but producing garbage results if the pixels aren't replaced. The default behavior allows the engine to figure out the right operation to use if the texture is discardable, which can result in increased performance. See `RDTextureFormat` or `texture_set_discardable`.
				The `breadcrumb` parameter can be an arbitrary 32-bit integer that is useful to diagnose GPU crashes. If Godot is built in dev or debug mode; when the GPU crashes Godot will dump all shaders that were being executed at the time of the crash and the breadcrumb is useful to diagnose what passes did those shaders belong to.
				It does not affect rendering behavior and can be set to 0. It is recommended to use `enum BreadcrumbMarker` enumerations for consistency but it's not required. It is also possible to use bitwise operations to add extra data. e.g.
				```gdscript
				rd.draw_list_begin(fb_, RenderingDevice.CLEAR_COLOR_ALL, clear_colors, true, 1.0f, true, 0, Rect2(), RenderingDevice.OPAQUE_PASS | 5)
				```
			"""
    pass

  def draw_list_begin_split(self, framebuffer:__core__.RID, splits:int, initial_color_action:int , final_color_action:int , initial_depth_action:int , final_depth_action:int , clear_color_values:__core__.PackedColorArray= __core__.PackedColorArray.new0(), clear_depth:float=1.0, clear_stencil:int=0, region:__core__.Rect2= __core__.Rect2.new0(), storage_textures:__core__.Array=Array[RID]([]))->__core__.PackedInt64Array:
    """
				This method does nothing and always returns an empty `PackedInt64Array`.
			"""
    pass

  def draw_list_set_blend_constants(self, draw_list:int, color:__core__.Color)->None:
    """
				Sets blend constants for the specified `draw_list` to `color`. Blend constants are used only if the graphics pipeline is created with `constant DYNAMIC_STATE_BLEND_CONSTANTS` flag set.
			"""
    pass

  def draw_list_bind_render_pipeline(self, draw_list:int, render_pipeline:__core__.RID)->None:
    """
				Binds `render_pipeline` to the specified `draw_list`.
			"""
    pass

  def draw_list_bind_uniform_set(self, draw_list:int, uniform_set:__core__.RID, set_index:int)->None:
    """
				Binds `uniform_set` to the specified `draw_list`. A `set_index` must also be specified, which is an identifier starting from `0` that must match the one expected by the draw list.
			"""
    pass

  def draw_list_bind_vertex_array(self, draw_list:int, vertex_array:__core__.RID)->None:
    """
				Binds `vertex_array` to the specified `draw_list`.
			"""
    pass

  def draw_list_bind_index_array(self, draw_list:int, index_array:__core__.RID)->None:
    """
				Binds `index_array` to the specified `draw_list`.
			"""
    pass

  def draw_list_set_push_constant(self, draw_list:int, buffer:__core__.PackedByteArray, size_bytes:int)->None:
    """
				Sets the push constant data to `buffer` for the specified `draw_list`. The shader determines how this binary data is used. The buffer's size in bytes must also be specified in `size_bytes` (this can be obtained by calling the `PackedByteArray.size` method on the passed `buffer`).
			"""
    pass

  def draw_list_draw(self, draw_list:int, use_indices:bool, instances:int, procedural_vertex_count:int=0)->None:
    """
				Submits `draw_list` for rendering on the GPU. This is the raster equivalent to `compute_list_dispatch`.
			"""
    pass

  def draw_list_draw_indirect(self, draw_list:int, use_indices:bool, buffer:__core__.RID, offset:int=0, draw_count:int=1, stride:int=0)->None:
    """
				Submits `draw_list` for rendering on the GPU with the given parameters stored in the `buffer` at `offset`. Parameters being integers: vertex count, instance count, first vertex, first instance. And when using indices: index count, instance count, first index, vertex offset, first instance. Buffer must have been created with `constant STORAGE_BUFFER_USAGE_DISPATCH_INDIRECT` flag.
			"""
    pass

  def draw_list_enable_scissor(self, draw_list:int, rect:__core__.Rect2= __core__.Rect2.new0())->None:
    """
				Creates a scissor rectangle and enables it for the specified `draw_list`. Scissor rectangles are used for clipping by discarding fragments that fall outside a specified rectangular portion of the screen. See also `draw_list_disable_scissor`.
				**Note:** The specified `rect` is automatically intersected with the screen's dimensions, which means it cannot exceed the screen's dimensions.
			"""
    pass

  def draw_list_disable_scissor(self, draw_list:int)->None:
    """
				Removes and disables the scissor rectangle for the specified `draw_list`. See also `draw_list_enable_scissor`.
			"""
    pass

  def draw_list_switch_to_next_pass(self)->int:
    """
				Switches to the next draw pass.
			"""
    pass

  def draw_list_switch_to_next_pass_split(self, splits:int)->__core__.PackedInt64Array:
    """
				This method does nothing and always returns an empty `PackedInt64Array`.
			"""
    pass

  def draw_list_end(self)->None:
    """
				Finishes a list of raster drawing commands created with the `draw_*` methods.
			"""
    pass

  def compute_list_begin(self)->int:
    """
				Starts a list of compute commands created with the `compute_*` methods. The returned value should be passed to other `compute_list_*` functions.
				Multiple compute lists cannot be created at the same time; you must finish the previous compute list first using `compute_list_end`.
				A simple compute operation might look like this (code is not a complete example):
				```gdscript
				var rd = RenderingDevice.new()
				var compute_list = rd.compute_list_begin()

				rd.compute_list_bind_compute_pipeline(compute_list, compute_shader_dilate_pipeline)
				rd.compute_list_bind_uniform_set(compute_list, compute_base_uniform_set, 0)
				rd.compute_list_bind_uniform_set(compute_list, dilate_uniform_set, 1)

				for i in atlas_slices:
					rd.compute_list_set_push_constant(compute_list, push_constant, push_constant.size())
					rd.compute_list_dispatch(compute_list, group_size.x, group_size.y, group_size.z)
					# No barrier, let them run all together.

				rd.compute_list_end()
				```
			"""
    pass

  def compute_list_bind_compute_pipeline(self, compute_list:int, compute_pipeline:__core__.RID)->None:
    """
				Tells the GPU what compute pipeline to use when processing the compute list. If the shader has changed since the last time this function was called, Godot will unbind all descriptor sets and will re-bind them inside `compute_list_dispatch`.
			"""
    pass

  def compute_list_set_push_constant(self, compute_list:int, buffer:__core__.PackedByteArray, size_bytes:int)->None:
    """
				Sets the push constant data to `buffer` for the specified `compute_list`. The shader determines how this binary data is used. The buffer's size in bytes must also be specified in `size_bytes` (this can be obtained by calling the `PackedByteArray.size` method on the passed `buffer`).
			"""
    pass

  def compute_list_bind_uniform_set(self, compute_list:int, uniform_set:__core__.RID, set_index:int)->None:
    """
				Binds the `uniform_set` to this `compute_list`. Godot ensures that all textures in the uniform set have the correct Vulkan access masks. If Godot had to change access masks of textures, it will raise a Vulkan image memory barrier.
			"""
    pass

  def compute_list_dispatch(self, compute_list:int, x_groups:int, y_groups:int, z_groups:int)->None:
    """
				Submits the compute list for processing on the GPU. This is the compute equivalent to `draw_list_draw`.
			"""
    pass

  def compute_list_dispatch_indirect(self, compute_list:int, buffer:__core__.RID, offset:int)->None:
    """
				Submits the compute list for processing on the GPU with the given group counts stored in the `buffer` at `offset`. Buffer must have been created with `constant STORAGE_BUFFER_USAGE_DISPATCH_INDIRECT` flag.
			"""
    pass

  def compute_list_add_barrier(self, compute_list:int)->None:
    """
				Raises a Vulkan compute barrier in the specified `compute_list`.
			"""
    pass

  def compute_list_end(self)->None:
    """
				Finishes a list of compute commands created with the `compute_*` methods.
			"""
    pass

  def free_rid(self, rid:__core__.RID)->None:
    """
				Tries to free an object in the RenderingDevice. To avoid memory leaks, this should be called after using an object as memory management does not occur automatically when using RenderingDevice directly.
			"""
    pass

  def capture_timestamp(self, name:str)->None:
    """
				Creates a timestamp marker with the specified `name`. This is used for performance reporting with the `get_captured_timestamp_cpu_time`, `get_captured_timestamp_gpu_time` and `get_captured_timestamp_name` methods.
			"""
    pass

  def get_captured_timestamps_count(self)->int:
    """
				Returns the total number of timestamps (rendering steps) available for profiling.
			"""
    pass

  def get_captured_timestamps_frame(self)->int:
    """
				Returns the index of the last frame rendered that has rendering timestamps available for querying.
			"""
    pass

  def get_captured_timestamp_gpu_time(self, index:int)->int:
    """
				Returns the timestamp in GPU time for the rendering step specified by `index` (in microseconds since the engine started). See also `get_captured_timestamp_cpu_time` and `capture_timestamp`.
			"""
    pass

  def get_captured_timestamp_cpu_time(self, index:int)->int:
    """
				Returns the timestamp in CPU time for the rendering step specified by `index` (in microseconds since the engine started). See also `get_captured_timestamp_gpu_time` and `capture_timestamp`.
			"""
    pass

  def get_captured_timestamp_name(self, index:int)->str:
    """
				Returns the timestamp's name for the rendering step specified by `index`. See also `capture_timestamp`.
			"""
    pass

  def has_feature(self, feature:int )->bool:
    """
				Returns `true` if the `feature` is supported by the GPU.
			"""
    pass

  def limit_get(self, limit:int )->int:
    """
				Returns the value of the specified `limit`. This limit varies depending on the current graphics hardware (and sometimes the driver version). If the given limit is exceeded, rendering errors will occur.
				Limits for various graphics hardware can be found in the `url=https://vulkan.gpuinfo.org/`Vulkan Hardware Database`/url`.
			"""
    pass

  def get_frame_delay(self)->int:
    """
				Returns the frame count kept by the graphics API. Higher values result in higher input lag, but with more consistent throughput. For the main `RenderingDevice`, frames are cycled (usually 3 with triple-buffered V-Sync enabled). However, local `RenderingDevice`s only have 1 frame.
			"""
    pass

  def submit(self)->None:
    """
				Pushes the frame setup and draw command buffers then marks the local device as currently processing (which allows calling `sync`).
				**Note:** Only available in local RenderingDevices.
			"""
    pass

  def sync(self)->None:
    """
				Forces a synchronization between the CPU and GPU, which may be required in certain cases. Only call this when needed, as CPU-GPU synchronization has a performance cost.
				**Note:** Only available in local RenderingDevices.
				**Note:** `sync` can only be called after a `submit`.
			"""
    pass

  def barrier(self, from_:int=32767, to:int=32767)->None:
    """
				This method does nothing.
			"""
    pass

  def full_barrier(self)->None:
    """
				This method does nothing.
			"""
    pass

  def create_local_device(self)->__renderingdevice__.RenderingDevice:
    """
				Create a new local `RenderingDevice`. This is most useful for performing compute operations on the GPU independently from the rest of the engine.
			"""
    pass

  def set_resource_name(self, id:__core__.RID, name:str)->None:
    """
				Sets the resource name for `id` to `name`. This is used for debugging with third-party tools such as `url=https://renderdoc.org/`RenderDoc`/url`.
				The following types of resources can be named: texture, sampler, vertex buffer, index buffer, uniform buffer, texture buffer, storage buffer, uniform set buffer, shader, render pipeline and compute pipeline. Framebuffers cannot be named. Attempting to name an incompatible resource type will print an error.
				**Note:** Resource names are only set when the engine runs in verbose mode (`OS.is_stdout_verbose` = `true`), or when using an engine build compiled with the `dev_mode=yes` SCons option. The graphics driver must also support the `VK_EXT_DEBUG_UTILS_EXTENSION_NAME` Vulkan extension for named resources to work.
			"""
    pass

  def draw_command_begin_label(self, name:str, color:__core__.Color)->None:
    """
				Create a command buffer debug label region that can be displayed in third-party tools such as `url=https://renderdoc.org/`RenderDoc`/url`. All regions must be ended with a `draw_command_end_label` call. When viewed from the linear series of submissions to a single queue, calls to `draw_command_begin_label` and `draw_command_end_label` must be matched and balanced.
				The `VK_EXT_DEBUG_UTILS_EXTENSION_NAME` Vulkan extension must be available and enabled for command buffer debug label region to work. See also `draw_command_end_label`.
			"""
    pass

  def draw_command_insert_label(self, name:str, color:__core__.Color)->None:
    """
				This method does nothing.
			"""
    pass

  def draw_command_end_label(self)->None:
    """
				Ends the command buffer debug label region started by a `draw_command_begin_label` call.
			"""
    pass

  def get_device_vendor_name(self)->str:
    """
				Returns the vendor of the video adapter (e.g. "NVIDIA Corporation"). Equivalent to `RenderingServer.get_video_adapter_vendor`. See also `get_device_name`.
			"""
    pass

  def get_device_name(self)->str:
    """
				Returns the name of the video adapter (e.g. "GeForce GTX 1080/PCIe/SSE2"). Equivalent to `RenderingServer.get_video_adapter_name`. See also `get_device_vendor_name`.
			"""
    pass

  def get_device_pipeline_cache_uuid(self)->str:
    """
				Returns the universally unique identifier for the pipeline cache. This is used to cache shader files on disk, which avoids shader recompilations on subsequent engine runs. This UUID varies depending on the graphics card model, but also the driver version. Therefore, updating graphics drivers will invalidate the shader cache.
			"""
    pass

  def get_memory_usage(self, type:int )->int:
    """
				Returns the memory usage in bytes corresponding to the given `type`. When using Vulkan, these statistics are calculated by `url=https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator`Vulkan Memory Allocator`/url`.
			"""
    pass

  def get_driver_resource(self, resource:int , rid:__core__.RID, index:int)->int:
    """
				Returns the unique identifier of the driver `resource` for the specified `rid`. Some driver resource types ignore the specified `rid`. `index` is always ignored but must be specified anyway.
			"""
    pass

  def get_perf_report(self)->str:
    """
				Returns a string with a performance report from the past frame. Updates every frame.
			"""
    pass

  def get_driver_and_device_memory_report(self)->str:
    """
				Returns string report in CSV format using the following methods:
				- `get_tracked_object_name`
				- `get_tracked_object_type_count`
				- `get_driver_total_memory`
				- `get_driver_allocation_count`
				- `get_driver_memory_by_object_type`
				- `get_driver_allocs_by_object_type`
				- `get_device_total_memory`
				- `get_device_allocation_count`
				- `get_device_memory_by_object_type`
				- `get_device_allocs_by_object_type`
				This is only used by Vulkan in debug builds. Godot must also be started with the `--extra-gpu-memory-tracking` `url=$DOCS_URL/tutorials/editor/command_line_tutorial.html`command line argument`/url`.
			"""
    pass

  def get_tracked_object_name(self, type_index:int)->str:
    """
				Returns the name of the type of object for the given `type_index`. This value must be in range ``0; get_tracked_object_type_count - 1``. If `get_tracked_object_type_count` is 0, then type argument is ignored and always returns the same string.
				The return value is important because it gives meaning to the types passed to `get_driver_memory_by_object_type`, `get_driver_allocs_by_object_type`, `get_device_memory_by_object_type`, and `get_device_allocs_by_object_type`. Examples of strings it can return (not exhaustive):
				- DEVICE_MEMORY
				- PIPELINE_CACHE
				- SWAPCHAIN_KHR
				- COMMAND_POOL
				Thus if e.g. `get_tracked_object_name(5)` returns "COMMAND_POOL", then `get_device_memory_by_object_type(5)` returns the bytes used by the GPU for command pools.
				This is only used by Vulkan in debug builds. Godot must also be started with the `--extra-gpu-memory-tracking` `url=$DOCS_URL/tutorials/editor/command_line_tutorial.html`command line argument`/url`.
			"""
    pass

  def get_tracked_object_type_count(self)->int:
    """
				Returns how many types of trackable objects there are.
				This is only used by Vulkan in debug builds. Godot must also be started with the `--extra-gpu-memory-tracking` `url=$DOCS_URL/tutorials/editor/command_line_tutorial.html`command line argument`/url`.
			"""
    pass

  def get_driver_total_memory(self)->int:
    """
				Returns how much bytes the GPU driver is using for internal driver structures.
				This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
			"""
    pass

  def get_driver_allocation_count(self)->int:
    """
				Returns how many allocations the GPU driver has performed for internal driver structures.
				This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
			"""
    pass

  def get_driver_memory_by_object_type(self, type:int)->int:
    """
				Same as `get_driver_total_memory` but filtered for a given object type.
				The type argument must be in range ``0; get_tracked_object_type_count - 1``. If `get_tracked_object_type_count` is 0, then type argument is ignored and always returns 0.
				This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
			"""
    pass

  def get_driver_allocs_by_object_type(self, type:int)->int:
    """
				Same as `get_driver_allocation_count` but filtered for a given object type.
				The type argument must be in range ``0; get_tracked_object_type_count - 1``. If `get_tracked_object_type_count` is 0, then type argument is ignored and always returns 0.
				This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
			"""
    pass

  def get_device_total_memory(self)->int:
    """
				Returns how much bytes the GPU is using.
				This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
			"""
    pass

  def get_device_allocation_count(self)->int:
    """
				Returns how many allocations the GPU has performed for internal driver structures.
				This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
			"""
    pass

  def get_device_memory_by_object_type(self, type:int)->int:
    """
				Same as `get_device_total_memory` but filtered for a given object type.
				The type argument must be in range ``0; get_tracked_object_type_count - 1``. If `get_tracked_object_type_count` is 0, then type argument is ignored and always returns 0.
				This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
			"""
    pass

  def get_device_allocs_by_object_type(self, type:int)->int:
    """
				Same as `get_device_allocation_count` but filtered for a given object type.
				The type argument must be in range ``0; get_tracked_object_type_count - 1``. If `get_tracked_object_type_count` is 0, then type argument is ignored and always returns 0.
				This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
			"""
    pass


