from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.HashingContext as __hashingcontext__
import py4godot.classes.RefCounted as __refcounted__



class HMACContext(__refcounted__.RefCounted):
  """
		The HMACContext class is useful for advanced HMAC use cases, such as streaming the message as it supports creating the message over time rather than providing it all at once.
		
		```gdscript
		extends Node
		var ctx = HMACContext.new()

		func _ready():
			var key = "supersecret".to_utf8_buffer()
			var err = ctx.start(HashingContext.HASH_SHA256, key)
			assert(err == OK)
			var msg1 = "this is ".to_utf8_buffer()
			var msg2 = "super duper secret".to_utf8_buffer()
			err = ctx.update(msg1)
			assert(err == OK)
			err = ctx.update(msg2)
			assert(err == OK)
			var hmac = ctx.finish()
			print(hmac.hex_encode())

		```
		
		
	"""

  @staticmethod
  def constructor()->HMACContext:pass



  @staticmethod
  def cast(other:__object__.Object)->HMACContext:pass


  def start(self, hash_type:int , key:__core__.PackedByteArray)->int:
    """
				Initializes the HMACContext. This method cannot be called again on the same HMACContext until `finish` has been called.
			"""
    pass

  def update(self, data:__core__.PackedByteArray)->int:
    """
				Updates the message to be HMACed. This can be called multiple times before `finish` is called to append `data` to the message, but cannot be called until `start` has been called.
			"""
    pass

  def finish(self)->__core__.PackedByteArray:
    """
				Returns the resulting HMAC. If the HMAC failed, an empty `PackedByteArray` is returned.
			"""
    pass


