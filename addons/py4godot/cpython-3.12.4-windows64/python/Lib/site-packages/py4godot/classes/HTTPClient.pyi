from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.HTTPClient as __httpclient__
import py4godot.classes.StreamPeerExtension as __streampeerextension__
import py4godot.classes.TLSOptions as __tlsoptions__
import py4godot.classes.StreamPeerBuffer as __streampeerbuffer__
import py4godot.classes.RefCounted as __refcounted__
import py4godot.classes.StreamPeerTCP as __streampeertcp__
import py4godot.classes.StreamPeerGZIP as __streampeergzip__
import py4godot.classes.StreamPeer as __streampeer__
import py4godot.classes.StreamPeerTLS as __streampeertls__


class Method:
  METHOD_GET:int = 0
  METHOD_HEAD:int = 1
  METHOD_POST:int = 2
  METHOD_PUT:int = 3
  METHOD_DELETE:int = 4
  METHOD_OPTIONS:int = 5
  METHOD_TRACE:int = 6
  METHOD_CONNECT:int = 7
  METHOD_PATCH:int = 8
  METHOD_MAX:int = 9
class Status:
  STATUS_DISCONNECTED:int = 0
  STATUS_RESOLVING:int = 1
  STATUS_CANT_RESOLVE:int = 2
  STATUS_CONNECTING:int = 3
  STATUS_CANT_CONNECT:int = 4
  STATUS_CONNECTED:int = 5
  STATUS_REQUESTING:int = 6
  STATUS_BODY:int = 7
  STATUS_CONNECTION_ERROR:int = 8
  STATUS_TLS_HANDSHAKE_ERROR:int = 9
class ResponseCode:
  RESPONSE_CONTINUE:int = 100
  RESPONSE_SWITCHING_PROTOCOLS:int = 101
  RESPONSE_PROCESSING:int = 102
  RESPONSE_OK:int = 200
  RESPONSE_CREATED:int = 201
  RESPONSE_ACCEPTED:int = 202
  RESPONSE_NON_AUTHORITATIVE_INFORMATION:int = 203
  RESPONSE_NO_CONTENT:int = 204
  RESPONSE_RESET_CONTENT:int = 205
  RESPONSE_PARTIAL_CONTENT:int = 206
  RESPONSE_MULTI_STATUS:int = 207
  RESPONSE_ALREADY_REPORTED:int = 208
  RESPONSE_IM_USED:int = 226
  RESPONSE_MULTIPLE_CHOICES:int = 300
  RESPONSE_MOVED_PERMANENTLY:int = 301
  RESPONSE_FOUND:int = 302
  RESPONSE_SEE_OTHER:int = 303
  RESPONSE_NOT_MODIFIED:int = 304
  RESPONSE_USE_PROXY:int = 305
  RESPONSE_SWITCH_PROXY:int = 306
  RESPONSE_TEMPORARY_REDIRECT:int = 307
  RESPONSE_PERMANENT_REDIRECT:int = 308
  RESPONSE_BAD_REQUEST:int = 400
  RESPONSE_UNAUTHORIZED:int = 401
  RESPONSE_PAYMENT_REQUIRED:int = 402
  RESPONSE_FORBIDDEN:int = 403
  RESPONSE_NOT_FOUND:int = 404
  RESPONSE_METHOD_NOT_ALLOWED:int = 405
  RESPONSE_NOT_ACCEPTABLE:int = 406
  RESPONSE_PROXY_AUTHENTICATION_REQUIRED:int = 407
  RESPONSE_REQUEST_TIMEOUT:int = 408
  RESPONSE_CONFLICT:int = 409
  RESPONSE_GONE:int = 410
  RESPONSE_LENGTH_REQUIRED:int = 411
  RESPONSE_PRECONDITION_FAILED:int = 412
  RESPONSE_REQUEST_ENTITY_TOO_LARGE:int = 413
  RESPONSE_REQUEST_URI_TOO_LONG:int = 414
  RESPONSE_UNSUPPORTED_MEDIA_TYPE:int = 415
  RESPONSE_REQUESTED_RANGE_NOT_SATISFIABLE:int = 416
  RESPONSE_EXPECTATION_FAILED:int = 417
  RESPONSE_IM_A_TEAPOT:int = 418
  RESPONSE_MISDIRECTED_REQUEST:int = 421
  RESPONSE_UNPROCESSABLE_ENTITY:int = 422
  RESPONSE_LOCKED:int = 423
  RESPONSE_FAILED_DEPENDENCY:int = 424
  RESPONSE_UPGRADE_REQUIRED:int = 426
  RESPONSE_PRECONDITION_REQUIRED:int = 428
  RESPONSE_TOO_MANY_REQUESTS:int = 429
  RESPONSE_REQUEST_HEADER_FIELDS_TOO_LARGE:int = 431
  RESPONSE_UNAVAILABLE_FOR_LEGAL_REASONS:int = 451
  RESPONSE_INTERNAL_SERVER_ERROR:int = 500
  RESPONSE_NOT_IMPLEMENTED:int = 501
  RESPONSE_BAD_GATEWAY:int = 502
  RESPONSE_SERVICE_UNAVAILABLE:int = 503
  RESPONSE_GATEWAY_TIMEOUT:int = 504
  RESPONSE_HTTP_VERSION_NOT_SUPPORTED:int = 505
  RESPONSE_VARIANT_ALSO_NEGOTIATES:int = 506
  RESPONSE_INSUFFICIENT_STORAGE:int = 507
  RESPONSE_LOOPERATOR_DETECTED:int = 508
  RESPONSE_NOT_EXTENDED:int = 510
  RESPONSE_NETWORK_AUTH_REQUIRED:int = 511


class HTTPClient(__refcounted__.RefCounted):
  """
		Hyper-text transfer protocol client (sometimes called "User Agent"). Used to make HTTP requests to download web content, upload files and other data or to communicate with various services, among other use cases.
		See the `HTTPRequest` node for a higher-level alternative.
		**Note:** This client only needs to connect to a host once (see `connect_to_host`) to send multiple requests. Because of this, methods that take URLs usually take just the part after the host instead of the full URL, as the client is already connected to a host. See `request` for a full example and to get started.
		An `HTTPClient` should be reused between multiple requests or to connect to different hosts instead of creating one client per request. Supports Transport Layer Security (TLS), including server certificate verification. HTTP status codes in the 2xx range indicate success, 3xx redirection (i.e. "try again, but over here"), 4xx something was wrong with the request, and 5xx something went wrong on the server's side.
		For more information on HTTP, see `url=https://developer.mozilla.org/en-US/docs/Web/HTTP`MDN's documentation on HTTP`/url` (or read `url=https://tools.ietf.org/html/rfc2616`RFC 2616`/url` to get it straight from the source).
		**Note:** When exporting to Android, make sure to enable the `INTERNET` permission in the Android export preset before exporting the project or using one-click deploy. Otherwise, network communication of any kind will be blocked by Android.
		**Note:** It's recommended to use transport encryption (TLS) and to avoid sending sensitive information (such as login credentials) in HTTP GET URL parameters. Consider using HTTP POST requests or HTTP headers for such information instead.
		**Note:** When performing HTTP requests from a project exported to Web, keep in mind the remote server may not allow requests from foreign origins due to `url=https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS`CORS`/url`. If you host the server in question, you should modify its backend to allow requests from foreign origins by adding the `Access-Control-Allow-Origin: *` HTTP header.
		**Note:** TLS support is currently limited to TLSv1.2 and TLSv1.3. Attempting to connect to a server that only supports older (insecure) TLS versions will return an error.
		**Warning:** TLS certificate revocation and certificate pinning are currently not supported. Revoked certificates are accepted as long as they are otherwise valid. If this is a concern, you may want to use automatically managed certificates with a short validity period.
	"""

  @staticmethod
  def constructor()->HTTPClient:pass



  @staticmethod
  def cast(other:__object__.Object)->HTTPClient:pass


  @property
  def blocking_mode_enabled(self)->bool:
    """"""
    pass
  @blocking_mode_enabled.setter
  def blocking_mode_enabled(self,  value:bool)->None:
    """"""
    pass
  @property
  def connection(self)->__streampeertcp__.StreamPeerTCP|__streampeergzip__.StreamPeerGZIP|__streampeertls__.StreamPeerTLS|__streampeer__.StreamPeer|__streampeerextension__.StreamPeerExtension|__streampeerbuffer__.StreamPeerBuffer:
    """"""
    pass
  @connection.setter
  def connection(self,  value:__streampeer__.StreamPeer)->None:
    """"""
    pass
  @property
  def read_chunk_size(self)->int:
    """"""
    pass
  @read_chunk_size.setter
  def read_chunk_size(self,  value:int)->None:
    """"""
    pass
  def connect_to_host(self, host:str, port:int=-1, tls_options:__tlsoptions__.TLSOptions= __tlsoptions__.TLSOptions.constructor())->int:
    """
				Connects to a host. This needs to be done before any requests are sent.
				If no `port` is specified (or `-1` is used), it is automatically set to 80 for HTTP and 443 for HTTPS. You can pass the optional `tls_options` parameter to customize the trusted certification authorities, or the common name verification when using HTTPS. See `TLSOptions.client` and `TLSOptions.client_unsafe`.
			"""
    pass

  def set_connection(self, connection:__streampeer__.StreamPeer)->None:
    """"""
    pass

  def get_connection(self)->__streampeertcp__.StreamPeerTCP|__streampeergzip__.StreamPeerGZIP|__streampeertls__.StreamPeerTLS|__streampeer__.StreamPeer|__streampeerextension__.StreamPeerExtension|__streampeerbuffer__.StreamPeerBuffer:
    """"""
    pass

  def request_raw(self, method:int , url:str, headers:__core__.PackedStringArray, body:__core__.PackedByteArray)->int:
    """
				Sends a raw HTTP request to the connected host with the given `method`.
				The URL parameter is usually just the part after the host, so for `https://example.com/index.php`, it is `/index.php`. When sending requests to an HTTP proxy server, it should be an absolute URL. For `constant HTTPClient.METHOD_OPTIONS` requests, `*` is also allowed. For `constant HTTPClient.METHOD_CONNECT` requests, it should be the authority component (`host:port`).
				`headers` are HTTP request headers.
				Sends the body data raw, as a byte array and does not encode it in any way.
			"""
    pass

  def request(self, method:int , url:str, headers:__core__.PackedStringArray, body:str= __core__.String.new0())->int:
    """
				Sends an HTTP request to the connected host with the given `method`.
				The URL parameter is usually just the part after the host, so for `https://example.com/index.php`, it is `/index.php`. When sending requests to an HTTP proxy server, it should be an absolute URL. For `constant HTTPClient.METHOD_OPTIONS` requests, `*` is also allowed. For `constant HTTPClient.METHOD_CONNECT` requests, it should be the authority component (`host:port`).
				`headers` are HTTP request headers.
				To create a POST request with query strings to push to the server, do:
				
				```gdscript
				var fields = { "username": "user", "password": "pass" }
				var query_string = http_client.query_string_from_dict(fields)
				var headers = `"Content-Type: application/x-www-form-urlencoded", "Content-Length: " + str(query_string.length())`
				var result = http_client.request(http_client.METHOD_POST, "/index.php", headers, query_string)
				```
				
				
				**Note:** The `body` parameter is ignored if `method` is `constant HTTPClient.METHOD_GET`. This is because GET methods can't contain request data. As a workaround, you can pass request data as a query string in the URL. See `String.uri_encode` for an example.
			"""
    pass

  def close(self)->None:
    """
				Closes the current connection, allowing reuse of this `HTTPClient`.
			"""
    pass

  def has_response(self)->bool:
    """
				If `true`, this `HTTPClient` has a response available.
			"""
    pass

  def is_response_chunked(self)->bool:
    """
				If `true`, this `HTTPClient` has a response that is chunked.
			"""
    pass

  def get_response_code(self)->int:
    """
				Returns the response's HTTP status code.
			"""
    pass

  def get_response_headers(self)->__core__.PackedStringArray:
    """
				Returns the response headers.
			"""
    pass

  def get_response_headers_as_dictionary(self)->__core__.Dictionary:
    """
				Returns all response headers as a `Dictionary`. Each entry is composed by the header name, and a `String` containing the values separated by `"; "`. The casing is kept the same as the headers were received.
				```gdscript
				{
					"content-length": 12,
					"Content-Type": "application/json; charset=UTF-8",
				}
				```
			"""
    pass

  def get_response_body_length(self)->int:
    """
				Returns the response's body length.
				**Note:** Some Web servers may not send a body length. In this case, the value returned will be `-1`. If using chunked transfer encoding, the body length will also be `-1`.
				**Note:** This function always returns `-1` on the Web platform due to browsers limitations.
			"""
    pass

  def read_response_body_chunk(self)->__core__.PackedByteArray:
    """
				Reads one chunk from the response.
			"""
    pass

  def set_read_chunk_size(self, bytes:int)->None:
    """"""
    pass

  def get_read_chunk_size(self)->int:
    """"""
    pass

  def set_blocking_mode(self, enabled:bool)->None:
    """"""
    pass

  def is_blocking_mode_enabled(self)->bool:
    """"""
    pass

  def get_status(self)->int:
    """
				Returns a `enum Status` constant. Need to call `poll` in order to get status updates.
			"""
    pass

  def poll(self)->int:
    """
				This needs to be called in order to have any request processed. Check results with `get_status`.
			"""
    pass

  def set_http_proxy(self, host:str, port:int)->None:
    """
				Sets the proxy server for HTTP requests.
				The proxy server is unset if `host` is empty or `port` is -1.
			"""
    pass

  def set_https_proxy(self, host:str, port:int)->None:
    """
				Sets the proxy server for HTTPS requests.
				The proxy server is unset if `host` is empty or `port` is -1.
			"""
    pass

  def query_string_from_dict(self, fields:__core__.Dictionary)->str:
    """
				Generates a GET/POST application/x-www-form-urlencoded style query string from a provided dictionary, e.g.:
				
				```gdscript
				var fields = { "username": "user", "password": "pass" }
				var query_string = http_client.query_string_from_dict(fields)
				# Returns "username=user&password=pass"
				```
				
				
				Furthermore, if a key has a `null` value, only the key itself is added, without equal sign and value. If the value is an array, for each value in it a pair with the same key is added.
				
				```gdscript
				var fields = { "single": 123, "not_valued": null, "multiple": `22, 33, 44` }
				var query_string = http_client.query_string_from_dict(fields)
				# Returns "single=123&not_valued&multiple=22&multiple=33&multiple=44"
				```
				
				
			"""
    pass


