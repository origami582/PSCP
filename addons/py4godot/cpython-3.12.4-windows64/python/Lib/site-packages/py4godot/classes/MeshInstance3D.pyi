from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.ShaderMaterial as __shadermaterial__
import py4godot.classes.MeshConvexDecompositionSettings as __meshconvexdecompositionsettings__
import py4godot.classes.CapsuleMesh as __capsulemesh__
import py4godot.classes.PlaceholderMesh as __placeholdermesh__
import py4godot.classes.GeometryInstance3D as __geometryinstance3d__
import py4godot.classes.Mesh as __mesh__
import py4godot.classes.BoxMesh as __boxmesh__
import py4godot.classes.Skin as __skin__
import py4godot.classes.ParticleProcessMaterial as __particleprocessmaterial__
import py4godot.classes.ProceduralSkyMaterial as __proceduralskymaterial__
import py4godot.classes.SphereMesh as __spheremesh__
import py4godot.classes.SkinReference as __skinreference__
import py4godot.classes.ArrayMesh as __arraymesh__
import py4godot.classes.ImmediateMesh as __immediatemesh__
import py4godot.classes.TextMesh as __textmesh__
import py4godot.classes.StandardMaterial3D as __standardmaterial3d__
import py4godot.classes.PanoramaSkyMaterial as __panoramaskymaterial__
import py4godot.classes.Material as __material__
import py4godot.classes.QuadMesh as __quadmesh__
import py4godot.classes.PlaceholderMaterial as __placeholdermaterial__
import py4godot.classes.PrismMesh as __prismmesh__
import py4godot.classes.PointMesh as __pointmesh__
import py4godot.classes.CylinderMesh as __cylindermesh__
import py4godot.classes.PhysicalSkyMaterial as __physicalskymaterial__
import py4godot.classes.PrimitiveMesh as __primitivemesh__
import py4godot.classes.CanvasItemMaterial as __canvasitemmaterial__
import py4godot.classes.FogMaterial as __fogmaterial__
import py4godot.classes.TubeTrailMesh as __tubetrailmesh__
import py4godot.classes.PlaneMesh as __planemesh__
import py4godot.classes.BaseMaterial3D as __basematerial3d__
import py4godot.classes.TorusMesh as __torusmesh__
import py4godot.classes.ORMMaterial3D as __ormmaterial3d__
import py4godot.classes.RibbonTrailMesh as __ribbontrailmesh__



class MeshInstance3D(__geometryinstance3d__.GeometryInstance3D):
  """
		MeshInstance3D is a node that takes a `Mesh` resource and adds it to the current scenario by creating an instance of it. This is the class most often used to render 3D geometry and can be used to instance a single `Mesh` in many places. This allows reusing geometry, which can save on resources. When a `Mesh` has to be instantiated more than thousands of times at close proximity, consider using a `MultiMesh` in a `MultiMeshInstance3D` instead.
	"""

  @staticmethod
  def constructor()->MeshInstance3D:pass



  @staticmethod
  def cast(other:__object__.Object)->MeshInstance3D:pass


  @property
  def mesh(self)->__quadmesh__.QuadMesh|__capsulemesh__.CapsuleMesh|__prismmesh__.PrismMesh|__pointmesh__.PointMesh|__placeholdermesh__.PlaceholderMesh|__mesh__.Mesh|__boxmesh__.BoxMesh|__cylindermesh__.CylinderMesh|__primitivemesh__.PrimitiveMesh|__spheremesh__.SphereMesh|__arraymesh__.ArrayMesh|__tubetrailmesh__.TubeTrailMesh|__planemesh__.PlaneMesh|__immediatemesh__.ImmediateMesh|__torusmesh__.TorusMesh|__textmesh__.TextMesh|__ribbontrailmesh__.RibbonTrailMesh:
    """"""
    pass
  @mesh.setter
  def mesh(self,  value:__mesh__.Mesh)->None:
    """"""
    pass
  @property
  def skin(self)->__skin__.Skin:
    """"""
    pass
  @skin.setter
  def skin(self,  value:__skin__.Skin)->None:
    """"""
    pass
  @property
  def skeleton(self)->__core__.NodePath:
    """"""
    pass
  @skeleton.setter
  def skeleton(self,  value:__core__.NodePath)->None:
    """"""
    pass
  def set_mesh(self, mesh:__mesh__.Mesh)->None:
    """"""
    pass

  def get_mesh(self)->__quadmesh__.QuadMesh|__capsulemesh__.CapsuleMesh|__prismmesh__.PrismMesh|__pointmesh__.PointMesh|__placeholdermesh__.PlaceholderMesh|__mesh__.Mesh|__boxmesh__.BoxMesh|__cylindermesh__.CylinderMesh|__primitivemesh__.PrimitiveMesh|__spheremesh__.SphereMesh|__arraymesh__.ArrayMesh|__tubetrailmesh__.TubeTrailMesh|__planemesh__.PlaneMesh|__immediatemesh__.ImmediateMesh|__torusmesh__.TorusMesh|__textmesh__.TextMesh|__ribbontrailmesh__.RibbonTrailMesh:
    """"""
    pass

  def set_skeleton_path(self, skeleton_path:__core__.NodePath|str)->None:
    """"""
    pass

  def get_skeleton_path(self)->__core__.NodePath:
    """"""
    pass

  def set_skin(self, skin:__skin__.Skin)->None:
    """"""
    pass

  def get_skin(self)->__skin__.Skin:
    """"""
    pass

  def get_skin_reference(self)->__skinreference__.SkinReference:
    """
				Returns the internal `SkinReference` containing the skeleton's `RID` attached to this RID. See also `Resource.get_rid`, `SkinReference.get_skeleton`, and `RenderingServer.instance_attach_skeleton`.
			"""
    pass

  def get_surface_override_material_count(self)->int:
    """
				Returns the number of surface override materials. This is equivalent to `Mesh.get_surface_count`. See also `get_surface_override_material`.
			"""
    pass

  def set_surface_override_material(self, surface:int, material:__material__.Material)->None:
    """
				Sets the override `material` for the specified `surface` of the `Mesh` resource. This material is associated with this `MeshInstance3D` rather than with `mesh`.
				**Note:** This assigns the `Material` associated to the `MeshInstance3D`'s Surface Material Override properties, not the material within the `Mesh` resource. To set the material within the `Mesh` resource, use `Mesh.surface_set_material` instead.
			"""
    pass

  def get_surface_override_material(self, surface:int)->__physicalskymaterial__.PhysicalSkyMaterial|__shadermaterial__.ShaderMaterial|__canvasitemmaterial__.CanvasItemMaterial|__material__.Material|__particleprocessmaterial__.ParticleProcessMaterial|__proceduralskymaterial__.ProceduralSkyMaterial|__fogmaterial__.FogMaterial|__basematerial3d__.BaseMaterial3D|__placeholdermaterial__.PlaceholderMaterial|__ormmaterial3d__.ORMMaterial3D|__standardmaterial3d__.StandardMaterial3D|__panoramaskymaterial__.PanoramaSkyMaterial:
    """
				Returns the override `Material` for the specified `surface` of the `Mesh` resource. See also `get_surface_override_material_count`.
				**Note:** This returns the `Material` associated to the `MeshInstance3D`'s Surface Material Override properties, not the material within the `Mesh` resource. To get the material within the `Mesh` resource, use `Mesh.surface_get_material` instead.
			"""
    pass

  def get_active_material(self, surface:int)->__physicalskymaterial__.PhysicalSkyMaterial|__shadermaterial__.ShaderMaterial|__canvasitemmaterial__.CanvasItemMaterial|__material__.Material|__particleprocessmaterial__.ParticleProcessMaterial|__proceduralskymaterial__.ProceduralSkyMaterial|__fogmaterial__.FogMaterial|__basematerial3d__.BaseMaterial3D|__placeholdermaterial__.PlaceholderMaterial|__ormmaterial3d__.ORMMaterial3D|__standardmaterial3d__.StandardMaterial3D|__panoramaskymaterial__.PanoramaSkyMaterial:
    """
				Returns the `Material` that will be used by the `Mesh` when drawing. This can return the `GeometryInstance3D.material_override`, the surface override `Material` defined in this `MeshInstance3D`, or the surface `Material` defined in the `mesh`. For example, if `GeometryInstance3D.material_override` is used, all surfaces will return the override material.
				Returns `null` if no material is active, including when `mesh` is `null`.
			"""
    pass

  def create_trimesh_collision(self)->None:
    """
				This helper creates a `StaticBody3D` child node with a `ConcavePolygonShape3D` collision shape calculated from the mesh geometry. It's mainly used for testing.
			"""
    pass

  def create_convex_collision(self, clean:bool=True, simplify:bool=False)->None:
    """
				This helper creates a `StaticBody3D` child node with a `ConvexPolygonShape3D` collision shape calculated from the mesh geometry. It's mainly used for testing.
				If `clean` is `true` (default), duplicate and interior vertices are removed automatically. You can set it to `false` to make the process faster if not needed.
				If `simplify` is `true`, the geometry can be further simplified to reduce the number of vertices. Disabled by default.
			"""
    pass

  def create_multiple_convex_collisions(self, settings:__meshconvexdecompositionsettings__.MeshConvexDecompositionSettings= __meshconvexdecompositionsettings__.MeshConvexDecompositionSettings.constructor())->None:
    """
				This helper creates a `StaticBody3D` child node with multiple `ConvexPolygonShape3D` collision shapes calculated from the mesh geometry via convex decomposition. The convex decomposition operation can be controlled with parameters from the optional `settings`.
			"""
    pass

  def get_blend_shape_count(self)->int:
    """
				Returns the number of blend shapes available. Produces an error if `mesh` is `null`.
			"""
    pass

  def find_blend_shape_by_name(self, name:__core__.StringName|str)->int:
    """
				Returns the index of the blend shape with the given `name`. Returns `-1` if no blend shape with this name exists, including when `mesh` is `null`.
			"""
    pass

  def get_blend_shape_value(self, blend_shape_idx:int)->float:
    """
				Returns the value of the blend shape at the given `blend_shape_idx`. Returns `0.0` and produces an error if `mesh` is `null` or doesn't have a blend shape at that index.
			"""
    pass

  def set_blend_shape_value(self, blend_shape_idx:int, value:float)->None:
    """
				Sets the value of the blend shape at `blend_shape_idx` to `value`. Produces an error if `mesh` is `null` or doesn't have a blend shape at that index.
			"""
    pass

  def create_debug_tangents(self)->None:
    """
				This helper creates a `MeshInstance3D` child node with gizmos at every vertex calculated from the mesh geometry. It's mainly used for testing.
			"""
    pass

  def bake_mesh_from_current_blend_shape_mix(self, existing:__arraymesh__.ArrayMesh= __arraymesh__.ArrayMesh.constructor())->__arraymesh__.ArrayMesh:
    """
				Takes a snapshot from the current `ArrayMesh` with all blend shapes applied according to their current weights and bakes it to the provided `existing` mesh. If no `existing` mesh is provided a new `ArrayMesh` is created, baked and returned. Mesh surface materials are not copied.
				**Performance:** `Mesh` data needs to be received from the GPU, stalling the `RenderingServer` in the process.
			"""
    pass

  def bake_mesh_from_current_skeleton_pose(self, existing:__arraymesh__.ArrayMesh= __arraymesh__.ArrayMesh.constructor())->__arraymesh__.ArrayMesh:
    """
				Takes a snapshot of the current animated skeleton pose of the skinned mesh and bakes it to the provided `existing` mesh. If no `existing` mesh is provided a new `ArrayMesh` is created, baked, and returned. Requires a skeleton with a registered skin to work. Blendshapes are ignored. Mesh surface materials are not copied.
				**Performance:** `Mesh` data needs to be retrieved from the GPU, stalling the `RenderingServer` in the process.
			"""
    pass


