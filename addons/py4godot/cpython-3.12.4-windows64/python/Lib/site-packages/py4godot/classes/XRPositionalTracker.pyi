from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.XRPose as __xrpose__
import py4godot.classes.XRPositionalTracker as __xrpositionaltracker__
import py4godot.classes.XRTracker as __xrtracker__
import py4godot.classes.XRHandTracker as __xrhandtracker__
import py4godot.classes.XRControllerTracker as __xrcontrollertracker__
import py4godot.classes.XRBodyTracker as __xrbodytracker__


class TrackerHand:
  TRACKER_HAND_UNKNOWN:int = 0
  TRACKER_HAND_LEFT:int = 1
  TRACKER_HAND_RIGHT:int = 2
  TRACKER_HAND_MAX:int = 3


class XRPositionalTracker(__xrtracker__.XRTracker):
  """
		An instance of this object represents a device that is tracked, such as a controller or anchor point. HMDs aren't represented here as they are handled internally.
		As controllers are turned on and the `XRInterface` detects them, instances of this object are automatically added to this list of active tracking objects accessible through the `XRServer`.
		The `XRNode3D` and `XRAnchor3D` both consume objects of this type and should be used in your project. The positional trackers are just under-the-hood objects that make this all work. These are mostly exposed so that GDExtension-based interfaces can interact with them.
	"""
  pose_changed: BuiltinSignal
  pose_lost_tracking: BuiltinSignal
  button_pressed: BuiltinSignal
  button_released: BuiltinSignal
  input_float_changed: BuiltinSignal
  input_vector2_changed: BuiltinSignal
  profile_changed: BuiltinSignal

  @staticmethod
  def constructor()->XRPositionalTracker:pass



  @staticmethod
  def cast(other:__object__.Object)->XRPositionalTracker:pass


  @property
  def profile(self)->str:
    """"""
    pass
  @profile.setter
  def profile(self,  value:str)->None:
    """"""
    pass
  @property
  def hand(self)->int:
    """"""
    pass
  @hand.setter
  def hand(self,  value:int)->None:
    """"""
    pass
  def get_tracker_profile(self)->str:
    """"""
    pass

  def set_tracker_profile(self, profile:str)->None:
    """"""
    pass

  def get_tracker_hand(self)->int:
    """"""
    pass

  def set_tracker_hand(self, hand:int )->None:
    """"""
    pass

  def has_pose(self, name:__core__.StringName|str)->bool:
    """
				Returns `true` if the tracker is available and is currently tracking the bound `name` pose.
			"""
    pass

  def get_pose(self, name:__core__.StringName|str)->__xrpose__.XRPose:
    """
				Returns the current `XRPose` state object for the bound `name` pose.
			"""
    pass

  def invalidate_pose(self, name:__core__.StringName|str)->None:
    """
				Marks this pose as invalid, we don't clear the last reported state but it allows users to decide if trackers need to be hidden if we lose tracking or just remain at their last known position.
			"""
    pass

  def set_pose(self, name:__core__.StringName|str, transform:__core__.Transform3D, linear_velocity:__core__.Vector3, angular_velocity:__core__.Vector3, tracking_confidence:int )->None:
    """
				Sets the transform, linear velocity, angular velocity and tracking confidence for the given pose. This method is called by an `XRInterface` implementation and should not be used directly.
			"""
    pass

  def get_input(self, name:__core__.StringName|str)->Any:
    """
				Returns an input for this tracker. It can return a boolean, float or `Vector2` value depending on whether the input is a button, trigger or thumbstick/thumbpad.
			"""
    pass

  def set_input(self, name:__core__.StringName|str, value:Any)->None:
    """
				Changes the value for the given input. This method is called by an `XRInterface` implementation and should not be used directly.
			"""
    pass


