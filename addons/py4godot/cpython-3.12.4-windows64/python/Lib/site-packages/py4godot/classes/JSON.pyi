from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.Resource as __resource__



class JSON(__resource__.Resource):
  """
		The `JSON` class enables all data types to be converted to and from a JSON string. This is useful for serializing data, e.g. to save to a file or send over the network.
		`stringify` is used to convert any data type into a JSON string.
		`parse` is used to convert any existing JSON data into a `Variant` that can be used within Godot. If successfully parsed, use `data` to retrieve the `Variant`, and use `@GlobalScope.typeof` to check if the Variant's type is what you expect. JSON Objects are converted into a `Dictionary`, but JSON data can be used to store `Array`s, numbers, `String`s and even just a boolean.
		```gdscript
		var data_to_send = `"a", "b", "c"`
		var json_string = JSON.stringify(data_to_send)
		# Save data
		# ...
		# Retrieve data
		var json = JSON.new()
		var error = json.parse(json_string)
		if error == OK:
			var data_received = json.data
			if typeof(data_received) == TYPE_ARRAY:
				print(data_received) # Prints the array.
			else:
				print("Unexpected data")
		else:
			print("JSON Parse Error: ", json.get_error_message(), " in ", json_string, " at line ", json.get_error_line())
		```
		Alternatively, you can parse strings using the static `parse_string` method, but it doesn't handle errors.
		```gdscript
		var data = JSON.parse_string(json_string) # Returns null if parsing failed.
		```
		**Note:** Both parse methods do not fully comply with the JSON specification:
		- Trailing commas in arrays or objects are ignored, instead of causing a parser error.
		- New line and tab characters are accepted in string literals, and are treated like their corresponding escape sequences `\n` and `\t`.
		- Numbers are parsed using `String.to_float` which is generally more lax than the JSON specification.
		- Certain errors, such as invalid Unicode sequences, do not cause a parser error. Instead, the string is cleaned up and an error is logged to the console.
	"""

  @staticmethod
  def constructor()->JSON:pass



  @staticmethod
  def cast(other:__object__.Object)->JSON:pass


  @property
  def data(self)->Any:
    """"""
    pass
  @data.setter
  def data(self,  value:Any)->None:
    """"""
    pass
  @staticmethod
  def stringify(data:Any, indent:str= __core__.String.new0(), sort_keys:bool=True, full_precision:bool=False)->str:
    """
				Converts a `Variant` var to JSON text and returns the result. Useful for serializing data to store or send over the network.
				**Note:** The JSON specification does not define integer or float types, but only a _number_ type. Therefore, converting a Variant to JSON text will convert all numerical values to `float` types.
				**Note:** If `full_precision` is `true`, when stringifying floats, the unreliable digits are stringified in addition to the reliable digits to guarantee exact decoding.
				The `indent` parameter controls if and how something is indented; its contents will be used where there should be an indent in the output. Even spaces like `"   "` will work. `\t` and `\n` can also be used for a tab indent, or to make a newline for each indent respectively.
				**Example output:**
				```gdscript
				## JSON.stringify(my_dictionary)
				{"name":"my_dictionary","version":"1.0.0","entities":`{"name":"entity_0","value":"value_0"},{"name":"entity_1","value":"value_1"}`}

				## JSON.stringify(my_dictionary, "\t")
				{
					"name": "my_dictionary",
					"version": "1.0.0",
					"entities": `
						{
							"name": "entity_0",
							"value": "value_0"
						},
						{
							"name": "entity_1",
							"value": "value_1"
						}
					`
				}

				## JSON.stringify(my_dictionary, "...")
				{
				..."name": "my_dictionary",
				..."version": "1.0.0",
				..."entities": `
				......{
				........."name": "entity_0",
				........."value": "value_0"
				......},
				......{
				........."name": "entity_1",
				........."value": "value_1"
				......}
				...`
				}
				```
			"""
    pass

  @staticmethod
  def parse_string(json_string:str)->Any:
    """
				Attempts to parse the `json_string` provided and returns the parsed data. Returns `null` if parse failed.
			"""
    pass

  def parse(self, json_text:str, keep_text:bool=False)->int:
    """
				Attempts to parse the `json_text` provided.
				Returns an `enum Error`. If the parse was successful, it returns `constant OK` and the result can be retrieved using `data`. If unsuccessful, use `get_error_line` and `get_error_message` to identify the source of the failure.
				Non-static variant of `parse_string`, if you want custom error handling.
				The optional `keep_text` argument instructs the parser to keep a copy of the original text. This text can be obtained later by using the `get_parsed_text` function and is used when saving the resource (instead of generating new text from `data`).
			"""
    pass

  def get_data(self)->Any:
    """"""
    pass

  def set_data(self, data:Any)->None:
    """"""
    pass

  def get_parsed_text(self)->str:
    """
				Return the text parsed by `parse` (requires passing `keep_text` to `parse`).
			"""
    pass

  def get_error_line(self)->int:
    """
				Returns `0` if the last call to `parse` was successful, or the line number where the parse failed.
			"""
    pass

  def get_error_message(self)->str:
    """
				Returns an empty string if the last call to `parse` was successful, or the error message if it failed.
			"""
    pass

  @staticmethod
  def from_native(variant:Any, full_objects:bool=False)->Any:
    """
				Converts a native engine type to a JSON-compliant value.
				By default, objects are ignored for security reasons, unless `full_objects` is `true`.
				You can convert a native value to a JSON string like this:
				```gdscript
				func encode_data(value, full_objects = false):
					return JSON.stringify(JSON.from_native(value, full_objects))
				```
			"""
    pass

  @staticmethod
  def to_native(json:Any, allow_objects:bool=False)->Any:
    """
				Converts a JSON-compliant value that was created with `from_native` back to native engine types.
				By default, objects are ignored for security reasons, unless `allow_objects` is `true`.
				You can convert a JSON string back to a native value like this:
				```gdscript
				func decode_data(string, allow_objects = false):
					return JSON.to_native(JSON.parse_string(string), allow_objects)
				```
			"""
    pass


