from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.n as __n__
import py4godot.classes.T as __t__
import py4godot.classes.CapsuleMesh as __capsulemesh__
import py4godot.classes.SurfaceTool as __surfacetool__
import py4godot.classes.PlaceholderMesh as __placeholdermesh__
import py4godot.classes.Mesh as __mesh__
import py4godot.classes.BoxMesh as __boxmesh__
import py4godot.classes.e as __e__
import py4godot.classes.SphereMesh as __spheremesh__
import py4godot.classes.ArrayMesh as __arraymesh__
import py4godot.classes.l as __l__
import py4godot.classes.RefCounted as __refcounted__
import py4godot.classes.ImmediateMesh as __immediatemesh__
import py4godot.classes.p as __p__
import py4godot.classes.TextMesh as __textmesh__
import py4godot.classes.Material as __material__
import py4godot.classes.QuadMesh as __quadmesh__
import py4godot.classes.d as __d__
import py4godot.classes.r as __r__
import py4godot.classes.a as __a__
import py4godot.classes.PrismMesh as __prismmesh__
import py4godot.classes.A as __a__
import py4godot.classes.RibbonTrailMesh as __ribbontrailmesh__
import py4godot.classes.y as __y__
import py4godot.classes.CylinderMesh as __cylindermesh__
import py4godot.classes.PrimitiveMesh as __primitivemesh__
import py4godot.classes.TubeTrailMesh as __tubetrailmesh__
import py4godot.classes.PlaneMesh as __planemesh__
import py4godot.classes.TorusMesh as __torusmesh__
import py4godot.classes.P as __p__
import py4godot.classes.PointMesh as __pointmesh__


class CustomFormat:
  CUSTOM_RGBA8_UNORM:int = 0
  CUSTOM_RGBA8_SNORM:int = 1
  CUSTOM_RG_HALF:int = 2
  CUSTOM_RGBA_HALF:int = 3
  CUSTOM_R_FLOAT:int = 4
  CUSTOM_RG_FLOAT:int = 5
  CUSTOM_RGB_FLOAT:int = 6
  CUSTOM_RGBA_FLOAT:int = 7
  CUSTOM_MAX:int = 8
class SkinWeightCount:
  SKIN_4_WEIGHTS:int = 0
  SKIN_8_WEIGHTS:int = 1


class SurfaceTool(__refcounted__.RefCounted):
  """
		The `SurfaceTool` is used to construct a `Mesh` by specifying vertex attributes individually. It can be used to construct a `Mesh` from a script. All properties except indices need to be added before calling `add_vertex`. For example, to add vertex colors and UVs:
		
		```gdscript
		var st = SurfaceTool.new()
		st.begin(Mesh.PRIMITIVE_TRIANGLES)
		st.set_color(Color(1, 0, 0))
		st.set_uv(Vector2(0, 0))
		st.add_vertex(Vector3(0, 0, 0))
		```
		
		
		The above `SurfaceTool` now contains one vertex of a triangle which has a UV coordinate and a specified `Color`. If another vertex were added without calling `set_uv` or `set_color`, then the last values would be used.
		Vertex attributes must be passed **before** calling `add_vertex`. Failure to do so will result in an error when committing the vertex information to a mesh.
		Additionally, the attributes used before the first vertex is added determine the format of the mesh. For example, if you only add UVs to the first vertex, you cannot add color to any of the subsequent vertices.
		See also `ArrayMesh`, `ImmediateMesh` and `MeshDataTool` for procedural geometry generation.
		**Note:** Godot uses clockwise `url=https://learnopengl.com/Advanced-OpenGL/Face-culling`winding order`/url` for front faces of triangle primitive modes.
	"""

  @staticmethod
  def constructor()->SurfaceTool:pass



  @staticmethod
  def cast(other:__object__.Object)->SurfaceTool:pass


  def set_skin_weight_count(self, count:int )->None:
    """
				Set to `constant SKIN_8_WEIGHTS` to indicate that up to 8 bone influences per vertex may be used.
				By default, only 4 bone influences are used (`constant SKIN_4_WEIGHTS`).
				**Note:** This function takes an enum, not the exact number of weights.
			"""
    pass

  def get_skin_weight_count(self)->int:
    """
				By default, returns `constant SKIN_4_WEIGHTS` to indicate only 4 bone influences per vertex are used.
				Returns `constant SKIN_8_WEIGHTS` if up to 8 influences are used.
				**Note:** This function returns an enum, not the exact number of weights.
			"""
    pass

  def set_custom_format(self, channel_index:int, format:int )->None:
    """
				Sets the color format for this custom `channel_index`. Use `constant CUSTOM_MAX` to disable.
				Must be invoked after `begin` and should be set before `commit` or `commit_to_arrays`.
			"""
    pass

  def get_custom_format(self, channel_index:int)->int:
    """
				Returns the format for custom `channel_index` (currently up to 4). Returns `constant CUSTOM_MAX` if this custom channel is unused.
			"""
    pass

  def begin(self, primitive:int )->None:
    """
				Called before adding any vertices. Takes the primitive type as an argument (e.g. `constant Mesh.PRIMITIVE_TRIANGLES`).
			"""
    pass

  def add_vertex(self, vertex:__core__.Vector3)->None:
    """
				Specifies the position of current vertex. Should be called after specifying other vertex properties (e.g. Color, UV).
			"""
    pass

  def set_color(self, color:__core__.Color)->None:
    """
				Specifies a `Color` to use for the _next_ vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
				**Note:** The material must have `BaseMaterial3D.vertex_color_use_as_albedo` enabled for the vertex color to be visible.
			"""
    pass

  def set_normal(self, normal:__core__.Vector3)->None:
    """
				Specifies a normal to use for the _next_ vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
			"""
    pass

  def set_tangent(self, tangent:__core__.Plane)->None:
    """
				Specifies a tangent to use for the _next_ vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
			"""
    pass

  def set_uv(self, uv:__core__.Vector2)->None:
    """
				Specifies a set of UV coordinates to use for the _next_ vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
			"""
    pass

  def set_uv2(self, uv2:__core__.Vector2)->None:
    """
				Specifies an optional second set of UV coordinates to use for the _next_ vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
			"""
    pass

  def set_bones(self, bones:__core__.PackedInt32Array)->None:
    """
				Specifies an array of bones to use for the _next_ vertex. `bones` must contain 4 integers.
			"""
    pass

  def set_weights(self, weights:__core__.PackedFloat32Array)->None:
    """
				Specifies weight values to use for the _next_ vertex. `weights` must contain 4 values. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
			"""
    pass

  def set_custom(self, channel_index:int, custom_color:__core__.Color)->None:
    """
				Sets the custom value on this vertex for `channel_index`.
				`set_custom_format` must be called first for this `channel_index`. Formats which are not RGBA will ignore other color channels.
			"""
    pass

  def set_smooth_group(self, index:int)->None:
    """
				Specifies the smooth group to use for the _next_ vertex. If this is never called, all vertices will have the default smooth group of `0` and will be smoothed with adjacent vertices of the same group. To produce a mesh with flat normals, set the smooth group to `-1`.
				**Note:** This function actually takes a `uint32_t`, so C# users should use `uint32.MaxValue` instead of `-1` to produce a mesh with flat normals.
			"""
    pass

  def add_triangle_fan(self, vertices:__core__.PackedVector3Array, uvs:__core__.PackedVector2Array= __core__.PackedVector2Array.new0(), colors:__core__.PackedColorArray= __core__.PackedColorArray.new0(), uv2s:__core__.PackedVector2Array= __core__.PackedVector2Array.new0(), normals:__core__.PackedVector3Array= __core__.PackedVector3Array.new0(), tangents:__core__.Array=Array[Plane]([]))->None:
    """
				Inserts a triangle fan made of array data into `Mesh` being constructed.
				Requires the primitive type be set to `constant Mesh.PRIMITIVE_TRIANGLES`.
			"""
    pass

  def add_index(self, index:int)->None:
    """
				Adds a vertex to index array if you are using indexed vertices. Does not need to be called before adding vertices.
			"""
    pass

  def index(self)->None:
    """
				Shrinks the vertex array by creating an index array. This can improve performance by avoiding vertex reuse.
			"""
    pass

  def deindex(self)->None:
    """
				Removes the index array by expanding the vertex array.
			"""
    pass

  def generate_normals(self, flip:bool=False)->None:
    """
				Generates normals from vertices so you do not have to do it manually. If `flip` is `true`, the resulting normals will be inverted. `generate_normals` should be called _after_ generating geometry and _before_ committing the mesh using `commit` or `commit_to_arrays`. For correct display of normal-mapped surfaces, you will also have to generate tangents using `generate_tangents`.
				**Note:** `generate_normals` only works if the primitive type is set to `constant Mesh.PRIMITIVE_TRIANGLES`.
				**Note:** `generate_normals` takes smooth groups into account. To generate smooth normals, set the smooth group to a value greater than or equal to `0` using `set_smooth_group` or leave the smooth group at the default of `0`. To generate flat normals, set the smooth group to `-1` using `set_smooth_group` prior to adding vertices.
			"""
    pass

  def generate_tangents(self)->None:
    """
				Generates a tangent vector for each vertex. Requires that each vertex already has UVs and normals set (see `generate_normals`).
			"""
    pass

  def optimize_indices_for_cache(self)->None:
    """
				Optimizes triangle sorting for performance. Requires that `get_primitive_type` is `constant Mesh.PRIMITIVE_TRIANGLES`.
			"""
    pass

  def get_aabb(self)->__core__.AABB:
    """
				Returns the axis-aligned bounding box of the vertex positions.
			"""
    pass

  def generate_lod(self, nd_threshold:float, target_index_count:int=3)->__core__.PackedInt32Array:
    """
				Generates an LOD for a given `nd_threshold` in linear units (square root of quadric error metric), using at most `target_index_count` indices.
			"""
    pass

  def set_material(self, material:__material__.Material)->None:
    """
				Sets `Material` to be used by the `Mesh` you are constructing.
			"""
    pass

  def get_primitive_type(self)->int:
    """
				Returns the type of mesh geometry, such as `constant Mesh.PRIMITIVE_TRIANGLES`.
			"""
    pass

  def clear(self)->None:
    """
				Clear all information passed into the surface tool so far.
			"""
    pass

  def create_from(self, existing:__mesh__.Mesh, surface:int)->None:
    """
				Creates a vertex array from an existing `Mesh`.
			"""
    pass

  def create_from_arrays(self, arrays:__core__.Array, primitive_type:int =3)->None:
    """
				Creates this SurfaceTool from existing vertex arrays such as returned by `commit_to_arrays`, `Mesh.surface_get_arrays`, `Mesh.surface_get_blend_shape_arrays`, `ImporterMesh.get_surface_arrays`, and `ImporterMesh.get_surface_blend_shape_arrays`. `primitive_type` controls the type of mesh data, defaulting to `constant Mesh.PRIMITIVE_TRIANGLES`.
			"""
    pass

  def create_from_blend_shape(self, existing:__mesh__.Mesh, surface:int, blend_shape:str)->None:
    """
				Creates a vertex array from the specified blend shape of an existing `Mesh`. This can be used to extract a specific pose from a blend shape.
			"""
    pass

  def append_from(self, existing:__mesh__.Mesh, surface:int, transform:__core__.Transform3D)->None:
    """
				Append vertices from a given `Mesh` surface onto the current vertex array with specified `Transform3D`.
			"""
    pass

  def commit(self, existing:__arraymesh__.ArrayMesh= __arraymesh__.ArrayMesh.constructor(), flags:int=0)->__arraymesh__.ArrayMesh:
    """
				Returns a constructed `ArrayMesh` from current information passed in. If an existing `ArrayMesh` is passed in as an argument, will add an extra surface to the existing `ArrayMesh`.
				The `flags` argument can be the bitwise OR of `constant Mesh.ARRAY_FLAG_USE_DYNAMIC_UPDATE`, `constant Mesh.ARRAY_FLAG_USE_8_BONE_WEIGHTS`, or `constant Mesh.ARRAY_FLAG_USES_EMPTY_VERTEX_ARRAY`.
			"""
    pass

  def commit_to_arrays(self)->__core__.Array:
    """
				Commits the data to the same format used by `ArrayMesh.add_surface_from_arrays`, `ImporterMesh.add_surface`, and `create_from_arrays`. This way you can further process the mesh data using the `ArrayMesh` or `ImporterMesh` APIs.
			"""
    pass


