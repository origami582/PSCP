from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.D as __d__
import py4godot.classes.r as __r__
import py4godot.classes.e as __e__
import py4godot.classes.a as __a__
import py4godot.classes.N as __n__
import py4godot.classes.Node as __node__
import py4godot.classes.p as __p__
import py4godot.classes.o as __o__
import py4godot.classes.y as __y__
import py4godot.classes.2 as __2__
import py4godot.classes.d as __d__
import py4godot.classes.CollisionObject2D as __collisionobject2d__
import py4godot.classes.A as __a__
import py4godot.classes.T as __t__
import py4godot.classes.Area2D as __area2d__


class SpaceOverride:
  SPACE_OVERRIDE_DISABLED:int = 0
  SPACE_OVERRIDE_COMBINE:int = 1
  SPACE_OVERRIDE_COMBINE_REPLACE:int = 2
  SPACE_OVERRIDE_REPLACE:int = 3
  SPACE_OVERRIDE_REPLACE_COMBINE:int = 4


class Area2D(__collisionobject2d__.CollisionObject2D):
  """
		`Area2D` is a region of 2D space defined by one or multiple `CollisionShape2D` or `CollisionPolygon2D` child nodes. It detects when other `CollisionObject2D`s enter or exit it, and it also keeps track of which collision objects haven't exited it yet (i.e. which one are overlapping it).
		This node can also locally alter or override physics parameters (gravity, damping) and route audio to custom audio buses.
		**Note:** Areas and bodies created with `PhysicsServer2D` might not interact as expected with `Area2D`s, and might not emit signals or track objects correctly.
	"""
  body_shape_entered: BuiltinSignal
  body_shape_exited: BuiltinSignal
  body_entered: BuiltinSignal
  body_exited: BuiltinSignal
  area_shape_entered: BuiltinSignal
  area_shape_exited: BuiltinSignal
  area_entered: BuiltinSignal
  area_exited: BuiltinSignal

  @staticmethod
  def constructor()->Area2D:pass



  @staticmethod
  def cast(other:__object__.Object)->Area2D:pass


  @property
  def monitoring(self)->bool:
    """"""
    pass
  @monitoring.setter
  def monitoring(self,  value:bool)->None:
    """"""
    pass
  @property
  def monitorable(self)->bool:
    """"""
    pass
  @monitorable.setter
  def monitorable(self,  value:bool)->None:
    """"""
    pass
  @property
  def priority(self)->int:
    """"""
    pass
  @priority.setter
  def priority(self,  value:int)->None:
    """"""
    pass
  @property
  def gravity_space_override(self)->int:
    """"""
    pass
  @gravity_space_override.setter
  def gravity_space_override(self,  value:int)->None:
    """"""
    pass
  @property
  def gravity_point(self)->bool:
    """"""
    pass
  @gravity_point.setter
  def gravity_point(self,  value:bool)->None:
    """"""
    pass
  @property
  def gravity_point_unit_distance(self)->float:
    """"""
    pass
  @gravity_point_unit_distance.setter
  def gravity_point_unit_distance(self,  value:float)->None:
    """"""
    pass
  @property
  def gravity_point_center(self)->__core__.Vector2:
    """"""
    pass
  @gravity_point_center.setter
  def gravity_point_center(self,  value:__core__.Vector2)->None:
    """"""
    pass
  @property
  def gravity_direction(self)->__core__.Vector2:
    """"""
    pass
  @gravity_direction.setter
  def gravity_direction(self,  value:__core__.Vector2)->None:
    """"""
    pass
  @property
  def gravity(self)->float:
    """"""
    pass
  @gravity.setter
  def gravity(self,  value:float)->None:
    """"""
    pass
  @property
  def linear_damp_space_override(self)->int:
    """"""
    pass
  @linear_damp_space_override.setter
  def linear_damp_space_override(self,  value:int)->None:
    """"""
    pass
  @property
  def linear_damp(self)->float:
    """"""
    pass
  @linear_damp.setter
  def linear_damp(self,  value:float)->None:
    """"""
    pass
  @property
  def angular_damp_space_override(self)->int:
    """"""
    pass
  @angular_damp_space_override.setter
  def angular_damp_space_override(self,  value:int)->None:
    """"""
    pass
  @property
  def angular_damp(self)->float:
    """"""
    pass
  @angular_damp.setter
  def angular_damp(self,  value:float)->None:
    """"""
    pass
  @property
  def audio_bus_override(self)->bool:
    """"""
    pass
  @audio_bus_override.setter
  def audio_bus_override(self,  value:bool)->None:
    """"""
    pass
  @property
  def audio_bus_name(self)->__core__.StringName:
    """"""
    pass
  @audio_bus_name.setter
  def audio_bus_name(self,  value:__core__.StringName)->None:
    """"""
    pass
  def set_gravity_space_override_mode(self, space_override_mode:int )->None:
    """"""
    pass

  def get_gravity_space_override_mode(self)->int:
    """"""
    pass

  def set_gravity_is_point(self, enable:bool)->None:
    """"""
    pass

  def is_gravity_a_point(self)->bool:
    """"""
    pass

  def set_gravity_point_unit_distance(self, distance_scale:float)->None:
    """"""
    pass

  def get_gravity_point_unit_distance(self)->float:
    """"""
    pass

  def set_gravity_point_center(self, center:__core__.Vector2)->None:
    """"""
    pass

  def get_gravity_point_center(self)->__core__.Vector2:
    """"""
    pass

  def set_gravity_direction(self, direction:__core__.Vector2)->None:
    """"""
    pass

  def get_gravity_direction(self)->__core__.Vector2:
    """"""
    pass

  def set_gravity(self, gravity:float)->None:
    """"""
    pass

  def get_gravity(self)->float:
    """"""
    pass

  def set_linear_damp_space_override_mode(self, space_override_mode:int )->None:
    """"""
    pass

  def get_linear_damp_space_override_mode(self)->int:
    """"""
    pass

  def set_angular_damp_space_override_mode(self, space_override_mode:int )->None:
    """"""
    pass

  def get_angular_damp_space_override_mode(self)->int:
    """"""
    pass

  def set_linear_damp(self, linear_damp:float)->None:
    """"""
    pass

  def get_linear_damp(self)->float:
    """"""
    pass

  def set_angular_damp(self, angular_damp:float)->None:
    """"""
    pass

  def get_angular_damp(self)->float:
    """"""
    pass

  def set_priority(self, priority:int)->None:
    """"""
    pass

  def get_priority(self)->int:
    """"""
    pass

  def set_monitoring(self, enable:bool)->None:
    """"""
    pass

  def is_monitoring(self)->bool:
    """"""
    pass

  def set_monitorable(self, enable:bool)->None:
    """"""
    pass

  def is_monitorable(self)->bool:
    """"""
    pass

  def get_overlapping_bodies(self)->typedarray::Node2D:
    """
				Returns a list of intersecting `PhysicsBody2D`s and `TileMap`s. The overlapping body's `CollisionObject2D.collision_layer` must be part of this area's `CollisionObject2D.collision_mask` in order to be detected.
				For performance reasons (collisions are all processed at the same time) this list is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
			"""
    pass

  def get_overlapping_areas(self)->typedarray::Area2D:
    """
				Returns a list of intersecting `Area2D`s. The overlapping area's `CollisionObject2D.collision_layer` must be part of this area's `CollisionObject2D.collision_mask` in order to be detected.
				For performance reasons (collisions are all processed at the same time) this list is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
			"""
    pass

  def has_overlapping_bodies(self)->bool:
    """
				Returns `true` if intersecting any `PhysicsBody2D`s or `TileMap`s, otherwise returns `false`. The overlapping body's `CollisionObject2D.collision_layer` must be part of this area's `CollisionObject2D.collision_mask` in order to be detected.
				For performance reasons (collisions are all processed at the same time) the list of overlapping bodies is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
			"""
    pass

  def has_overlapping_areas(self)->bool:
    """
				Returns `true` if intersecting any `Area2D`s, otherwise returns `false`. The overlapping area's `CollisionObject2D.collision_layer` must be part of this area's `CollisionObject2D.collision_mask` in order to be detected.
				For performance reasons (collisions are all processed at the same time) the list of overlapping areas is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
			"""
    pass

  def overlaps_body(self, body:__node__.Node)->bool:
    """
				Returns `true` if the given physics body intersects or overlaps this `Area2D`, `false` otherwise.
				**Note:** The result of this test is not immediate after moving objects. For performance, list of overlaps is updated once per frame and before the physics step. Consider using signals instead.
				The `body` argument can either be a `PhysicsBody2D` or a `TileMap` instance. While TileMaps are not physics bodies themselves, they register their tiles with collision shapes as a virtual physics body.
			"""
    pass

  def overlaps_area(self, area:__node__.Node)->bool:
    """
				Returns `true` if the given `Area2D` intersects or overlaps this `Area2D`, `false` otherwise.
				**Note:** The result of this test is not immediate after moving objects. For performance, the list of overlaps is updated once per frame and before the physics step. Consider using signals instead.
			"""
    pass

  def set_audio_bus_name(self, name:__core__.StringName|str)->None:
    """"""
    pass

  def get_audio_bus_name(self)->__core__.StringName:
    """"""
    pass

  def set_audio_bus_override(self, enable:bool)->None:
    """"""
    pass

  def is_overriding_audio_bus(self)->bool:
    """"""
    pass


