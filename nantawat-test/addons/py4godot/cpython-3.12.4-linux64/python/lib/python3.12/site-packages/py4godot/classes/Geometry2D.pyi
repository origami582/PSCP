from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.c as __c__
import py4godot.classes.r as __r__
import py4godot.classes.i as __i__
import py4godot.classes.e as __e__
import py4godot.classes.t as __t__
import py4godot.classes.a as __a__
import py4godot.classes.V as __v__
import py4godot.classes.p as __p__
import py4godot.classes.Geometry2D as __geometry2d__
import py4godot.classes.o as __o__
import py4godot.classes.y as __y__
import py4godot.classes.k as __k__
import py4godot.classes.P as __p__
import py4godot.classes.d as __d__
import py4godot.classes.Object as __object__
import py4godot.classes.2 as __2__
import py4godot.classes.A as __a__
import py4godot.classes.T as __t__


class PolyBooleanOperation:
  OPERATION_UNION:int = 0
  OPERATION_DIFFERENCE:int = 1
  OPERATION_INTERSECTION:int = 2
  OPERATION_XOR:int = 3
class PolyJoinType:
  JOIN_SQUARE:int = 0
  JOIN_ROUND:int = 1
  JOIN_MITER:int = 2
class PolyEndType:
  END_POLYGON:int = 0
  END_JOINED:int = 1
  END_BUTT:int = 2
  END_SQUARE:int = 3
  END_ROUND:int = 4


class Geometry2D(__object__.Object):
  """
		Provides a set of helper functions to create geometric shapes, compute intersections between shapes, and process various other geometric operations in 2D.
	"""



  @staticmethod
  def cast(other:__object__.Object)->Geometry2D:pass

  @staticmethod
  def instance()->Geometry2D:pass

  def is_point_in_circle(self, point:__core__.Vector2, circle_position:__core__.Vector2, circle_radius:float)->bool:
    """
				Returns `true` if `point` is inside the circle or if it's located exactly _on_ the circle's boundary, otherwise returns `false`.
			"""
    pass

  def segment_intersects_circle(self, segment_from:__core__.Vector2, segment_to:__core__.Vector2, circle_position:__core__.Vector2, circle_radius:float)->float:
    """
				Given the 2D segment (`segment_from`, `segment_to`), returns the position on the segment (as a number between 0 and 1) at which the segment hits the circle that is located at position `circle_position` and has radius `circle_radius`. If the segment does not intersect the circle, -1 is returned (this is also the case if the line extending the segment would intersect the circle, but the segment does not).
			"""
    pass

  def segment_intersects_segment(self, from_a:__core__.Vector2, to_a:__core__.Vector2, from_b:__core__.Vector2, to_b:__core__.Vector2)->Any:
    """
				Checks if the two segments (`from_a`, `to_a`) and (`from_b`, `to_b`) intersect. If yes, return the point of intersection as `Vector2`. If no intersection takes place, returns `null`.
			"""
    pass

  def line_intersects_line(self, from_a:__core__.Vector2, dir_a:__core__.Vector2, from_b:__core__.Vector2, dir_b:__core__.Vector2)->Any:
    """
				Returns the point of intersection between the two lines (`from_a`, `dir_a`) and (`from_b`, `dir_b`). Returns a `Vector2`, or `null` if the lines are parallel.
				`from` and `dir` are _not_ endpoints of a line segment or ray but the slope (`dir`) and a known point (`from`) on that line.
				
				```gdscript
				var from_a = Vector2.ZERO
				var dir_a = Vector2.RIGHT
				var from_b = Vector2.DOWN

				# Returns Vector2(1, 0)
				Geometry2D.line_intersects_line(from_a, dir_a, from_b, Vector2(1, -1))
				# Returns Vector2(-1, 0)
				Geometry2D.line_intersects_line(from_a, dir_a, from_b, Vector2(-1, -1))
				# Returns null
				Geometry2D.line_intersects_line(from_a, dir_a, from_b, Vector2.RIGHT)
				```
				
				
			"""
    pass

  def get_closest_points_between_segments(self, p1:__core__.Vector2, q1:__core__.Vector2, p2:__core__.Vector2, q2:__core__.Vector2)->__core__.PackedVector2Array:
    """
				Given the two 2D segments (`p1`, `q1`) and (`p2`, `q2`), finds those two points on the two segments that are closest to each other. Returns a `PackedVector2Array` that contains this point on (`p1`, `q1`) as well the accompanying point on (`p2`, `q2`).
			"""
    pass

  def get_closest_point_to_segment(self, point:__core__.Vector2, s1:__core__.Vector2, s2:__core__.Vector2)->__core__.Vector2:
    """
				Returns the 2D point on the 2D segment (`s1`, `s2`) that is closest to `point`. The returned point will always be inside the specified segment.
			"""
    pass

  def get_closest_point_to_segment_uncapped(self, point:__core__.Vector2, s1:__core__.Vector2, s2:__core__.Vector2)->__core__.Vector2:
    """
				Returns the 2D point on the 2D line defined by (`s1`, `s2`) that is closest to `point`. The returned point can be inside the segment (`s1`, `s2`) or outside of it, i.e. somewhere on the line extending from the segment.
			"""
    pass

  def point_is_inside_triangle(self, point:__core__.Vector2, a:__core__.Vector2, b:__core__.Vector2, c:__core__.Vector2)->bool:
    """
				Returns if `point` is inside the triangle specified by `a`, `b` and `c`.
			"""
    pass

  def is_polygon_clockwise(self, polygon:__core__.PackedVector2Array)->bool:
    """
				Returns `true` if `polygon`'s vertices are ordered in clockwise order, otherwise returns `false`.
				**Note:** Assumes a Cartesian coordinate system where `+x` is right and `+y` is up. If using screen coordinates (`+y` is down), the result will need to be flipped (i.e. a `true` result will indicate counter-clockwise).
			"""
    pass

  def is_point_in_polygon(self, point:__core__.Vector2, polygon:__core__.PackedVector2Array)->bool:
    """
				Returns `true` if `point` is inside `polygon` or if it's located exactly _on_ polygon's boundary, otherwise returns `false`.
			"""
    pass

  def triangulate_polygon(self, polygon:__core__.PackedVector2Array)->__core__.PackedInt32Array:
    """
				Triangulates the polygon specified by the points in `polygon`. Returns a `PackedInt32Array` where each triangle consists of three consecutive point indices into `polygon` (i.e. the returned array will have `n * 3` elements, with `n` being the number of found triangles). Output triangles will always be counter clockwise, and the contour will be flipped if it's clockwise. If the triangulation did not succeed, an empty `PackedInt32Array` is returned.
			"""
    pass

  def triangulate_delaunay(self, points:__core__.PackedVector2Array)->__core__.PackedInt32Array:
    """
				Triangulates the area specified by discrete set of `points` such that no point is inside the circumcircle of any resulting triangle. Returns a `PackedInt32Array` where each triangle consists of three consecutive point indices into `points` (i.e. the returned array will have `n * 3` elements, with `n` being the number of found triangles). If the triangulation did not succeed, an empty `PackedInt32Array` is returned.
			"""
    pass

  def convex_hull(self, points:__core__.PackedVector2Array)->__core__.PackedVector2Array:
    """
				Given an array of `Vector2`s, returns the convex hull as a list of points in counterclockwise order. The last point is the same as the first one.
			"""
    pass

  def decompose_polygon_in_convex(self, polygon:__core__.PackedVector2Array)->typedarray::PackedVector2Array:
    """
				Decomposes the `polygon` into multiple convex hulls and returns an array of `PackedVector2Array`.
			"""
    pass

  def merge_polygons(self, polygon_a:__core__.PackedVector2Array, polygon_b:__core__.PackedVector2Array)->typedarray::PackedVector2Array:
    """
				Merges (combines) `polygon_a` and `polygon_b` and returns an array of merged polygons. This performs `constant OPERATION_UNION` between polygons.
				The operation may result in an outer polygon (boundary) and multiple inner polygons (holes) produced which could be distinguished by calling `is_polygon_clockwise`.
			"""
    pass

  def clip_polygons(self, polygon_a:__core__.PackedVector2Array, polygon_b:__core__.PackedVector2Array)->typedarray::PackedVector2Array:
    """
				Clips `polygon_a` against `polygon_b` and returns an array of clipped polygons. This performs `constant OPERATION_DIFFERENCE` between polygons. Returns an empty array if `polygon_b` completely overlaps `polygon_a`.
				If `polygon_b` is enclosed by `polygon_a`, returns an outer polygon (boundary) and inner polygon (hole) which could be distinguished by calling `is_polygon_clockwise`.
			"""
    pass

  def intersect_polygons(self, polygon_a:__core__.PackedVector2Array, polygon_b:__core__.PackedVector2Array)->typedarray::PackedVector2Array:
    """
				Intersects `polygon_a` with `polygon_b` and returns an array of intersected polygons. This performs `constant OPERATION_INTERSECTION` between polygons. In other words, returns common area shared by polygons. Returns an empty array if no intersection occurs.
				The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling `is_polygon_clockwise`.
			"""
    pass

  def exclude_polygons(self, polygon_a:__core__.PackedVector2Array, polygon_b:__core__.PackedVector2Array)->typedarray::PackedVector2Array:
    """
				Mutually excludes common area defined by intersection of `polygon_a` and `polygon_b` (see `intersect_polygons`) and returns an array of excluded polygons. This performs `constant OPERATION_XOR` between polygons. In other words, returns all but common area between polygons.
				The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling `is_polygon_clockwise`.
			"""
    pass

  def clip_polyline_with_polygon(self, polyline:__core__.PackedVector2Array, polygon:__core__.PackedVector2Array)->typedarray::PackedVector2Array:
    """
				Clips `polyline` against `polygon` and returns an array of clipped polylines. This performs `constant OPERATION_DIFFERENCE` between the polyline and the polygon. This operation can be thought of as cutting a line with a closed shape.
			"""
    pass

  def intersect_polyline_with_polygon(self, polyline:__core__.PackedVector2Array, polygon:__core__.PackedVector2Array)->typedarray::PackedVector2Array:
    """
				Intersects `polyline` with `polygon` and returns an array of intersected polylines. This performs `constant OPERATION_INTERSECTION` between the polyline and the polygon. This operation can be thought of as chopping a line with a closed shape.
			"""
    pass

  def offset_polygon(self, polygon:__core__.PackedVector2Array, delta:float, join_type:int =0)->typedarray::PackedVector2Array:
    """
				Inflates or deflates `polygon` by `delta` units (pixels). If `delta` is positive, makes the polygon grow outward. If `delta` is negative, shrinks the polygon inward. Returns an array of polygons because inflating/deflating may result in multiple discrete polygons. Returns an empty array if `delta` is negative and the absolute value of it approximately exceeds the minimum bounding rectangle dimensions of the polygon.
				Each polygon's vertices will be rounded as determined by `join_type`.
				The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling `is_polygon_clockwise`.
				**Note:** To translate the polygon's vertices specifically, multiply them to a `Transform2D`:
				
				```gdscript
				var polygon = PackedVector2Array(`Vector2(0, 0), Vector2(100, 0), Vector2(100, 100), Vector2(0, 100)`)
				var offset = Vector2(50, 50)
				polygon = Transform2D(0, offset) * polygon
				print(polygon) # Prints `(50.0, 50.0), (150.0, 50.0), (150.0, 150.0), (50.0, 150.0)`
				```
				
				
			"""
    pass

  def offset_polyline(self, polyline:__core__.PackedVector2Array, delta:float, join_type:int =0, end_type:int =3)->typedarray::PackedVector2Array:
    """
				Inflates or deflates `polyline` by `delta` units (pixels), producing polygons. If `delta` is positive, makes the polyline grow outward. Returns an array of polygons because inflating/deflating may result in multiple discrete polygons. If `delta` is negative, returns an empty array.
				Each polygon's vertices will be rounded as determined by `join_type`.
				Each polygon's endpoints will be rounded as determined by `end_type`.
				The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling `is_polygon_clockwise`.
			"""
    pass

  def make_atlas(self, sizes:__core__.PackedVector2Array)->__core__.Dictionary:
    """
				Given an array of `Vector2`s representing tiles, builds an atlas. The returned dictionary has two keys: `points` is a `PackedVector2Array` that specifies the positions of each tile, `size` contains the overall size of the whole atlas as `Vector2i`.
			"""
    pass

  def bresenham_line(self, from_:__core__.Vector2i, to:__core__.Vector2i)->typedarray::Vector2i:
    """
				Returns the `url=https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm`Bresenham line`/url` between the `from` and `to` points. A Bresenham line is a series of pixels that draws a line and is always 1-pixel thick on every row and column of the drawing (never more, never less).
				Example code to draw a line between two `Marker2D` nodes using a series of `CanvasItem.draw_rect` calls:
				```gdscript
				func _draw():
					for pixel in Geometry2D.bresenham_line($MarkerA.position, $MarkerB.position):
						draw_rect(Rect2(pixel, Vector2.ONE), Color.WHITE)
				```
			"""
    pass


