from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.AudioStreamPlayer2D as __audiostreamplayer2d__
import py4godot.classes.CanvasModulate as __canvasmodulate__
import py4godot.classes.NavigationLink2D as __navigationlink2d__
import py4godot.classes.VSplitContainer as __vsplitcontainer__
import py4godot.classes.TextServer as __textserver__
import py4godot.classes.GraphElement as __graphelement__
import py4godot.classes.VisibleOnScreenEnabler2D as __visibleonscreenenabler2d__
import py4godot.classes.GraphNode as __graphnode__
import py4godot.classes.Skeleton2D as __skeleton2d__
import py4godot.classes.Node2D as __node2d__
import py4godot.classes.HFlowContainer as __hflowcontainer__
import py4godot.classes.OpenXRBindingModifierEditor as __openxrbindingmodifiereditor__
import py4godot.classes.Font as __font__
import py4godot.classes.GraphFrame as __graphframe__
import py4godot.classes.AudioListener2D as __audiolistener2d__
import py4godot.classes.Camera2D as __camera2d__
import py4godot.classes.InputEventJoypadMotion as __inputeventjoypadmotion__
import py4godot.classes.MarginContainer as __margincontainer__
import py4godot.classes.Path2D as __path2d__
import py4godot.classes.HBoxContainer as __hboxcontainer__
import py4godot.classes.PathFollow2D as __pathfollow2d__
import py4godot.classes.OpenXRInteractionProfileEditor as __openxrinteractionprofileeditor__
import py4godot.classes.RayCast2D as __raycast2d__
import py4godot.classes.InputEventPanGesture as __inputeventpangesture__
import py4godot.classes.HSeparator as __hseparator__
import py4godot.classes.Control as __control__
import py4godot.classes.Tree as __tree__
import py4godot.classes.PlaceholderMaterial as __placeholdermaterial__
import py4godot.classes.LineEdit as __lineedit__
import py4godot.classes.BackBufferCopy as __backbuffercopy__
import py4godot.classes.RichTextLabel as __richtextlabel__
import py4godot.classes.InputEventScreenTouch as __inputeventscreentouch__
import py4godot.classes.Slider as __slider__
import py4godot.classes.PhysicalSkyMaterial as __physicalskymaterial__
import py4godot.classes.GrooveJoint2D as __groovejoint2d__
import py4godot.classes.AnimatableBody2D as __animatablebody2d__
import py4godot.classes.ParallaxBackground as __parallaxbackground__
import py4godot.classes.BaseMaterial3D as __basematerial3d__
import py4godot.classes.CollisionShape2D as __collisionshape2d__
import py4godot.classes.ORMMaterial3D as __ormmaterial3d__
import py4godot.classes.Sprite2D as __sprite2d__
import py4godot.classes.NinePatchRect as __ninepatchrect__
import py4godot.classes.ShaderMaterial as __shadermaterial__
import py4godot.classes.GraphEdit as __graphedit__
import py4godot.classes.EditorSpinSlider as __editorspinslider__
import py4godot.classes.World2D as __world2d__
import py4godot.classes.CPUParticles2D as __cpuparticles2d__
import py4godot.classes.PointLight2D as __pointlight2d__
import py4godot.classes.Texture2D as __texture2d__
import py4godot.classes.PanelContainer as __panelcontainer__
import py4godot.classes.AspectRatioContainer as __aspectratiocontainer__
import py4godot.classes.CheckBox as __checkbox__
import py4godot.classes.Separator as __separator__
import py4godot.classes.TextureProgressBar as __textureprogressbar__
import py4godot.classes.Joint2D as __joint2d__
import py4godot.classes.Range as __range__
import py4godot.classes.VBoxContainer as __vboxcontainer__
import py4godot.classes.RemoteTransform2D as __remotetransform2d__
import py4godot.classes.ParticleProcessMaterial as __particleprocessmaterial__
import py4godot.classes.TileMapLayer as __tilemaplayer__
import py4godot.classes.InputEventGesture as __inputeventgesture__
import py4godot.classes.InputEventKey as __inputeventkey__
import py4godot.classes.ScrollBar as __scrollbar__
import py4godot.classes.CheckButton as __checkbutton__
import py4godot.classes.GridContainer as __gridcontainer__
import py4godot.classes.MultiMesh as __multimesh__
import py4godot.classes.RigidBody2D as __rigidbody2d__
import py4godot.classes.SplitContainer as __splitcontainer__
import py4godot.classes.EditorResourcePicker as __editorresourcepicker__
import py4godot.classes.InputEventMouseMotion as __inputeventmousemotion__
import py4godot.classes.VideoStreamPlayer as __videostreamplayer__
import py4godot.classes.Parallax2D as __parallax2d__
import py4godot.classes.MultiMeshInstance2D as __multimeshinstance2d__
import py4godot.classes.InputEvent as __inputevent__
import py4godot.classes.Container as __container__
import py4godot.classes.FlowContainer as __flowcontainer__
import py4godot.classes.ItemList as __itemlist__
import py4godot.classes.AnimatedSprite2D as __animatedsprite2d__
import py4godot.classes.PinJoint2D as __pinjoint2d__
import py4godot.classes.SubViewportContainer as __subviewportcontainer__
import py4godot.classes.LightOccluder2D as __lightoccluder2d__
import py4godot.classes.FileSystemDock as __filesystemdock__
import py4godot.classes.BaseButton as __basebutton__
import py4godot.classes.InputEventShortcut as __inputeventshortcut__
import py4godot.classes.LinkButton as __linkbutton__
import py4godot.classes.OptionButton as __optionbutton__
import py4godot.classes.StaticBody2D as __staticbody2d__
import py4godot.classes.MenuBar as __menubar__
import py4godot.classes.VScrollBar as __vscrollbar__
import py4godot.classes.CollisionPolygon2D as __collisionpolygon2d__
import py4godot.classes.StyleBox as __stylebox__
import py4godot.classes.GPUParticles2D as __gpuparticles2d__
import py4godot.classes.Button as __button__
import py4godot.classes.Mesh as __mesh__
import py4godot.classes.Light2D as __light2d__
import py4godot.classes.Panel as __panel__
import py4godot.classes.CanvasItem as __canvasitem__
import py4godot.classes.ProgressBar as __progressbar__
import py4godot.classes.TextEdit as __textedit__
import py4godot.classes.BoxContainer as __boxcontainer__
import py4godot.classes.InputEventScreenDrag as __inputeventscreendrag__
import py4godot.classes.InputEventFromWindow as __inputeventfromwindow__
import py4godot.classes.PanoramaSkyMaterial as __panoramaskymaterial__
import py4godot.classes.InputEventJoypadButton as __inputeventjoypadbutton__
import py4godot.classes.TabContainer as __tabcontainer__
import py4godot.classes.ColorPickerButton as __colorpickerbutton__
import py4godot.classes.Label as __label__
import py4godot.classes.Bone2D as __bone2d__
import py4godot.classes.DampedSpringJoint2D as __dampedspringjoint2d__
import py4godot.classes.TextureButton as __texturebutton__
import py4godot.classes.TextureRect as __texturerect__
import py4godot.classes.CodeEdit as __codeedit__
import py4godot.classes.PhysicsBody2D as __physicsbody2d__
import py4godot.classes.CharacterBody2D as __characterbody2d__
import py4godot.classes.CanvasLayer as __canvaslayer__
import py4godot.classes.FogMaterial as __fogmaterial__
import py4godot.classes.ColorPicker as __colorpicker__
import py4godot.classes.InputEventAction as __inputeventaction__
import py4godot.classes.Marker2D as __marker2d__
import py4godot.classes.PhysicalBone2D as __physicalbone2d__
import py4godot.classes.TileMap as __tilemap__
import py4godot.classes.ColorRect as __colorrect__
import py4godot.classes.NavigationObstacle2D as __navigationobstacle2d__
import py4godot.classes.VFlowContainer as __vflowcontainer__
import py4godot.classes.EditorInspector as __editorinspector__
import py4godot.classes.Area2D as __area2d__
import py4godot.classes.ShapeCast2D as __shapecast2d__
import py4godot.classes.VSeparator as __vseparator__
import py4godot.classes.InputEventMagnifyGesture as __inputeventmagnifygesture__
import py4godot.classes.Node as __node__
import py4godot.classes.Line2D as __line2d__
import py4godot.classes.CenterContainer as __centercontainer__
import py4godot.classes.EditorProperty as __editorproperty__
import py4godot.classes.ProceduralSkyMaterial as __proceduralskymaterial__
import py4godot.classes.TabBar as __tabbar__
import py4godot.classes.MeshInstance2D as __meshinstance2d__
import py4godot.classes.HSplitContainer as __hsplitcontainer__
import py4godot.classes.OpenXRInteractionProfileEditorBase as __openxrinteractionprofileeditorbase__
import py4godot.classes.EditorScriptPicker as __editorscriptpicker__
import py4godot.classes.TouchScreenButton as __touchscreenbutton__
import py4godot.classes.StandardMaterial3D as __standardmaterial3d__
import py4godot.classes.SpinBox as __spinbox__
import py4godot.classes.Material as __material__
import py4godot.classes.InputEventWithModifiers as __inputeventwithmodifiers__
import py4godot.classes.DirectionalLight2D as __directionallight2d__
import py4godot.classes.ReferenceRect as __referencerect__
import py4godot.classes.ScriptEditor as __scripteditor__
import py4godot.classes.InputEventMouseButton as __inputeventmousebutton__
import py4godot.classes.ScriptEditorBase as __scripteditorbase__
import py4godot.classes.MenuButton as __menubutton__
import py4godot.classes.NavigationRegion2D as __navigationregion2d__
import py4godot.classes.ScrollContainer as __scrollcontainer__
import py4godot.classes.CanvasItemMaterial as __canvasitemmaterial__
import py4godot.classes.CollisionObject2D as __collisionobject2d__
import py4godot.classes.Polygon2D as __polygon2d__
import py4godot.classes.EditorToaster as __editortoaster__
import py4godot.classes.HSlider as __hslider__
import py4godot.classes.HScrollBar as __hscrollbar__
import py4godot.classes.VSlider as __vslider__
import py4godot.classes.ParallaxLayer as __parallaxlayer__
import py4godot.classes.InputEventMouse as __inputeventmouse__
import py4godot.classes.CanvasGroup as __canvasgroup__
import py4godot.classes.InputEventMIDI as __inputeventmidi__
import py4godot.classes.VisibleOnScreenNotifier2D as __visibleonscreennotifier2d__


class TextureFilter:
  TEXTURE_FILTER_PARENT_NODE:int = 0
  TEXTURE_FILTER_NEAREST:int = 1
  TEXTURE_FILTER_LINEAR:int = 2
  TEXTURE_FILTER_NEAREST_WITH_MIPMAPS:int = 3
  TEXTURE_FILTER_LINEAR_WITH_MIPMAPS:int = 4
  TEXTURE_FILTER_NEAREST_WITH_MIPMAPS_ANISOTROPIC:int = 5
  TEXTURE_FILTER_LINEAR_WITH_MIPMAPS_ANISOTROPIC:int = 6
  TEXTURE_FILTER_MAX:int = 7
class TextureRepeat:
  TEXTURE_REPEAT_PARENT_NODE:int = 0
  TEXTURE_REPEAT_DISABLED:int = 1
  TEXTURE_REPEAT_ENABLED:int = 2
  TEXTURE_REPEAT_MIRROR:int = 3
  TEXTURE_REPEAT_MAX:int = 4
class ClipChildrenMode:
  CLIP_CHILDREN_DISABLED:int = 0
  CLIP_CHILDREN_ONLY:int = 1
  CLIP_CHILDREN_AND_DRAW:int = 2
  CLIP_CHILDREN_MAX:int = 3


class CanvasItem(__node__.Node):
  """
		Abstract base class for everything in 2D space. Canvas items are laid out in a tree; children inherit and extend their parent's transform. `CanvasItem` is extended by `Control` for GUI-related nodes, and by `Node2D` for 2D game objects.
		Any `CanvasItem` can draw. For this, `queue_redraw` is called by the engine, then `constant NOTIFICATION_DRAW` will be received on idle time to request a redraw. Because of this, canvas items don't need to be redrawn on every frame, improving the performance significantly. Several functions for drawing on the `CanvasItem` are provided (see `draw_*` functions). However, they can only be used inside `_draw`, its corresponding `Object._notification` or methods connected to the `signal draw` signal.
		Canvas items are drawn in tree order on their canvas layer. By default, children are on top of their parents, so a root `CanvasItem` will be drawn behind everything. This behavior can be changed on a per-item basis.
		A `CanvasItem` can be hidden, which will also hide its children. By adjusting various other properties of a `CanvasItem`, you can also modulate its color (via `modulate` or `self_modulate`), change its Z-index, blend mode, and more.
		Note that properties like transform, modulation, and visibility are only propagated to _direct_ `CanvasItem` child nodes. If there is a non-`CanvasItem` node in between, like `Node` or `AnimationPlayer`, the `CanvasItem` nodes below will have an independent position and `modulate` chain. See also `top_level`.
	"""
  draw: BuiltinSignal
  visibility_changed: BuiltinSignal
  hidden: BuiltinSignal
  item_rect_changed: BuiltinSignal

  @staticmethod
  def constructor()->CanvasItem:pass



  @staticmethod
  def cast(other:__object__.Object)->CanvasItem:pass


  @property
  def visible(self)->bool:
    """"""
    pass
  @visible.setter
  def visible(self,  value:bool)->None:
    """"""
    pass
  @property
  def modulate(self)->__core__.Color:
    """"""
    pass
  @modulate.setter
  def modulate(self,  value:__core__.Color)->None:
    """"""
    pass
  @property
  def self_modulate(self)->__core__.Color:
    """"""
    pass
  @self_modulate.setter
  def self_modulate(self,  value:__core__.Color)->None:
    """"""
    pass
  @property
  def show_behind_parent(self)->bool:
    """"""
    pass
  @show_behind_parent.setter
  def show_behind_parent(self,  value:bool)->None:
    """"""
    pass
  @property
  def top_level(self)->bool:
    """"""
    pass
  @top_level.setter
  def top_level(self,  value:bool)->None:
    """"""
    pass
  @property
  def clip_children(self)->int:
    """"""
    pass
  @clip_children.setter
  def clip_children(self,  value:int)->None:
    """"""
    pass
  @property
  def light_mask(self)->int:
    """"""
    pass
  @light_mask.setter
  def light_mask(self,  value:int)->None:
    """"""
    pass
  @property
  def visibility_layer(self)->int:
    """"""
    pass
  @visibility_layer.setter
  def visibility_layer(self,  value:int)->None:
    """"""
    pass
  @property
  def z_index(self)->int:
    """"""
    pass
  @z_index.setter
  def z_index(self,  value:int)->None:
    """"""
    pass
  @property
  def z_as_relative(self)->bool:
    """"""
    pass
  @z_as_relative.setter
  def z_as_relative(self,  value:bool)->None:
    """"""
    pass
  @property
  def y_sort_enabled(self)->bool:
    """"""
    pass
  @y_sort_enabled.setter
  def y_sort_enabled(self,  value:bool)->None:
    """"""
    pass
  @property
  def texture_filter(self)->int:
    """"""
    pass
  @texture_filter.setter
  def texture_filter(self,  value:int)->None:
    """"""
    pass
  @property
  def texture_repeat(self)->int:
    """"""
    pass
  @texture_repeat.setter
  def texture_repeat(self,  value:int)->None:
    """"""
    pass
  @property
  def material(self)->CanvasItemMaterial,ShaderMaterial:
    """"""
    pass
  @material.setter
  def material(self,  value:__canvasitemmaterial__.CanvasItemMaterial)->None:
    """"""
    pass
  @property
  def use_parent_material(self)->bool:
    """"""
    pass
  @use_parent_material.setter
  def use_parent_material(self,  value:bool)->None:
    """"""
    pass
  def _draw(self)->None:
    """
				Called when `CanvasItem` has been requested to redraw (after `queue_redraw` is called, either manually or by the engine).
				Corresponds to the `constant NOTIFICATION_DRAW` notification in `Object._notification`.
			"""
    pass

  def get_canvas_item(self)->__core__.RID:
    """
				Returns the internal canvas item `RID` used by the `RenderingServer` for this node.
			"""
    pass

  def set_visible(self, visible:bool)->None:
    """"""
    pass

  def is_visible(self)->bool:
    """"""
    pass

  def is_visible_in_tree(self)->bool:
    """
				Returns `true` if the node is present in the `SceneTree`, its `visible` property is `true` and all its ancestors are also visible. If any ancestor is hidden, this node will not be visible in the scene tree, and is therefore not drawn (see `_draw`).
				Visibility is checked only in parent nodes that inherit from `CanvasItem`, `CanvasLayer`, and `Window`. If the parent is of any other type (such as `Node`, `AnimationPlayer`, or `Node3D`), it is assumed to be visible.
				**Note:** This method does not take `visibility_layer` into account, so even if this method returns `true`, the node might end up not being rendered.
			"""
    pass

  def show(self)->None:
    """
				Show the `CanvasItem` if it's currently hidden. This is equivalent to setting `visible` to `true`.
				**Note:** For controls that inherit `Popup`, the correct way to make them visible is to call one of the multiple `popup*()` functions instead.
			"""
    pass

  def hide(self)->None:
    """
				Hide the `CanvasItem` if it's currently visible. This is equivalent to setting `visible` to `false`.
			"""
    pass

  def queue_redraw(self)->None:
    """
				Queues the `CanvasItem` to redraw. During idle time, if `CanvasItem` is visible, `constant NOTIFICATION_DRAW` is sent and `_draw` is called. This only occurs **once** per frame, even if this method has been called multiple times.
			"""
    pass

  def move_to_front(self)->None:
    """
				Moves this node below its siblings, usually causing the node to draw on top of its siblings. Does nothing if this node does not have a parent. See also `Node.move_child`.
			"""
    pass

  def set_as_top_level(self, enable:bool)->None:
    """"""
    pass

  def is_set_as_top_level(self)->bool:
    """"""
    pass

  def set_light_mask(self, light_mask:int)->None:
    """"""
    pass

  def get_light_mask(self)->int:
    """"""
    pass

  def set_modulate(self, modulate:__core__.Color)->None:
    """"""
    pass

  def get_modulate(self)->__core__.Color:
    """"""
    pass

  def set_self_modulate(self, self_modulate:__core__.Color)->None:
    """"""
    pass

  def get_self_modulate(self)->__core__.Color:
    """"""
    pass

  def set_z_index(self, z_index:int)->None:
    """"""
    pass

  def get_z_index(self)->int:
    """"""
    pass

  def set_z_as_relative(self, enable:bool)->None:
    """"""
    pass

  def is_z_relative(self)->bool:
    """"""
    pass

  def set_y_sort_enabled(self, enabled:bool)->None:
    """"""
    pass

  def is_y_sort_enabled(self)->bool:
    """"""
    pass

  def set_draw_behind_parent(self, enable:bool)->None:
    """"""
    pass

  def is_draw_behind_parent_enabled(self)->bool:
    """"""
    pass

  def draw_line(self, from_:__core__.Vector2, to:__core__.Vector2, color:__core__.Color, width:float=-1.0, antialiased:bool=False)->None:
    """
				Draws a line from a 2D point to another, with a given color and width. It can be optionally antialiased. See also `draw_dashed_line`, `draw_multiline`, and `draw_polyline`.
				If `width` is negative, then a two-point primitive will be drawn instead of a four-point one. This means that when the CanvasItem is scaled, the line will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
			"""
    pass

  def draw_dashed_line(self, from_:__core__.Vector2, to:__core__.Vector2, color:__core__.Color, width:float=-1.0, dash:float=2.0, aligned:bool=True, antialiased:bool=False)->None:
    """
				Draws a dashed line from a 2D point to another, with a given color and width. See also `draw_line`, `draw_multiline`, and `draw_polyline`.
				If `width` is negative, then a two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the line parts will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
				`dash` is the length of each dash in pixels, with the gap between each dash being the same length. If `aligned` is `true`, the length of the first and last dashes may be shortened or lengthened to allow the line to begin and end at the precise points defined by `from` and `to`. Both ends are always symmetrical when `aligned` is `true`. If `aligned` is `false`, all dashes will have the same length, but the line may appear incomplete at the end due to the dash length not dividing evenly into the line length. Only full dashes are drawn when `aligned` is `false`.
				If `antialiased` is `true`, half transparent "feathers" will be attached to the boundary, making outlines smooth.
				**Note:** `antialiased` is only effective if `width` is greater than `0.0`.
			"""
    pass

  def draw_polyline(self, points:__core__.PackedVector2Array, color:__core__.Color, width:float=-1.0, antialiased:bool=False)->None:
    """
				Draws interconnected line segments with a uniform `color` and `width` and optional antialiasing (supported only for positive `width`). When drawing large amounts of lines, this is faster than using individual `draw_line` calls. To draw disconnected lines, use `draw_multiline` instead. See also `draw_polygon`.
				If `width` is negative, it will be ignored and the polyline will be drawn using `constant RenderingServer.PRIMITIVE_LINE_STRIP`. This means that when the CanvasItem is scaled, the polyline will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
			"""
    pass

  def draw_polyline_colors(self, points:__core__.PackedVector2Array, colors:__core__.PackedColorArray, width:float=-1.0, antialiased:bool=False)->None:
    """
				Draws interconnected line segments with a uniform `width`, point-by-point coloring, and optional antialiasing (supported only for positive `width`). Colors assigned to line points match by index between `points` and `colors`, i.e. each line segment is filled with a gradient between the colors of the endpoints. When drawing large amounts of lines, this is faster than using individual `draw_line` calls. To draw disconnected lines, use `draw_multiline_colors` instead. See also `draw_polygon`.
				If `width` is negative, it will be ignored and the polyline will be drawn using `constant RenderingServer.PRIMITIVE_LINE_STRIP`. This means that when the CanvasItem is scaled, the polyline will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
			"""
    pass

  def draw_arc(self, center:__core__.Vector2, radius:float, start_angle:float, end_angle:float, point_count:int, color:__core__.Color, width:float=-1.0, antialiased:bool=False)->None:
    """
				Draws an unfilled arc between the given angles with a uniform `color` and `width` and optional antialiasing (supported only for positive `width`). The larger the value of `point_count`, the smoother the curve. See also `draw_circle`.
				If `width` is negative, it will be ignored and the arc will be drawn using `constant RenderingServer.PRIMITIVE_LINE_STRIP`. This means that when the CanvasItem is scaled, the arc will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
				The arc is drawn from `start_angle` towards the value of `end_angle` so in clockwise direction if `start_angle < end_angle` and counter-clockwise otherwise. Passing the same angles but in reversed order will produce the same arc. If absolute difference of `start_angle` and `end_angle` is greater than `constant @GDScript.TAU` radians, then a full circle arc is drawn (i.e. arc will not overlap itself).
			"""
    pass

  def draw_multiline(self, points:__core__.PackedVector2Array, color:__core__.Color, width:float=-1.0, antialiased:bool=False)->None:
    """
				Draws multiple disconnected lines with a uniform `width` and `color`. Each line is defined by two consecutive points from `points` array, i.e. i-th segment consists of `points`2 * i``, `points`2 * i + 1`` endpoints. When drawing large amounts of lines, this is faster than using individual `draw_line` calls. To draw interconnected lines, use `draw_polyline` instead.
				If `width` is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
				**Note:** `antialiased` is only effective if `width` is greater than `0.0`.
			"""
    pass

  def draw_multiline_colors(self, points:__core__.PackedVector2Array, colors:__core__.PackedColorArray, width:float=-1.0, antialiased:bool=False)->None:
    """
				Draws multiple disconnected lines with a uniform `width` and segment-by-segment coloring. Each segment is defined by two consecutive points from `points` array and a corresponding color from `colors` array, i.e. i-th segment consists of `points`2 * i``, `points`2 * i + 1`` endpoints and has `colors_` color. When drawing large amounts of lines, this is faster than using individual `draw_line` calls. To draw interconnected lines, use `draw_polyline_colors` instead.
				If `width` is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
				**Note:** `antialiased` is only effective if `width` is greater than `0.0`.
			"""
    pass

  def draw_rect(self, rect:__core__.Rect2, color:__core__.Color, filled:bool=True, width:float=-1.0, antialiased:bool=False)->None:
    """
				Draws a rectangle. If `filled` is `true`, the rectangle will be filled with the `color` specified. If `filled` is `false`, the rectangle will be drawn as a stroke with the `color` and `width` specified. See also `draw_texture_rect`.
				If `width` is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
				If `antialiased` is `true`, half transparent "feathers" will be attached to the boundary, making outlines smooth.
				**Note:** `width` is only effective if `filled` is `false`.
				**Note:** Unfilled rectangles drawn with a negative `width` may not display perfectly. For example, corners may be missing or brighter due to overlapping lines (for a translucent `color`).
			"""
    pass

  def draw_circle(self, position:__core__.Vector2, radius:float, color:__core__.Color, filled:bool=True, width:float=-1.0, antialiased:bool=False)->None:
    """
				Draws a circle. See also `draw_arc`, `draw_polyline`, and `draw_polygon`.
				If `filled` is `true`, the circle will be filled with the `color` specified. If `filled` is `false`, the circle will be drawn as a stroke with the `color` and `width` specified.
				If `width` is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
				If `antialiased` is `true`, half transparent "feathers" will be attached to the boundary, making outlines smooth.
				**Note:** `width` is only effective if `filled` is `false`.
			"""
    pass

  def draw_texture(self, texture:__texture2d__.Texture2D, position:__core__.Vector2, modulate:__core__.Color= __core__.Color.new0())->None:
    """
				Draws a texture at a given position.
			"""
    pass

  def draw_texture_rect(self, texture:__texture2d__.Texture2D, rect:__core__.Rect2, tile:bool, modulate:__core__.Color= __core__.Color.new0(), transpose:bool=False)->None:
    """
				Draws a textured rectangle at a given position, optionally modulated by a color. If `transpose` is `true`, the texture will have its X and Y coordinates swapped. See also `draw_rect` and `draw_texture_rect_region`.
			"""
    pass

  def draw_texture_rect_region(self, texture:__texture2d__.Texture2D, rect:__core__.Rect2, src_rect:__core__.Rect2, modulate:__core__.Color= __core__.Color.new0(), transpose:bool=False, clip_uv:bool=True)->None:
    """
				Draws a textured rectangle from a texture's region (specified by `src_rect`) at a given position, optionally modulated by a color. If `transpose` is `true`, the texture will have its X and Y coordinates swapped. See also `draw_texture_rect`.
			"""
    pass

  def draw_msdf_texture_rect_region(self, texture:__texture2d__.Texture2D, rect:__core__.Rect2, src_rect:__core__.Rect2, modulate:__core__.Color= __core__.Color.new0(), outline:float=0.0, pixel_range:float=4.0, scale:float=1.0)->None:
    """
				Draws a textured rectangle region of the multichannel signed distance field texture at a given position, optionally modulated by a color. See `FontFile.multichannel_signed_distance_field` for more information and caveats about MSDF font rendering.
				If `outline` is positive, each alpha channel value of pixel in region is set to maximum value of true distance in the `outline` radius.
				Value of the `pixel_range` should the same that was used during distance field texture generation.
			"""
    pass

  def draw_lcd_texture_rect_region(self, texture:__texture2d__.Texture2D, rect:__core__.Rect2, src_rect:__core__.Rect2, modulate:__core__.Color= __core__.Color.new0())->None:
    """
				Draws a textured rectangle region of the font texture with LCD subpixel anti-aliasing at a given position, optionally modulated by a color.
				Texture is drawn using the following blend operation, blend mode of the `CanvasItemMaterial` is ignored:
				```gdscript
				dst.r = texture.r * modulate.r * modulate.a + dst.r * (1.0 - texture.r * modulate.a);
				dst.g = texture.g * modulate.g * modulate.a + dst.g * (1.0 - texture.g * modulate.a);
				dst.b = texture.b * modulate.b * modulate.a + dst.b * (1.0 - texture.b * modulate.a);
				dst.a = modulate.a + dst.a * (1.0 - modulate.a);
				```
			"""
    pass

  def draw_style_box(self, style_box:__stylebox__.StyleBox, rect:__core__.Rect2)->None:
    """
				Draws a styled rectangle.
			"""
    pass

  def draw_primitive(self, points:__core__.PackedVector2Array, colors:__core__.PackedColorArray, uvs:__core__.PackedVector2Array, texture:__texture2d__.Texture2D= __texture2d__.Texture2D.constructor())->None:
    """
				Draws a custom primitive. 1 point for a point, 2 points for a line, 3 points for a triangle, and 4 points for a quad. If 0 points or more than 4 points are specified, nothing will be drawn and an error message will be printed. See also `draw_line`, `draw_polyline`, `draw_polygon`, and `draw_rect`.
			"""
    pass

  def draw_polygon(self, points:__core__.PackedVector2Array, colors:__core__.PackedColorArray, uvs:__core__.PackedVector2Array= __core__.PackedVector2Array.new0(), texture:__texture2d__.Texture2D= __texture2d__.Texture2D.constructor())->None:
    """
				Draws a solid polygon of any number of points, convex or concave. Unlike `draw_colored_polygon`, each point's color can be changed individually. See also `draw_polyline` and `draw_polyline_colors`. If you need more flexibility (such as being able to use bones), use `RenderingServer.canvas_item_add_triangle_array` instead.
				**Note:** If you frequently redraw the same polygon with a large number of vertices, consider pre-calculating the triangulation with `Geometry2D.triangulate_polygon` and using `draw_mesh`, `draw_multimesh`, or `RenderingServer.canvas_item_add_triangle_array`.
			"""
    pass

  def draw_colored_polygon(self, points:__core__.PackedVector2Array, color:__core__.Color, uvs:__core__.PackedVector2Array= __core__.PackedVector2Array.new0(), texture:__texture2d__.Texture2D= __texture2d__.Texture2D.constructor())->None:
    """
				Draws a colored polygon of any number of points, convex or concave. Unlike `draw_polygon`, a single color must be specified for the whole polygon.
				**Note:** If you frequently redraw the same polygon with a large number of vertices, consider pre-calculating the triangulation with `Geometry2D.triangulate_polygon` and using `draw_mesh`, `draw_multimesh`, or `RenderingServer.canvas_item_add_triangle_array`.
			"""
    pass

  def draw_string(self, font:__font__.Font, pos:__core__.Vector2, text:str, alignment:int =0, width:float=-1, font_size:int=16, modulate:__core__.Color= __core__.Color.new0(), justification_flags:int=3, direction:int =0, orientation:int =0)->None:
    """
				Draws `text` using the specified `font` at the `pos` (bottom-left corner using the baseline of the font). The text will have its color multiplied by `modulate`. If `width` is greater than or equal to 0, the text will be clipped if it exceeds the specified width. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
				**Example:** Draw "Hello world", using the project's default font:
				
				```gdscript
				# If using this method in a script that redraws constantly, move the
				# `default_font` declaration to a member variable assigned in `_ready()`
				# so the Control is only created once.
				var default_font = ThemeDB.fallback_font
				var default_font_size = ThemeDB.fallback_font_size
				draw_string(default_font, Vector2(64, 64), "Hello world", HORIZONTAL_ALIGNMENT_LEFT, -1, default_font_size)
				```
				
				
				See also `Font.draw_string`.
			"""
    pass

  def draw_multiline_string(self, font:__font__.Font, pos:__core__.Vector2, text:str, alignment:int =0, width:float=-1, font_size:int=16, max_lines:int=-1, modulate:__core__.Color= __core__.Color.new0(), brk_flags:int=3, justification_flags:int=3, direction:int =0, orientation:int =0)->None:
    """
				Breaks `text` into lines and draws it using the specified `font` at the `pos` (top-left corner). The text will have its color multiplied by `modulate`. If `width` is greater than or equal to 0, the text will be clipped if it exceeds the specified width. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
			"""
    pass

  def draw_string_outline(self, font:__font__.Font, pos:__core__.Vector2, text:str, alignment:int =0, width:float=-1, font_size:int=16, size:int=1, modulate:__core__.Color= __core__.Color.new0(), justification_flags:int=3, direction:int =0, orientation:int =0)->None:
    """
				Draws `text` outline using the specified `font` at the `pos` (bottom-left corner using the baseline of the font). The text will have its color multiplied by `modulate`. If `width` is greater than or equal to 0, the text will be clipped if it exceeds the specified width. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
			"""
    pass

  def draw_multiline_string_outline(self, font:__font__.Font, pos:__core__.Vector2, text:str, alignment:int =0, width:float=-1, font_size:int=16, max_lines:int=-1, size:int=1, modulate:__core__.Color= __core__.Color.new0(), brk_flags:int=3, justification_flags:int=3, direction:int =0, orientation:int =0)->None:
    """
				Breaks `text` to the lines and draws text outline using the specified `font` at the `pos` (top-left corner). The text will have its color multiplied by `modulate`. If `width` is greater than or equal to 0, the text will be clipped if it exceeds the specified width. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
			"""
    pass

  def draw_char(self, font:__font__.Font, pos:__core__.Vector2, char:str, font_size:int=16, modulate:__core__.Color= __core__.Color.new0())->None:
    """
				Draws a string first character using a custom font. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
			"""
    pass

  def draw_char_outline(self, font:__font__.Font, pos:__core__.Vector2, char:str, font_size:int=16, size:int=-1, modulate:__core__.Color= __core__.Color.new0())->None:
    """
				Draws a string first character outline using a custom font. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
			"""
    pass

  def draw_mesh(self, mesh:__mesh__.Mesh, texture:__texture2d__.Texture2D, transform:__core__.Transform2D= __core__.Transform2D.new0(), modulate:__core__.Color= __core__.Color.new0())->None:
    """
				Draws a `Mesh` in 2D, using the provided texture. See `MeshInstance2D` for related documentation.
			"""
    pass

  def draw_multimesh(self, multimesh:__multimesh__.MultiMesh, texture:__texture2d__.Texture2D)->None:
    """
				Draws a `MultiMesh` in 2D with the provided texture. See `MultiMeshInstance2D` for related documentation.
			"""
    pass

  def draw_set_transform(self, position:__core__.Vector2, rotation:float=0.0, scale:__core__.Vector2= __core__.Vector2.new0())->None:
    """
				Sets a custom transform for drawing via components. Anything drawn afterwards will be transformed by this.
				**Note:** `FontFile.oversampling` does _not_ take `scale` into account. This means that scaling up/down will cause bitmap fonts and rasterized (non-MSDF) dynamic fonts to appear blurry or pixelated. To ensure text remains crisp regardless of scale, you can enable MSDF font rendering by enabling `ProjectSettings.gui/theme/default_font_multichannel_signed_distance_field` (applies to the default project font only), or enabling **Multichannel Signed Distance Field** in the import options of a DynamicFont for custom fonts. On system fonts, `SystemFont.multichannel_signed_distance_field` can be enabled in the inspector.
			"""
    pass

  def draw_set_transform_matrix(self, xform:__core__.Transform2D)->None:
    """
				Sets a custom transform for drawing via matrix. Anything drawn afterwards will be transformed by this.
			"""
    pass

  def draw_animation_slice(self, animation_length:float, slice_begin:float, slice_end:float, offset:float=0.0)->None:
    """
				Subsequent drawing commands will be ignored unless they fall within the specified animation slice. This is a faster way to implement animations that loop on background rather than redrawing constantly.
			"""
    pass

  def draw_end_animation(self)->None:
    """
				After submitting all animations slices via `draw_animation_slice`, this function can be used to revert drawing to its default state (all subsequent drawing commands will be visible). If you don't care about this particular use case, usage of this function after submitting the slices is not required.
			"""
    pass

  def get_transform(self)->__core__.Transform2D:
    """
				Returns the transform matrix of this `CanvasItem`.
			"""
    pass

  def get_global_transform(self)->__core__.Transform2D:
    """
				Returns the global transform matrix of this item, i.e. the combined transform up to the topmost `CanvasItem` node. The topmost item is a `CanvasItem` that either has no parent, has non-`CanvasItem` parent or it has `top_level` enabled.
			"""
    pass

  def get_global_transform_with_canvas(self)->__core__.Transform2D:
    """
				Returns the transform from the local coordinate system of this `CanvasItem` to the `Viewport`s coordinate system.
			"""
    pass

  def get_viewport_transform(self)->__core__.Transform2D:
    """
				Returns the transform of this node, converted from its registered canvas's coordinate system to its viewport embedder's coordinate system. See also `Viewport.get_final_transform` and `Node.get_viewport`.
			"""
    pass

  def get_viewport_rect(self)->__core__.Rect2:
    """
				Returns this node's viewport boundaries as a `Rect2`. See also `Node.get_viewport`.
			"""
    pass

  def get_canvas_transform(self)->__core__.Transform2D:
    """
				Returns the transform of this node, converted from its registered canvas's coordinate system to its viewport's coordinate system. See also `Node.get_viewport`.
			"""
    pass

  def get_screen_transform(self)->__core__.Transform2D:
    """
				Returns the transform of this `CanvasItem` in global screen coordinates (i.e. taking window position into account). Mostly useful for editor plugins.
				Equals to `get_global_transform` if the window is embedded (see `Viewport.gui_embed_subwindows`).
			"""
    pass

  def get_local_mouse_position(self)->__core__.Vector2:
    """
				Returns the mouse's position in this `CanvasItem` using the local coordinate system of this `CanvasItem`.
			"""
    pass

  def get_global_mouse_position(self)->__core__.Vector2:
    """
				Returns mouse cursor's global position relative to the `CanvasLayer` that contains this node.
				**Note:** For screen-space coordinates (e.g. when using a non-embedded `Popup`), you can use `DisplayServer.mouse_get_position`.
			"""
    pass

  def get_canvas(self)->__core__.RID:
    """
				Returns the `RID` of the `World2D` canvas where this node is registered to, used by the `RenderingServer`.
			"""
    pass

  def get_canvas_layer_node(self)->__canvaslayer__.CanvasLayer|__parallaxbackground__.ParallaxBackground:
    """
				Returns the `CanvasLayer` that contains this node, or `null` if the node is not in any `CanvasLayer`.
			"""
    pass

  def get_world_2d(self)->__world2d__.World2D:
    """
				Returns the `World2D` this node is registered to.
				Usually, this is the same as this node's viewport (see `Node.get_viewport` and `Viewport.find_world_2d`).
			"""
    pass

  def set_material(self, material:__material__.Material)->None:
    """"""
    pass

  def get_material(self)->__physicalskymaterial__.PhysicalSkyMaterial|__shadermaterial__.ShaderMaterial|__canvasitemmaterial__.CanvasItemMaterial|__material__.Material|__particleprocessmaterial__.ParticleProcessMaterial|__proceduralskymaterial__.ProceduralSkyMaterial|__fogmaterial__.FogMaterial|__basematerial3d__.BaseMaterial3D|__placeholdermaterial__.PlaceholderMaterial|__ormmaterial3d__.ORMMaterial3D|__standardmaterial3d__.StandardMaterial3D|__panoramaskymaterial__.PanoramaSkyMaterial:
    """"""
    pass

  def set_instance_shader_parameter(self, name:__core__.StringName|str, value:Any)->None:
    """
				Set the value of a shader uniform for this instance only (`url=$DOCS_URL/tutorials/shaders/shader_reference/shading_language.html#per-instance-uniforms`per-instance uniform`/url`). See also `ShaderMaterial.set_shader_parameter` to assign a uniform on all instances using the same `ShaderMaterial`.
				**Note:** For a shader uniform to be assignable on a per-instance basis, it _must_ be defined with `instance uniform ...` rather than `uniform ...` in the shader code.
				**Note:** `name` is case-sensitive and must match the name of the uniform in the code exactly (not the capitalized name in the inspector).
			"""
    pass

  def get_instance_shader_parameter(self, name:__core__.StringName|str)->Any:
    """
				Get the value of a shader parameter as set on this instance.
			"""
    pass

  def set_use_parent_material(self, enable:bool)->None:
    """"""
    pass

  def get_use_parent_material(self)->bool:
    """"""
    pass

  def set_notify_local_transform(self, enable:bool)->None:
    """
				If `true`, the node will receive `constant NOTIFICATION_LOCAL_TRANSFORM_CHANGED` whenever its local transform changes.
				**Note:** Many canvas items such as `Bone2D` or `CollisionShape2D` automatically enable this in order to function correctly.
			"""
    pass

  def is_local_transform_notification_enabled(self)->bool:
    """
				Returns `true` if the node receives `constant NOTIFICATION_LOCAL_TRANSFORM_CHANGED` whenever its local transform changes. This is enabled with `set_notify_local_transform`.
			"""
    pass

  def set_notify_transform(self, enable:bool)->None:
    """
				If `true`, the node will receive `constant NOTIFICATION_TRANSFORM_CHANGED` whenever global transform changes.
				**Note:** Many canvas items such as `Camera2D` or `Light2D` automatically enable this in order to function correctly.
			"""
    pass

  def is_transform_notification_enabled(self)->bool:
    """
				Returns `true` if the node receives `constant NOTIFICATION_TRANSFORM_CHANGED` whenever its global transform changes. This is enabled with `set_notify_transform`.
			"""
    pass

  def force_update_transform(self)->None:
    """
				Forces the node's transform to update. Fails if the node is not inside the tree. See also `get_transform`.
				**Note:** For performance reasons, transform changes are usually accumulated and applied _once_ at the end of the frame. The update propagates through `CanvasItem` children, as well. Therefore, use this method only when you need an up-to-date transform (such as during physics operations).
			"""
    pass

  def make_canvas_position_local(self, viewport_point:__core__.Vector2)->__core__.Vector2:
    """
				Transforms `viewport_point` from the viewport's coordinates to this node's local coordinates.
				For the opposite operation, use `get_global_transform_with_canvas`.
				```gdscript
				var viewport_point = get_global_transform_with_canvas() * local_point
				```
			"""
    pass

  def make_input_local(self, event:__inputevent__.InputEvent)->__inputeventmousemotion__.InputEventMouseMotion|__inputeventpangesture__.InputEventPanGesture|__inputeventwithmodifiers__.InputEventWithModifiers|__inputeventfromwindow__.InputEventFromWindow|__inputeventmagnifygesture__.InputEventMagnifyGesture|__inputeventmousebutton__.InputEventMouseButton|__inputevent__.InputEvent|__inputeventmouse__.InputEventMouse|__inputeventscreentouch__.InputEventScreenTouch|__inputeventgesture__.InputEventGesture|__inputeventkey__.InputEventKey|__inputeventaction__.InputEventAction|__inputeventscreendrag__.InputEventScreenDrag|__inputeventjoypadmotion__.InputEventJoypadMotion|__inputeventshortcut__.InputEventShortcut|__inputeventmidi__.InputEventMIDI|__inputeventjoypadbutton__.InputEventJoypadButton:
    """
				Returns a copy of the given `event` with its coordinates converted from global space to this `CanvasItem`'s local space. If not possible, returns the same `InputEvent` unchanged.
			"""
    pass

  def set_visibility_layer(self, layer:int)->None:
    """"""
    pass

  def get_visibility_layer(self)->int:
    """"""
    pass

  def set_visibility_layer_bit(self, layer:int, enabled:bool)->None:
    """
				Set/clear individual bits on the rendering visibility layer. This simplifies editing this `CanvasItem`'s visibility layer.
			"""
    pass

  def get_visibility_layer_bit(self, layer:int)->bool:
    """
				Returns `true` if the layer at the given index is set in `visibility_layer`.
			"""
    pass

  def set_texture_filter(self, mode:int )->None:
    """"""
    pass

  def get_texture_filter(self)->int:
    """"""
    pass

  def set_texture_repeat(self, mode:int )->None:
    """"""
    pass

  def get_texture_repeat(self)->int:
    """"""
    pass

  def set_clip_children_mode(self, mode:int )->None:
    """"""
    pass

  def get_clip_children_mode(self)->int:
    """"""
    pass


