from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.WebSocketMultiplayerPeer as __websocketmultiplayerpeer__
import py4godot.classes.MultiplayerPeer as __multiplayerpeer__
import py4godot.classes.OfflineMultiplayerPeer as __offlinemultiplayerpeer__
import py4godot.classes.MultiplayerPeerExtension as __multiplayerpeerextension__
import py4godot.classes.ENetMultiplayerPeer as __enetmultiplayerpeer__
import py4godot.classes.Object as __object__
import py4godot.classes.WebRTCMultiplayerPeer as __webrtcmultiplayerpeer__
import py4godot.classes.MultiplayerAPI as __multiplayerapi__



class MultiplayerAPIExtension(__multiplayerapi__.MultiplayerAPI):
  """
		This class can be used to extend or replace the default `MultiplayerAPI` implementation via script or extensions.
		The following example extend the default implementation (`SceneMultiplayer`) by logging every RPC being made, and every object being configured for replication.
		
		```gdscript
		extends MultiplayerAPIExtension
		class_name LogMultiplayer

		# We want to extend the default SceneMultiplayer.
		var base_multiplayer = SceneMultiplayer.new()

		func _init():
			# Just passthrough base signals (copied to var to avoid cyclic reference)
			var cts = connected_to_server
			var cf = connection_failed
			var sd = server_disconnected
			var pc = peer_connected
			var pd = peer_disconnected
			base_multiplayer.connected_to_server.connect(func(): cts.emit())
			base_multiplayer.connection_failed.connect(func(): cf.emit())
			base_multiplayer.server_disconnected.connect(func(): sd.emit())
			base_multiplayer.peer_connected.connect(func(id): pc.emit(id))
			base_multiplayer.peer_disconnected.connect(func(id): pd.emit(id))

		func _poll():
			return base_multiplayer.poll()

		# Log RPC being made and forward it to the default multiplayer.
		func _rpc(peer: int, object: Object, method: StringName, args: Array) -> Error:
			print("Got RPC for %d: %s::%s(%s)" % `peer, object, method, args`)
			return base_multiplayer.rpc(peer, object, method, args)

		# Log configuration add. E.g. root path (nullptr, NodePath), replication (Node, Spawner|Synchronizer), custom.
		func _object_configuration_add(object, config: Variant) -> Error:
			if config is MultiplayerSynchronizer:
				print("Adding synchronization configuration for %s. Synchronizer: %s" % `object, config`)
			elif config is MultiplayerSpawner:
				print("Adding node %s to the spawn list. Spawner: %s" % `object, config`)
			return base_multiplayer.object_configuration_add(object, config)

		# Log configuration remove. E.g. root path (nullptr, NodePath), replication (Node, Spawner|Synchronizer), custom.
		func _object_configuration_remove(object, config: Variant) -> Error:
			if config is MultiplayerSynchronizer:
				print("Removing synchronization configuration for %s. Synchronizer: %s" % `object, config`)
			elif config is MultiplayerSpawner:
				print("Removing node %s from the spawn list. Spawner: %s" % `object, config`)
			return base_multiplayer.object_configuration_remove(object, config)

		# These can be optional, but in our case we want to extend SceneMultiplayer, so forward everything.
		func _set_multiplayer_peer(p_peer: MultiplayerPeer):
			base_multiplayer.multiplayer_peer = p_peer

		func _get_multiplayer_peer() -> MultiplayerPeer:
			return base_multiplayer.multiplayer_peer

		func _get_unique_id() -> int:
			return base_multiplayer.get_unique_id()

		func _get_remote_sender_id() -> int:
			return base_multiplayer.get_remote_sender_id()

		func _get_peer_ids() -> PackedInt32Array:
			return base_multiplayer.get_peers()
		```
		
		Then in your main scene or in an autoload call `SceneTree.set_multiplayer` to start using your custom `MultiplayerAPI`:
		
		```gdscript
		# autoload.gd
		func _enter_tree():
			# Sets our custom multiplayer as the main one in SceneTree.
			get_tree().set_multiplayer(LogMultiplayer.new())
		```
		
		Native extensions can alternatively use the `MultiplayerAPI.set_default_interface` method during initialization to configure themselves as the default implementation.
	"""

  @staticmethod
  def constructor()->MultiplayerAPIExtension:pass



  @staticmethod
  def cast(other:__object__.Object)->MultiplayerAPIExtension:pass


  def _poll(self)->int:
    """
				Callback for `MultiplayerAPI.poll`.
			"""
    pass

  def _set_multiplayer_peer(self, multiplayer_peer:__multiplayerpeer__.MultiplayerPeer)->None:
    """
				Called when the `MultiplayerAPI.multiplayer_peer` is set.
			"""
    pass

  def _get_multiplayer_peer(self)->__multiplayerpeer__.MultiplayerPeer|__websocketmultiplayerpeer__.WebSocketMultiplayerPeer|__enetmultiplayerpeer__.ENetMultiplayerPeer|__webrtcmultiplayerpeer__.WebRTCMultiplayerPeer|__offlinemultiplayerpeer__.OfflineMultiplayerPeer|__multiplayerpeerextension__.MultiplayerPeerExtension:
    """
				Called when the `MultiplayerAPI.multiplayer_peer` is retrieved.
			"""
    pass

  def _get_unique_id(self)->int:
    """
				Callback for `MultiplayerAPI.get_unique_id`.
			"""
    pass

  def _get_peer_ids(self)->__core__.PackedInt32Array:
    """
				Callback for `MultiplayerAPI.get_peers`.
			"""
    pass

  def _rpc(self, peer:int, object:__object__.Object, method:__core__.StringName|str, args:__core__.Array)->int:
    """
				Callback for `MultiplayerAPI.rpc`.
			"""
    pass

  def _get_remote_sender_id(self)->int:
    """
				Callback for `MultiplayerAPI.get_remote_sender_id`.
			"""
    pass

  def _object_configuration_add(self, object:__object__.Object, configuration:Any)->int:
    """
				Callback for `MultiplayerAPI.object_configuration_add`.
			"""
    pass

  def _object_configuration_remove(self, object:__object__.Object, configuration:Any)->int:
    """
				Callback for `MultiplayerAPI.object_configuration_remove`.
			"""
    pass


