from py4godot.utils.VariantTypeWrapper4 import *
import py4godot.classes.Object as __object__
from typing import Any

import py4godot.classes.core as __core__
from py4godot.signals import BuiltinSignal
import py4godot.classes.Image as __image__
import py4godot.classes.Shape3D as __shape3d__



class HeightMapShape3D(__shape3d__.Shape3D):
  """
		A 3D heightmap shape, intended for use in physics. Usually used to provide a shape for a `CollisionShape3D`. This type is most commonly used for terrain with vertices placed in a fixed width grid. Due to the nature of the heightmap, it cannot be used to model overhangs or caves, which would require multiple vertices at the same vertical location. Holes can be punched through the collision by assigning `constant @GDScript.NAN` to the height of the desired vertices (this is supported in both GodotPhysics3D and Jolt Physics). You could then insert meshes with their own separate collision to provide overhangs, caves, and so on.
		**Performance:** `HeightMapShape3D` is faster to check collisions against than `ConcavePolygonShape3D`, but it is significantly slower than primitive shapes like `BoxShape3D`.
		A heightmap collision shape can also be built by using an `Image` reference:
		
		```gdscript
		var heightmap_texture = ResourceLoader.load("res://heightmap_image.exr")
		var heightmap_image = heightmap_texture.get_image()
		heightmap_image.convert(Image.FORMAT_RF)

		var height_min = 0.0
		var height_max = 10.0

		update_map_data_from_image(heightmap_image, height_min, height_max)
		```
		
	"""

  @staticmethod
  def constructor()->HeightMapShape3D:pass



  @staticmethod
  def cast(other:__object__.Object)->HeightMapShape3D:pass


  @property
  def map_width(self)->int:
    """"""
    pass
  @map_width.setter
  def map_width(self,  value:int)->None:
    """"""
    pass
  @property
  def map_depth(self)->int:
    """"""
    pass
  @map_depth.setter
  def map_depth(self,  value:int)->None:
    """"""
    pass
  @property
  def map_data(self)->__core__.PackedFloat32Array:
    """"""
    pass
  @map_data.setter
  def map_data(self,  value:__core__.PackedFloat32Array)->None:
    """"""
    pass
  def set_map_width(self, width:int)->None:
    """"""
    pass

  def get_map_width(self)->int:
    """"""
    pass

  def set_map_depth(self, height:int)->None:
    """"""
    pass

  def get_map_depth(self)->int:
    """"""
    pass

  def set_map_data(self, data:__core__.PackedFloat32Array)->None:
    """"""
    pass

  def get_map_data(self)->__core__.PackedFloat32Array:
    """"""
    pass

  def get_min_height(self)->float:
    """
				Returns the smallest height value found in `map_data`. Recalculates only when `map_data` changes.
			"""
    pass

  def get_max_height(self)->float:
    """
				Returns the largest height value found in `map_data`. Recalculates only when `map_data` changes.
			"""
    pass

  def update_map_data_from_image(self, image:__image__.Image, height_min:float, height_max:float)->None:
    """
				Updates `map_data` with data read from an `Image` reference. Automatically resizes heightmap `map_width` and `map_depth` to fit the full image width and height.
				The image needs to be in either `constant Image.FORMAT_RF` (32 bit), `constant Image.FORMAT_RH` (16 bit), or `constant Image.FORMAT_R8` (8 bit).
				Each image pixel is read in as a float on the range from `0.0` (black pixel) to `1.0` (white pixel). This range value gets remapped to `height_min` and `height_max` to form the final height value.
				**Note:** Using a heightmap with 16-bit or 32-bit data, stored in EXR or HDR format is recommended. Using 8-bit height data, or a format like PNG that Godot imports as 8-bit, will result in a terraced terrain.
			"""
    pass


